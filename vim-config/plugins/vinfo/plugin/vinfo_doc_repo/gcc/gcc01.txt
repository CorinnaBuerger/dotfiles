          This is the warning level of '-Wshift-overflow' and is enabled
          by default in C99 and C++11 modes (and newer).  This warning
          level does not warn about left-shifting 1 into the sign bit.
          (However, in C, such an overflow is still rejected in contexts
          where an integer constant expression is required.)  No warning
          is emitted in C++2A mode (and newer), as signed left shifts
          always wrap.

     '-Wshift-overflow=2'
          This warning level also warns about left-shifting 1 into the
          sign bit, unless C++14 mode (or newer) is active.

'-Wswitch'
     Warn whenever a 'switch' statement has an index of enumerated type
     and lacks a 'case' for one or more of the named codes of that
     enumeration.  (The presence of a 'default' label prevents this
     warning.)  'case' labels outside the enumeration range also provoke
     warnings when this option is used (even if there is a 'default'
     label).  This warning is enabled by '-Wall'.

'-Wswitch-default'
     Warn whenever a 'switch' statement does not have a 'default' case.

'-Wswitch-enum'
     Warn whenever a 'switch' statement has an index of enumerated type
     and lacks a 'case' for one or more of the named codes of that
     enumeration.  'case' labels outside the enumeration range also
     provoke warnings when this option is used.  The only difference
     between '-Wswitch' and this option is that this option gives a
     warning about an omitted enumeration code even if there is a
     'default' label.

'-Wswitch-bool'
     Warn whenever a 'switch' statement has an index of boolean type and
     the case values are outside the range of a boolean type.  It is
     possible to suppress this warning by casting the controlling
     expression to a type other than 'bool'.  For example:
          switch ((int) (a == 4))
            {
            ...
            }
     This warning is enabled by default for C and C++ programs.

'-Wswitch-unreachable'
     Warn whenever a 'switch' statement contains statements between the
     controlling expression and the first case label, which will never
     be executed.  For example:
          switch (cond)
            {
             i = 15;
            ...
             case 5:
            ...
            }
     '-Wswitch-unreachable' does not warn if the statement between the
     controlling expression and the first case label is just a
     declaration:
          switch (cond)
            {
             int i;
            ...
             case 5:
             i = 5;
            ...
            }
     This warning is enabled by default for C and C++ programs.

'-Wsync-nand (C and C++ only)'
     Warn when '__sync_fetch_and_nand' and '__sync_nand_and_fetch'
     built-in functions are used.  These functions changed semantics in
     GCC 4.4.

'-Wunused-but-set-parameter'
     Warn whenever a function parameter is assigned to, but otherwise
     unused (aside from its declaration).

     To suppress this warning use the 'unused' attribute (*note Variable
     Attributes::).

     This warning is also enabled by '-Wunused' together with '-Wextra'.

'-Wunused-but-set-variable'
     Warn whenever a local variable is assigned to, but otherwise unused
     (aside from its declaration).  This warning is enabled by '-Wall'.

     To suppress this warning use the 'unused' attribute (*note Variable
     Attributes::).

     This warning is also enabled by '-Wunused', which is enabled by
     '-Wall'.

'-Wunused-function'
     Warn whenever a static function is declared but not defined or a
     non-inline static function is unused.  This warning is enabled by
     '-Wall'.

'-Wunused-label'
     Warn whenever a label is declared but not used.  This warning is
     enabled by '-Wall'.

     To suppress this warning use the 'unused' attribute (*note Variable
     Attributes::).

'-Wunused-local-typedefs (C, Objective-C, C++ and Objective-C++ only)'
     Warn when a typedef locally defined in a function is not used.
     This warning is enabled by '-Wall'.

'-Wunused-parameter'
     Warn whenever a function parameter is unused aside from its
     declaration.

     To suppress this warning use the 'unused' attribute (*note Variable
     Attributes::).

'-Wno-unused-result'
     Do not warn if a caller of a function marked with attribute
     'warn_unused_result' (*note Function Attributes::) does not use its
     return value.  The default is '-Wunused-result'.

'-Wunused-variable'
     Warn whenever a local or static variable is unused aside from its
     declaration.  This option implies '-Wunused-const-variable=1' for
     C, but not for C++.  This warning is enabled by '-Wall'.

     To suppress this warning use the 'unused' attribute (*note Variable
     Attributes::).

'-Wunused-const-variable'
'-Wunused-const-variable=N'
     Warn whenever a constant static variable is unused aside from its
     declaration.  '-Wunused-const-variable=1' is enabled by
     '-Wunused-variable' for C, but not for C++.  In C this declares
     variable storage, but in C++ this is not an error since const
     variables take the place of '#define's.

     To suppress this warning use the 'unused' attribute (*note Variable
     Attributes::).

     '-Wunused-const-variable=1'
          This is the warning level that is enabled by
          '-Wunused-variable' for C. It warns only about unused static
          const variables defined in the main compilation unit, but not
          about static const variables declared in any header included.

     '-Wunused-const-variable=2'
          This warning level also warns for unused constant static
          variables in headers (excluding system headers).  This is the
          warning level of '-Wunused-const-variable' and must be
          explicitly requested since in C++ this isn't an error and in C
          it might be harder to clean up all headers included.

'-Wunused-value'
     Warn whenever a statement computes a result that is explicitly not
     used.  To suppress this warning cast the unused expression to
     'void'.  This includes an expression-statement or the left-hand
     side of a comma expression that contains no side effects.  For
     example, an expression such as 'x[i,j]' causes a warning, while
     'x[(void)i,j]' does not.

     This warning is enabled by '-Wall'.

'-Wunused'
     All the above '-Wunused' options combined.

     In order to get a warning about an unused function parameter, you
     must either specify '-Wextra -Wunused' (note that '-Wall' implies
     '-Wunused'), or separately specify '-Wunused-parameter'.

'-Wuninitialized'
     Warn if an automatic variable is used without first being
     initialized or if a variable may be clobbered by a 'setjmp' call.
     In C++, warn if a non-static reference or non-static 'const' member
     appears in a class without constructors.

     If you want to warn about code that uses the uninitialized value of
     the variable in its own initializer, use the '-Winit-self' option.

     These warnings occur for individual uninitialized or clobbered
     elements of structure, union or array variables as well as for
     variables that are uninitialized or clobbered as a whole.  They do
     not occur for variables or elements declared 'volatile'.  Because
     these warnings depend on optimization, the exact variables or
     elements for which there are warnings depends on the precise
     optimization options and version of GCC used.

     Note that there may be no warning about a variable that is used
     only to compute a value that itself is never used, because such
     computations may be deleted by data flow analysis before the
     warnings are printed.

'-Winvalid-memory-model'
     Warn for invocations of *note __atomic Builtins::, *note __sync
     Builtins::, and the C11 atomic generic functions with a memory
     consistency argument that is either invalid for the operation or
     outside the range of values of the 'memory_order' enumeration.  For
     example, since the '__atomic_store' and '__atomic_store_n'
     built-ins are only defined for the relaxed, release, and
     sequentially consistent memory orders the following code is
     diagnosed:

          void store (int *i)
          {
            __atomic_store_n (i, 0, memory_order_consume);
          }

     '-Winvalid-memory-model' is enabled by default.

'-Wmaybe-uninitialized'
     For an automatic (i.e. local) variable, if there exists a path from
     the function entry to a use of the variable that is initialized,
     but there exist some other paths for which the variable is not
     initialized, the compiler emits a warning if it cannot prove the
     uninitialized paths are not executed at run time.

     These warnings are only possible in optimizing compilation, because
     otherwise GCC does not keep track of the state of variables.

     These warnings are made optional because GCC may not be able to
     determine when the code is correct in spite of appearing to have an
     error.  Here is one example of how this can happen:

          {
            int x;
            switch (y)
              {
              case 1: x = 1;
                break;
              case 2: x = 4;
                break;
              case 3: x = 5;
              }
            foo (x);
          }

     If the value of 'y' is always 1, 2 or 3, then 'x' is always
     initialized, but GCC doesn't know this.  To suppress the warning,
     you need to provide a default case with assert(0) or similar code.

     This option also warns when a non-volatile automatic variable might
     be changed by a call to 'longjmp'.  The compiler sees only the
     calls to 'setjmp'.  It cannot know where 'longjmp' will be called;
     in fact, a signal handler could call it at any point in the code.
     As a result, you may get a warning even when there is in fact no
     problem because 'longjmp' cannot in fact be called at the place
     that would cause a problem.

     Some spurious warnings can be avoided if you declare all the
     functions you use that never return as 'noreturn'.  *Note Function
     Attributes::.

     This warning is enabled by '-Wall' or '-Wextra'.

'-Wunknown-pragmas'
     Warn when a '#pragma' directive is encountered that is not
     understood by GCC.  If this command-line option is used, warnings
     are even issued for unknown pragmas in system header files.  This
     is not the case if the warnings are only enabled by the '-Wall'
     command-line option.

'-Wno-pragmas'
     Do not warn about misuses of pragmas, such as incorrect parameters,
     invalid syntax, or conflicts between pragmas.  See also
     '-Wunknown-pragmas'.

'-Wno-prio-ctor-dtor'
     Do not warn if a priority from 0 to 100 is used for constructor or
     destructor.  The use of constructor and destructor attributes allow
     you to assign a priority to the constructor/destructor to control
     its order of execution before 'main' is called or after it returns.
     The priority values must be greater than 100 as the compiler
     reserves priority values between 0-100 for the implementation.

'-Wstrict-aliasing'
     This option is only active when '-fstrict-aliasing' is active.  It
     warns about code that might break the strict aliasing rules that
     the compiler is using for optimization.  The warning does not catch
     all cases, but does attempt to catch the more common pitfalls.  It
     is included in '-Wall'.  It is equivalent to '-Wstrict-aliasing=3'

'-Wstrict-aliasing=n'
     This option is only active when '-fstrict-aliasing' is active.  It
     warns about code that might break the strict aliasing rules that
     the compiler is using for optimization.  Higher levels correspond
     to higher accuracy (fewer false positives).  Higher levels also
     correspond to more effort, similar to the way '-O' works.
     '-Wstrict-aliasing' is equivalent to '-Wstrict-aliasing=3'.

     Level 1: Most aggressive, quick, least accurate.  Possibly useful
     when higher levels do not warn but '-fstrict-aliasing' still breaks
     the code, as it has very few false negatives.  However, it has many
     false positives.  Warns for all pointer conversions between
     possibly incompatible types, even if never dereferenced.  Runs in
     the front end only.

     Level 2: Aggressive, quick, not too precise.  May still have many
     false positives (not as many as level 1 though), and few false
     negatives (but possibly more than level 1).  Unlike level 1, it
     only warns when an address is taken.  Warns about incomplete types.
     Runs in the front end only.

     Level 3 (default for '-Wstrict-aliasing'): Should have very few
     false positives and few false negatives.  Slightly slower than
     levels 1 or 2 when optimization is enabled.  Takes care of the
     common pun+dereference pattern in the front end:
     '(int)&some_float'.  If optimization is enabled, it also runs in
     the back end, where it deals with multiple statement cases using
     flow-sensitive points-to information.  Only warns when the
     converted pointer is dereferenced.  Does not warn about incomplete
     types.

'-Wstrict-overflow'
'-Wstrict-overflow=N'
     This option is only active when signed overflow is undefined.  It
     warns about cases where the compiler optimizes based on the
     assumption that signed overflow does not occur.  Note that it does
     not warn about all cases where the code might overflow: it only
     warns about cases where the compiler implements some optimization.
     Thus this warning depends on the optimization level.

     An optimization that assumes that signed overflow does not occur is
     perfectly safe if the values of the variables involved are such
     that overflow never does, in fact, occur.  Therefore this warning
     can easily give a false positive: a warning about code that is not
     actually a problem.  To help focus on important issues, several
     warning levels are defined.  No warnings are issued for the use of
     undefined signed overflow when estimating how many iterations a
     loop requires, in particular when determining whether a loop will
     be executed at all.

     '-Wstrict-overflow=1'
          Warn about cases that are both questionable and easy to avoid.
          For example the compiler simplifies 'x + 1 > x' to '1'.  This
          level of '-Wstrict-overflow' is enabled by '-Wall'; higher
          levels are not, and must be explicitly requested.

     '-Wstrict-overflow=2'
          Also warn about other cases where a comparison is simplified
          to a constant.  For example: 'abs (x) >= 0'.  This can only be
          simplified when signed integer overflow is undefined, because
          'abs (INT_MIN)' overflows to 'INT_MIN', which is less than
          zero.  '-Wstrict-overflow' (with no level) is the same as
          '-Wstrict-overflow=2'.

     '-Wstrict-overflow=3'
          Also warn about other cases where a comparison is simplified.
          For example: 'x + 1 > 1' is simplified to 'x > 0'.

     '-Wstrict-overflow=4'
          Also warn about other simplifications not covered by the above
          cases.  For example: '(x * 10) / 5' is simplified to 'x * 2'.

     '-Wstrict-overflow=5'
          Also warn about cases where the compiler reduces the magnitude
          of a constant involved in a comparison.  For example: 'x + 2 >
          y' is simplified to 'x + 1 >= y'.  This is reported only at
          the highest warning level because this simplification applies
          to many comparisons, so this warning level gives a very large
          number of false positives.

'-Wstringop-overflow'
'-Wstringop-overflow=TYPE'
     Warn for calls to string manipulation functions such as 'memcpy'
     and 'strcpy' that are determined to overflow the destination
     buffer.  The optional argument is one greater than the type of
     Object Size Checking to perform to determine the size of the
     destination.  *Note Object Size Checking::.  The argument is
     meaningful only for functions that operate on character arrays but
     not for raw memory functions like 'memcpy' which always make use of
     Object Size type-0.  The option also warns for calls that specify a
     size in excess of the largest possible object or at most 'SIZE_MAX
     / 2' bytes.  The option produces the best results with optimization
     enabled but can detect a small subset of simple buffer overflows
     even without optimization in calls to the GCC built-in functions
     like '__builtin_memcpy' that correspond to the standard functions.
     In any case, the option warns about just a subset of buffer
     overflows detected by the corresponding overflow checking
     built-ins.  For example, the option will issue a warning for the
     'strcpy' call below because it copies at least 5 characters (the
     string '"blue"' including the terminating NUL) into the buffer of
     size 4.

          enum Color { blue, purple, yellow };
          const char* f (enum Color clr)
          {
            static char buf [4];
            const char *str;
            switch (clr)
              {
                case blue: str = "blue"; break;
                case purple: str = "purple"; break;
                case yellow: str = "yellow"; break;
              }

            return strcpy (buf, str);   // warning here
          }

     Option '-Wstringop-overflow=2' is enabled by default.

     '-Wstringop-overflow'
     '-Wstringop-overflow=1'
          The '-Wstringop-overflow=1' option uses type-zero Object Size
          Checking to determine the sizes of destination objects.  This
          is the default setting of the option.  At this setting the
          option will not warn for writes past the end of subobjects of
          larger objects accessed by pointers unless the size of the
          largest surrounding object is known.  When the destination may
          be one of several objects it is assumed to be the largest one
          of them.  On Linux systems, when optimization is enabled at
          this setting the option warns for the same code as when the
          '_FORTIFY_SOURCE' macro is defined to a non-zero value.

     '-Wstringop-overflow=2'
          The '-Wstringop-overflow=2' option uses type-one Object Size
          Checking to determine the sizes of destination objects.  At
          this setting the option will warn about overflows when writing
          to members of the largest complete objects whose exact size is
          known.  It will, however, not warn for excessive writes to the
          same members of unknown objects referenced by pointers since
          they may point to arrays containing unknown numbers of
          elements.

     '-Wstringop-overflow=3'
          The '-Wstringop-overflow=3' option uses type-two Object Size
          Checking to determine the sizes of destination objects.  At
          this setting the option warns about overflowing the smallest
          object or data member.  This is the most restrictive setting
          of the option that may result in warnings for safe code.

     '-Wstringop-overflow=4'
          The '-Wstringop-overflow=4' option uses type-three Object Size
          Checking to determine the sizes of destination objects.  At
          this setting the option will warn about overflowing any data
          members, and when the destination is one of several objects it
          uses the size of the largest of them to decide whether to
          issue a warning.  Similarly to '-Wstringop-overflow=3' this
          setting of the option may result in warnings for benign code.

'-Wstringop-truncation'
     Warn for calls to bounded string manipulation functions such as
     'strncat', 'strncpy', and 'stpncpy' that may either truncate the
     copied string or leave the destination unchanged.

     In the following example, the call to 'strncat' specifies a bound
     that is less than the length of the source string.  As a result,
     the copy of the source will be truncated and so the call is
     diagnosed.  To avoid the warning use 'bufsize - strlen (buf) - 1)'
     as the bound.

          void append (char *buf, size_t bufsize)
          {
            strncat (buf, ".txt", 3);
          }

     As another example, the following call to 'strncpy' results in
     copying to 'd' just the characters preceding the terminating NUL,
     without appending the NUL to the end.  Assuming the result of
     'strncpy' is necessarily a NUL-terminated string is a common
     mistake, and so the call is diagnosed.  To avoid the warning when
     the result is not expected to be NUL-terminated, call 'memcpy'
     instead.

          void copy (char *d, const char *s)
          {
            strncpy (d, s, strlen (s));
          }

     In the following example, the call to 'strncpy' specifies the size
     of the destination buffer as the bound.  If the length of the
     source string is equal to or greater than this size the result of
     the copy will not be NUL-terminated.  Therefore, the call is also
     diagnosed.  To avoid the warning, specify 'sizeof buf - 1' as the
     bound and set the last element of the buffer to 'NUL'.

          void copy (const char *s)
          {
            char buf[80];
            strncpy (buf, s, sizeof buf);
            ...
          }

     In situations where a character array is intended to store a
     sequence of bytes with no terminating 'NUL' such an array may be
     annotated with attribute 'nonstring' to avoid this warning.  Such
     arrays, however, are not suitable arguments to functions that
     expect 'NUL'-terminated strings.  To help detect accidental misuses
     of such arrays GCC issues warnings unless it can prove that the use
     is safe.  *Note Common Variable Attributes::.

'-Wsuggest-attribute=[pure|const|noreturn|format|cold|malloc]'
     Warn for cases where adding an attribute may be beneficial.  The
     attributes currently supported are listed below.

     '-Wsuggest-attribute=pure'
     '-Wsuggest-attribute=const'
     '-Wsuggest-attribute=noreturn'
     '-Wmissing-noreturn'
     '-Wsuggest-attribute=malloc'

          Warn about functions that might be candidates for attributes
          'pure', 'const' or 'noreturn' or 'malloc'.  The compiler only
          warns for functions visible in other compilation units or (in
          the case of 'pure' and 'const') if it cannot prove that the
          function returns normally.  A function returns normally if it
          doesn't contain an infinite loop or return abnormally by
          throwing, calling 'abort' or trapping.  This analysis requires
          option '-fipa-pure-const', which is enabled by default at '-O'
          and higher.  Higher optimization levels improve the accuracy
          of the analysis.

     '-Wsuggest-attribute=format'
     '-Wmissing-format-attribute'

          Warn about function pointers that might be candidates for
          'format' attributes.  Note these are only possible candidates,
          not absolute ones.  GCC guesses that function pointers with
          'format' attributes that are used in assignment,
          initialization, parameter passing or return statements should
          have a corresponding 'format' attribute in the resulting type.
          I.e. the left-hand side of the assignment or initialization,
          the type of the parameter variable, or the return type of the
          containing function respectively should also have a 'format'
          attribute to avoid the warning.

          GCC also warns about function definitions that might be
          candidates for 'format' attributes.  Again, these are only
          possible candidates.  GCC guesses that 'format' attributes
          might be appropriate for any function that calls a function
          like 'vprintf' or 'vscanf', but this might not always be the
          case, and some functions for which 'format' attributes are
          appropriate may not be detected.

     '-Wsuggest-attribute=cold'

          Warn about functions that might be candidates for 'cold'
          attribute.  This is based on static detection and generally
          will only warn about functions which always leads to a call to
          another 'cold' function such as wrappers of C++ 'throw' or
          fatal error reporting functions leading to 'abort'.

'-Wsuggest-final-types'
     Warn about types with virtual methods where code quality would be
     improved if the type were declared with the C++11 'final'
     specifier, or, if possible, declared in an anonymous namespace.
     This allows GCC to more aggressively devirtualize the polymorphic
     calls.  This warning is more effective with link time optimization,
     where the information about the class hierarchy graph is more
     complete.

'-Wsuggest-final-methods'
     Warn about virtual methods where code quality would be improved if
     the method were declared with the C++11 'final' specifier, or, if
     possible, its type were declared in an anonymous namespace or with
     the 'final' specifier.  This warning is more effective with
     link-time optimization, where the information about the class
     hierarchy graph is more complete.  It is recommended to first
     consider suggestions of '-Wsuggest-final-types' and then rebuild
     with new annotations.

'-Wsuggest-override'
     Warn about overriding virtual functions that are not marked with
     the override keyword.

'-Walloc-zero'
     Warn about calls to allocation functions decorated with attribute
     'alloc_size' that specify zero bytes, including those to the
     built-in forms of the functions 'aligned_alloc', 'alloca',
     'calloc', 'malloc', and 'realloc'.  Because the behavior of these
     functions when called with a zero size differs among
     implementations (and in the case of 'realloc' has been deprecated)
     relying on it may result in subtle portability bugs and should be
     avoided.

'-Walloc-size-larger-than=BYTE-SIZE'
     Warn about calls to functions decorated with attribute 'alloc_size'
     that attempt to allocate objects larger than the specified number
     of bytes, or where the result of the size computation in an integer
     type with infinite precision would exceed the value of
     'PTRDIFF_MAX' on the target.
     '-Walloc-size-larger-than=''PTRDIFF_MAX' is enabled by default.
     Warnings controlled by the option can be disabled either by
     specifying BYTE-SIZE of 'SIZE_MAX' or more or by
     '-Wno-alloc-size-larger-than'.  *Note Function Attributes::.

'-Wno-alloc-size-larger-than'
     Disable '-Walloc-size-larger-than=' warnings.  The option is
     equivalent to '-Walloc-size-larger-than=''SIZE_MAX' or larger.

'-Walloca'
     This option warns on all uses of 'alloca' in the source.

'-Walloca-larger-than=BYTE-SIZE'
     This option warns on calls to 'alloca' with an integer argument
     whose value is either zero, or that is not bounded by a controlling
     predicate that limits its value to at most BYTE-SIZE.  It also
     warns for calls to 'alloca' where the bound value is unknown.
     Arguments of non-integer types are considered unbounded even if
     they appear to be constrained to the expected range.

     For example, a bounded case of 'alloca' could be:

          void func (size_t n)
          {
            void *p;
            if (n <= 1000)
              p = alloca (n);
            else
              p = malloc (n);
            f (p);
          }

     In the above example, passing '-Walloca-larger-than=1000' would not
     issue a warning because the call to 'alloca' is known to be at most
     1000 bytes.  However, if '-Walloca-larger-than=500' were passed,
     the compiler would emit a warning.

     Unbounded uses, on the other hand, are uses of 'alloca' with no
     controlling predicate constraining its integer argument.  For
     example:

          void func ()
          {
            void *p = alloca (n);
            f (p);
          }

     If '-Walloca-larger-than=500' were passed, the above would trigger
     a warning, but this time because of the lack of bounds checking.

     Note, that even seemingly correct code involving signed integers
     could cause a warning:

          void func (signed int n)
          {
            if (n < 500)
              {
                p = alloca (n);
                f (p);
              }
          }

     In the above example, N could be negative, causing a larger than
     expected argument to be implicitly cast into the 'alloca' call.

     This option also warns when 'alloca' is used in a loop.

     '-Walloca-larger-than=''PTRDIFF_MAX' is enabled by default but is
     usually only effective when '-ftree-vrp' is active (default for
     '-O2' and above).

     See also '-Wvla-larger-than=''byte-size'.

'-Wno-alloca-larger-than'
     Disable '-Walloca-larger-than=' warnings.  The option is equivalent
     to '-Walloca-larger-than=''SIZE_MAX' or larger.

'-Warray-bounds'
'-Warray-bounds=N'
     This option is only active when '-ftree-vrp' is active (default for
     '-O2' and above).  It warns about subscripts to arrays that are
     always out of bounds.  This warning is enabled by '-Wall'.

     '-Warray-bounds=1'
          This is the warning level of '-Warray-bounds' and is enabled
          by '-Wall'; higher levels are not, and must be explicitly
          requested.

     '-Warray-bounds=2'
          This warning level also warns about out of bounds access for
          arrays at the end of a struct and for arrays accessed through
          pointers.  This warning level may give a larger number of
          false positives and is deactivated by default.

'-Wattribute-alias=N'
'-Wno-attribute-alias'
     Warn about declarations using the 'alias' and similar attributes
     whose target is incompatible with the type of the alias.  *Note
     Declaring Attributes of Functions: Function Attributes.

     '-Wattribute-alias=1'
          The default warning level of the '-Wattribute-alias' option
          diagnoses incompatibilities between the type of the alias
          declaration and that of its target.  Such incompatibilities
          are typically indicative of bugs.

     '-Wattribute-alias=2'

          At this level '-Wattribute-alias' also diagnoses cases where
          the attributes of the alias declaration are more restrictive
          than the attributes applied to its target.  These mismatches
          can potentially result in incorrect code generation.  In other
          cases they may be benign and could be resolved simply by
          adding the missing attribute to the target.  For comparison,
          see the '-Wmissing-attributes' option, which controls
          diagnostics when the alias declaration is less restrictive
          than the target, rather than more restrictive.

          Attributes considered include 'alloc_align', 'alloc_size',
          'cold', 'const', 'hot', 'leaf', 'malloc', 'nonnull',
          'noreturn', 'nothrow', 'pure', 'returns_nonnull', and
          'returns_twice'.

     '-Wattribute-alias' is equivalent to '-Wattribute-alias=1'.  This
     is the default.  You can disable these warnings with either
     '-Wno-attribute-alias' or '-Wattribute-alias=0'.

'-Wbool-compare'
     Warn about boolean expression compared with an integer value
     different from 'true'/'false'.  For instance, the following
     comparison is always false:
          int n = 5;
          ...
          if ((n > 1) == 2) { ... }
     This warning is enabled by '-Wall'.

'-Wbool-operation'
     Warn about suspicious operations on expressions of a boolean type.
     For instance, bitwise negation of a boolean is very likely a bug in
     the program.  For C, this warning also warns about incrementing or
     decrementing a boolean, which rarely makes sense.  (In C++,
     decrementing a boolean is always invalid.  Incrementing a boolean
     is invalid in C++17, and deprecated otherwise.)

     This warning is enabled by '-Wall'.

'-Wduplicated-branches'
     Warn when an if-else has identical branches.  This warning detects
     cases like
          if (p != NULL)
            return 0;
          else
            return 0;
     It doesn't warn when both branches contain just a null statement.
     This warning also warn for conditional operators:
            int i = x ? *p : *p;

'-Wduplicated-cond'
     Warn about duplicated conditions in an if-else-if chain.  For
     instance, warn for the following code:
          if (p->q != NULL) { ... }
          else if (p->q != NULL) { ... }

'-Wframe-address'
     Warn when the '__builtin_frame_address' or
     '__builtin_return_address' is called with an argument greater than
     0.  Such calls may return indeterminate values or crash the
     program.  The warning is included in '-Wall'.

'-Wno-discarded-qualifiers (C and Objective-C only)'
     Do not warn if type qualifiers on pointers are being discarded.
     Typically, the compiler warns if a 'const char *' variable is
     passed to a function that takes a 'char *' parameter.  This option
     can be used to suppress such a warning.

'-Wno-discarded-array-qualifiers (C and Objective-C only)'
     Do not warn if type qualifiers on arrays which are pointer targets
     are being discarded.  Typically, the compiler warns if a 'const int
     (*)[]' variable is passed to a function that takes a 'int (*)[]'
     parameter.  This option can be used to suppress such a warning.

'-Wno-incompatible-pointer-types (C and Objective-C only)'
     Do not warn when there is a conversion between pointers that have
     incompatible types.  This warning is for cases not covered by
     '-Wno-pointer-sign', which warns for pointer argument passing or
     assignment with different signedness.

'-Wno-int-conversion (C and Objective-C only)'
     Do not warn about incompatible integer to pointer and pointer to
     integer conversions.  This warning is about implicit conversions;
     for explicit conversions the warnings '-Wno-int-to-pointer-cast'
     and '-Wno-pointer-to-int-cast' may be used.

'-Wno-div-by-zero'
     Do not warn about compile-time integer division by zero.
     Floating-point division by zero is not warned about, as it can be a
     legitimate way of obtaining infinities and NaNs.

'-Wsystem-headers'
     Print warning messages for constructs found in system header files.
     Warnings from system headers are normally suppressed, on the
     assumption that they usually do not indicate real problems and
     would only make the compiler output harder to read.  Using this
     command-line option tells GCC to emit warnings from system headers
     as if they occurred in user code.  However, note that using '-Wall'
     in conjunction with this option does _not_ warn about unknown
     pragmas in system headers--for that, '-Wunknown-pragmas' must also
     be used.

'-Wtautological-compare'
     Warn if a self-comparison always evaluates to true or false.  This
     warning detects various mistakes such as:
          int i = 1;
          ...
          if (i > i) { ... }

     This warning also warns about bitwise comparisons that always
     evaluate to true or false, for instance:
          if ((a & 16) == 10) { ... }
     will always be false.

     This warning is enabled by '-Wall'.

'-Wtrampolines'
     Warn about trampolines generated for pointers to nested functions.
     A trampoline is a small piece of data or code that is created at
     run time on the stack when the address of a nested function is
     taken, and is used to call the nested function indirectly.  For
     some targets, it is made up of data only and thus requires no
     special treatment.  But, for most targets, it is made up of code
     and thus requires the stack to be made executable in order for the
     program to work properly.

'-Wfloat-equal'
     Warn if floating-point values are used in equality comparisons.

     The idea behind this is that sometimes it is convenient (for the
     programmer) to consider floating-point values as approximations to
     infinitely precise real numbers.  If you are doing this, then you
     need to compute (by analyzing the code, or in some other way) the
     maximum or likely maximum error that the computation introduces,
     and allow for it when performing comparisons (and when producing
     output, but that's a different problem).  In particular, instead of
     testing for equality, you should check to see whether the two
     values have ranges that overlap; and this is done with the
     relational operators, so equality comparisons are probably
     mistaken.

'-Wtraditional (C and Objective-C only)'
     Warn about certain constructs that behave differently in
     traditional and ISO C.  Also warn about ISO C constructs that have
     no traditional C equivalent, and/or problematic constructs that
     should be avoided.

        * Macro parameters that appear within string literals in the
          macro body.  In traditional C macro replacement takes place
          within string literals, but in ISO C it does not.

        * In traditional C, some preprocessor directives did not exist.
          Traditional preprocessors only considered a line to be a
          directive if the '#' appeared in column 1 on the line.
          Therefore '-Wtraditional' warns about directives that
          traditional C understands but ignores because the '#' does not
          appear as the first character on the line.  It also suggests
          you hide directives like '#pragma' not understood by
          traditional C by indenting them.  Some traditional
          implementations do not recognize '#elif', so this option
          suggests avoiding it altogether.

        * A function-like macro that appears without arguments.

        * The unary plus operator.

        * The 'U' integer constant suffix, or the 'F' or 'L'
          floating-point constant suffixes.  (Traditional C does support
          the 'L' suffix on integer constants.)  Note, these suffixes
          appear in macros defined in the system headers of most modern
          systems, e.g. the '_MIN'/'_MAX' macros in '<limits.h>'.  Use
          of these macros in user code might normally lead to spurious
          warnings, however GCC's integrated preprocessor has enough
          context to avoid warning in these cases.

        * A function declared external in one block and then used after
          the end of the block.

        * A 'switch' statement has an operand of type 'long'.

        * A non-'static' function declaration follows a 'static' one.
          This construct is not accepted by some traditional C
          compilers.

        * The ISO type of an integer constant has a different width or
          signedness from its traditional type.  This warning is only
          issued if the base of the constant is ten.  I.e. hexadecimal
          or octal values, which typically represent bit patterns, are
          not warned about.

        * Usage of ISO string concatenation is detected.

        * Initialization of automatic aggregates.

        * Identifier conflicts with labels.  Traditional C lacks a
          separate namespace for labels.

        * Initialization of unions.  If the initializer is zero, the
          warning is omitted.  This is done under the assumption that
          the zero initializer in user code appears conditioned on e.g.
          '__STDC__' to avoid missing initializer warnings and relies on
          default initialization to zero in the traditional C case.

        * Conversions by prototypes between fixed/floating-point values
          and vice versa.  The absence of these prototypes when
          compiling with traditional C causes serious problems.  This is
          a subset of the possible conversion warnings; for the full set
          use '-Wtraditional-conversion'.

        * Use of ISO C style function definitions.  This warning
          intentionally is _not_ issued for prototype declarations or
          variadic functions because these ISO C features appear in your
          code when using libiberty's traditional C compatibility
          macros, 'PARAMS' and 'VPARAMS'.  This warning is also bypassed
          for nested functions because that feature is already a GCC
          extension and thus not relevant to traditional C
          compatibility.

'-Wtraditional-conversion (C and Objective-C only)'
     Warn if a prototype causes a type conversion that is different from
     what would happen to the same argument in the absence of a
     prototype.  This includes conversions of fixed point to floating
     and vice versa, and conversions changing the width or signedness of
     a fixed-point argument except when the same as the default
     promotion.

'-Wdeclaration-after-statement (C and Objective-C only)'
     Warn when a declaration is found after a statement in a block.
     This construct, known from C++, was introduced with ISO C99 and is
     by default allowed in GCC.  It is not supported by ISO C90.  *Note
     Mixed Declarations::.

'-Wshadow'
     Warn whenever a local variable or type declaration shadows another
     variable, parameter, type, class member (in C++), or instance
     variable (in Objective-C) or whenever a built-in function is
     shadowed.  Note that in C++, the compiler warns if a local variable
     shadows an explicit typedef, but not if it shadows a
     struct/class/enum.  Same as '-Wshadow=global'.

'-Wno-shadow-ivar (Objective-C only)'
     Do not warn whenever a local variable shadows an instance variable
     in an Objective-C method.

'-Wshadow=global'
     The default for '-Wshadow'.  Warns for any (global) shadowing.

'-Wshadow=local'
     Warn when a local variable shadows another local variable or
     parameter.  This warning is enabled by '-Wshadow=global'.

'-Wshadow=compatible-local'
     Warn when a local variable shadows another local variable or
     parameter whose type is compatible with that of the shadowing
     variable.  In C++, type compatibility here means the type of the
     shadowing variable can be converted to that of the shadowed
     variable.  The creation of this flag (in addition to
     '-Wshadow=local') is based on the idea that when a local variable
     shadows another one of incompatible type, it is most likely
     intentional, not a bug or typo, as shown in the following example:

          for (SomeIterator i = SomeObj.begin(); i != SomeObj.end(); ++i)
          {
            for (int i = 0; i < N; ++i)
            {
              ...
            }
            ...
          }

     Since the two variable 'i' in the example above have incompatible
     types, enabling only '-Wshadow=compatible-local' will not emit a
     warning.  Because their types are incompatible, if a programmer
     accidentally uses one in place of the other, type checking will
     catch that and emit an error or warning.  So not warning (about
     shadowing) in this case will not lead to undetected bugs.  Use of
     this flag instead of '-Wshadow=local' can possibly reduce the
     number of warnings triggered by intentional shadowing.

     This warning is enabled by '-Wshadow=local'.

'-Wlarger-than=BYTE-SIZE'
     Warn whenever an object is defined whose size exceeds BYTE-SIZE.
     '-Wlarger-than=''PTRDIFF_MAX' is enabled by default.  Warnings
     controlled by the option can be disabled either by specifying
     BYTE-SIZE of 'SIZE_MAX' or more or by '-Wno-larger-than'.

'-Wno-larger-than'
     Disable '-Wlarger-than=' warnings.  The option is equivalent to
     '-Wlarger-than=''SIZE_MAX' or larger.

'-Wframe-larger-than=BYTE-SIZE'
     Warn if the size of a function frame exceeds BYTE-SIZE.  The
     computation done to determine the stack frame size is approximate
     and not conservative.  The actual requirements may be somewhat
     greater than BYTE-SIZE even if you do not get a warning.  In
     addition, any space allocated via 'alloca', variable-length arrays,
     or related constructs is not included by the compiler when
     determining whether or not to issue a warning.
     '-Wframe-larger-than=''PTRDIFF_MAX' is enabled by default.
     Warnings controlled by the option can be disabled either by
     specifying BYTE-SIZE of 'SIZE_MAX' or more or by
     '-Wno-frame-larger-than'.

'-Wno-frame-larger-than'
     Disable '-Wframe-larger-than=' warnings.  The option is equivalent
     to '-Wframe-larger-than=''SIZE_MAX' or larger.

'-Wno-free-nonheap-object'
     Do not warn when attempting to free an object that was not
     allocated on the heap.

'-Wstack-usage=BYTE-SIZE'
     Warn if the stack usage of a function might exceed BYTE-SIZE.  The
     computation done to determine the stack usage is conservative.  Any
     space allocated via 'alloca', variable-length arrays, or related
     constructs is included by the compiler when determining whether or
     not to issue a warning.

     The message is in keeping with the output of '-fstack-usage'.

        * If the stack usage is fully static but exceeds the specified
          amount, it's:

                 warning: stack usage is 1120 bytes
        * If the stack usage is (partly) dynamic but bounded, it's:

                 warning: stack usage might be 1648 bytes
        * If the stack usage is (partly) dynamic and not bounded, it's:

                 warning: stack usage might be unbounded

     '-Wstack-usage=''PTRDIFF_MAX' is enabled by default.  Warnings
     controlled by the option can be disabled either by specifying
     BYTE-SIZE of 'SIZE_MAX' or more or by '-Wno-stack-usage'.

'-Wno-stack-usage'
     Disable '-Wstack-usage=' warnings.  The option is equivalent to
     '-Wstack-usage=''SIZE_MAX' or larger.

'-Wunsafe-loop-optimizations'
     Warn if the loop cannot be optimized because the compiler cannot
     assume anything on the bounds of the loop indices.  With
     '-funsafe-loop-optimizations' warn if the compiler makes such
     assumptions.

'-Wno-pedantic-ms-format (MinGW targets only)'
     When used in combination with '-Wformat' and '-pedantic' without
     GNU extensions, this option disables the warnings about non-ISO
     'printf' / 'scanf' format width specifiers 'I32', 'I64', and 'I'
     used on Windows targets, which depend on the MS runtime.

'-Waligned-new'
     Warn about a new-expression of a type that requires greater
     alignment than the 'alignof(std::max_align_t)' but uses an
     allocation function without an explicit alignment parameter.  This
     option is enabled by '-Wall'.

     Normally this only warns about global allocation functions, but
     '-Waligned-new=all' also warns about class member allocation
     functions.

'-Wplacement-new'
'-Wplacement-new=N'
     Warn about placement new expressions with undefined behavior, such
     as constructing an object in a buffer that is smaller than the type
     of the object.  For example, the placement new expression below is
     diagnosed because it attempts to construct an array of 64 integers
     in a buffer only 64 bytes large.
          char buf [64];
          new (buf) int[64];
     This warning is enabled by default.

     '-Wplacement-new=1'
          This is the default warning level of '-Wplacement-new'.  At
          this level the warning is not issued for some strictly
          undefined constructs that GCC allows as extensions for
          compatibility with legacy code.  For example, the following
          'new' expression is not diagnosed at this level even though it
          has undefined behavior according to the C++ standard because
          it writes past the end of the one-element array.
               struct S { int n, a[1]; };
               S *s = (S *)malloc (sizeof *s + 31 * sizeof s->a[0]);
               new (s->a)int [32]();

     '-Wplacement-new=2'
          At this level, in addition to diagnosing all the same
          constructs as at level 1, a diagnostic is also issued for
          placement new expressions that construct an object in the last
          member of structure whose type is an array of a single element
          and whose size is less than the size of the object being
          constructed.  While the previous example would be diagnosed,
          the following construct makes use of the flexible member array
          extension to avoid the warning at level 2.
               struct S { int n, a[]; };
               S *s = (S *)malloc (sizeof *s + 32 * sizeof s->a[0]);
               new (s->a)int [32]();

'-Wpointer-arith'
     Warn about anything that depends on the "size of" a function type
     or of 'void'.  GNU C assigns these types a size of 1, for
     convenience in calculations with 'void *' pointers and pointers to
     functions.  In C++, warn also when an arithmetic operation involves
     'NULL'.  This warning is also enabled by '-Wpedantic'.

'-Wpointer-compare'
     Warn if a pointer is compared with a zero character constant.  This
     usually means that the pointer was meant to be dereferenced.  For
     example:

          const char *p = foo ();
          if (p == '\0')
            return 42;

     Note that the code above is invalid in C++11.

     This warning is enabled by default.

'-Wtype-limits'
     Warn if a comparison is always true or always false due to the
     limited range of the data type, but do not warn for constant
     expressions.  For example, warn if an unsigned variable is compared
     against zero with '<' or '>='.  This warning is also enabled by
     '-Wextra'.

'-Wabsolute-value (C and Objective-C only)'
     Warn for calls to standard functions that compute the absolute
     value of an argument when a more appropriate standard function is
     available.  For example, calling 'abs(3.14)' triggers the warning
     because the appropriate function to call to compute the absolute
     value of a double argument is 'fabs'.  The option also triggers
     warnings when the argument in a call to such a function has an
     unsigned type.  This warning can be suppressed with an explicit
     type cast and it is also enabled by '-Wextra'.

'-Wcomment'
'-Wcomments'
     Warn whenever a comment-start sequence '/*' appears in a '/*'
     comment, or whenever a backslash-newline appears in a '//' comment.
     This warning is enabled by '-Wall'.

'-Wtrigraphs'
     Warn if any trigraphs are encountered that might change the meaning
     of the program.  Trigraphs within comments are not warned about,
     except those that would form escaped newlines.

     This option is implied by '-Wall'.  If '-Wall' is not given, this
     option is still enabled unless trigraphs are enabled.  To get
     trigraph conversion without warnings, but get the other '-Wall'
     warnings, use '-trigraphs -Wall -Wno-trigraphs'.

'-Wundef'
     Warn if an undefined identifier is evaluated in an '#if' directive.
     Such identifiers are replaced with zero.

'-Wexpansion-to-defined'
     Warn whenever 'defined' is encountered in the expansion of a macro
     (including the case where the macro is expanded by an '#if'
     directive).  Such usage is not portable.  This warning is also
     enabled by '-Wpedantic' and '-Wextra'.

'-Wunused-macros'
     Warn about macros defined in the main file that are unused.  A
     macro is "used" if it is expanded or tested for existence at least
     once.  The preprocessor also warns if the macro has not been used
     at the time it is redefined or undefined.

     Built-in macros, macros defined on the command line, and macros
     defined in include files are not warned about.

     _Note:_ If a macro is actually used, but only used in skipped
     conditional blocks, then the preprocessor reports it as unused.  To
     avoid the warning in such a case, you might improve the scope of
     the macro's definition by, for example, moving it into the first
     skipped block.  Alternatively, you could provide a dummy use with
     something like:

          #if defined the_macro_causing_the_warning
          #endif

'-Wno-endif-labels'
     Do not warn whenever an '#else' or an '#endif' are followed by
     text.  This sometimes happens in older programs with code of the
     form

          #if FOO
          ...
          #else FOO
          ...
          #endif FOO

     The second and third 'FOO' should be in comments.  This warning is
     on by default.

'-Wbad-function-cast (C and Objective-C only)'
     Warn when a function call is cast to a non-matching type.  For
     example, warn if a call to a function returning an integer type is
     cast to a pointer type.

'-Wc90-c99-compat (C and Objective-C only)'
     Warn about features not present in ISO C90, but present in ISO C99.
     For instance, warn about use of variable length arrays, 'long long'
     type, 'bool' type, compound literals, designated initializers, and
     so on.  This option is independent of the standards mode.  Warnings
     are disabled in the expression that follows '__extension__'.

'-Wc99-c11-compat (C and Objective-C only)'
     Warn about features not present in ISO C99, but present in ISO C11.
     For instance, warn about use of anonymous structures and unions,
     '_Atomic' type qualifier, '_Thread_local' storage-class specifier,
     '_Alignas' specifier, 'Alignof' operator, '_Generic' keyword, and
     so on.  This option is independent of the standards mode.  Warnings
     are disabled in the expression that follows '__extension__'.

'-Wc++-compat (C and Objective-C only)'
     Warn about ISO C constructs that are outside of the common subset
     of ISO C and ISO C++, e.g. request for implicit conversion from
     'void *' to a pointer to non-'void' type.

'-Wc++11-compat (C++ and Objective-C++ only)'
     Warn about C++ constructs whose meaning differs between ISO C++
     1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are
     keywords in ISO C++ 2011.  This warning turns on '-Wnarrowing' and
     is enabled by '-Wall'.

'-Wc++14-compat (C++ and Objective-C++ only)'
     Warn about C++ constructs whose meaning differs between ISO C++
     2011 and ISO C++ 2014.  This warning is enabled by '-Wall'.

'-Wc++17-compat (C++ and Objective-C++ only)'
     Warn about C++ constructs whose meaning differs between ISO C++
     2014 and ISO C++ 2017.  This warning is enabled by '-Wall'.

'-Wcast-qual'
     Warn whenever a pointer is cast so as to remove a type qualifier
     from the target type.  For example, warn if a 'const char *' is
     cast to an ordinary 'char *'.

     Also warn when making a cast that introduces a type qualifier in an
     unsafe way.  For example, casting 'char **' to 'const char **' is
     unsafe, as in this example:

            /* p is char ** value.  */
            const char **q = (const char **) p;
            /* Assignment of readonly string to const char * is OK.  */
            *q = "string";
            /* Now char** pointer points to read-only memory.  */
            **p = 'b';

'-Wcast-align'
     Warn whenever a pointer is cast such that the required alignment of
     the target is increased.  For example, warn if a 'char *' is cast
     to an 'int *' on machines where integers can only be accessed at
     two- or four-byte boundaries.

'-Wcast-align=strict'
     Warn whenever a pointer is cast such that the required alignment of
     the target is increased.  For example, warn if a 'char *' is cast
     to an 'int *' regardless of the target machine.

'-Wcast-function-type'
     Warn when a function pointer is cast to an incompatible function
     pointer.  In a cast involving function types with a variable
     argument list only the types of initial arguments that are provided
     are considered.  Any parameter of pointer-type matches any other
     pointer-type.  Any benign differences in integral types are
     ignored, like 'int' vs. 'long' on ILP32 targets.  Likewise type
     qualifiers are ignored.  The function type 'void (*) (void)' is
     special and matches everything, which can be used to suppress this
     warning.  In a cast involving pointer to member types this warning
     warns whenever the type cast is changing the pointer to member
     type.  This warning is enabled by '-Wextra'.

'-Wwrite-strings'
     When compiling C, give string constants the type 'const
     char[LENGTH]' so that copying the address of one into a non-'const'
     'char *' pointer produces a warning.  These warnings help you find
     at compile time code that can try to write into a string constant,
     but only if you have been very careful about using 'const' in
     declarations and prototypes.  Otherwise, it is just a nuisance.
     This is why we did not make '-Wall' request these warnings.

     When compiling C++, warn about the deprecated conversion from
     string literals to 'char *'.  This warning is enabled by default
     for C++ programs.

'-Wcatch-value'
'-Wcatch-value=N (C++ and Objective-C++ only)'
     Warn about catch handlers that do not catch via reference.  With
     '-Wcatch-value=1' (or '-Wcatch-value' for short) warn about
     polymorphic class types that are caught by value.  With
     '-Wcatch-value=2' warn about all class types that are caught by
     value.  With '-Wcatch-value=3' warn about all types that are not
     caught by reference.  '-Wcatch-value' is enabled by '-Wall'.

'-Wclobbered'
     Warn for variables that might be changed by 'longjmp' or 'vfork'.
     This warning is also enabled by '-Wextra'.

'-Wconditionally-supported (C++ and Objective-C++ only)'
     Warn for conditionally-supported (C++11 [intro.defs]) constructs.

'-Wconversion'
     Warn for implicit conversions that may alter a value.  This
     includes conversions between real and integer, like 'abs (x)' when
     'x' is 'double'; conversions between signed and unsigned, like
     'unsigned ui = -1'; and conversions to smaller types, like 'sqrtf
     (M_PI)'.  Do not warn for explicit casts like 'abs ((int) x)' and
     'ui = (unsigned) -1', or if the value is not changed by the
     conversion like in 'abs (2.0)'.  Warnings about conversions between
     signed and unsigned integers can be disabled by using
     '-Wno-sign-conversion'.

     For C++, also warn for confusing overload resolution for
     user-defined conversions; and conversions that never use a type
     conversion operator: conversions to 'void', the same type, a base
     class or a reference to them.  Warnings about conversions between
     signed and unsigned integers are disabled by default in C++ unless
     '-Wsign-conversion' is explicitly enabled.

'-Wno-conversion-null (C++ and Objective-C++ only)'
     Do not warn for conversions between 'NULL' and non-pointer types.
     '-Wconversion-null' is enabled by default.

'-Wzero-as-null-pointer-constant (C++ and Objective-C++ only)'
     Warn when a literal '0' is used as null pointer constant.  This can
     be useful to facilitate the conversion to 'nullptr' in C++11.

'-Wsubobject-linkage (C++ and Objective-C++ only)'
     Warn if a class type has a base or a field whose type uses the
     anonymous namespace or depends on a type with no linkage.  If a
     type A depends on a type B with no or internal linkage, defining it
     in multiple translation units would be an ODR violation because the
     meaning of B is different in each translation unit.  If A only
     appears in a single translation unit, the best way to silence the
     warning is to give it internal linkage by putting it in an
     anonymous namespace as well.  The compiler doesn't give this
     warning for types defined in the main .C file, as those are
     unlikely to have multiple definitions.  '-Wsubobject-linkage' is
     enabled by default.

'-Wdangling-else'
     Warn about constructions where there may be confusion to which 'if'
     statement an 'else' branch belongs.  Here is an example of such a
     case:

          {
            if (a)
              if (b)
                foo ();
            else
              bar ();
          }

     In C/C++, every 'else' branch belongs to the innermost possible
     'if' statement, which in this example is 'if (b)'.  This is often
     not what the programmer expected, as illustrated in the above
     example by indentation the programmer chose.  When there is the
     potential for this confusion, GCC issues a warning when this flag
     is specified.  To eliminate the warning, add explicit braces around
     the innermost 'if' statement so there is no way the 'else' can
     belong to the enclosing 'if'.  The resulting code looks like this:

          {
            if (a)
              {
                if (b)
                  foo ();
                else
                  bar ();
              }
          }

     This warning is enabled by '-Wparentheses'.

'-Wdate-time'
     Warn when macros '__TIME__', '__DATE__' or '__TIMESTAMP__' are
     encountered as they might prevent bit-wise-identical reproducible
     compilations.

'-Wdelete-incomplete (C++ and Objective-C++ only)'
     Warn when deleting a pointer to incomplete type, which may cause
     undefined behavior at runtime.  This warning is enabled by default.

'-Wuseless-cast (C++ and Objective-C++ only)'
     Warn when an expression is casted to its own type.

'-Wempty-body'
     Warn if an empty body occurs in an 'if', 'else' or 'do while'
     statement.  This warning is also enabled by '-Wextra'.

'-Wenum-compare'
     Warn about a comparison between values of different enumerated
     types.  In C++ enumerated type mismatches in conditional
     expressions are also diagnosed and the warning is enabled by
     default.  In C this warning is enabled by '-Wall'.

'-Wextra-semi (C++, Objective-C++ only)'
     Warn about redundant semicolon after in-class function definition.

'-Wjump-misses-init (C, Objective-C only)'
     Warn if a 'goto' statement or a 'switch' statement jumps forward
     across the initialization of a variable, or jumps backward to a
     label after the variable has been initialized.  This only warns
     about variables that are initialized when they are declared.  This
     warning is only supported for C and Objective-C; in C++ this sort
     of branch is an error in any case.

     '-Wjump-misses-init' is included in '-Wc++-compat'.  It can be
     disabled with the '-Wno-jump-misses-init' option.

'-Wsign-compare'
     Warn when a comparison between signed and unsigned values could
     produce an incorrect result when the signed value is converted to
     unsigned.  In C++, this warning is also enabled by '-Wall'.  In C,
     it is also enabled by '-Wextra'.

'-Wsign-conversion'
     Warn for implicit conversions that may change the sign of an
     integer value, like assigning a signed integer expression to an
     unsigned integer variable.  An explicit cast silences the warning.
     In C, this option is enabled also by '-Wconversion'.

'-Wfloat-conversion'
     Warn for implicit conversions that reduce the precision of a real
     value.  This includes conversions from real to integer, and from
     higher precision real to lower precision real values.  This option
     is also enabled by '-Wconversion'.

'-Wno-scalar-storage-order'
     Do not warn on suspicious constructs involving reverse scalar
     storage order.

'-Wsized-deallocation (C++ and Objective-C++ only)'
     Warn about a definition of an unsized deallocation function
          void operator delete (void *) noexcept;
          void operator delete[] (void *) noexcept;
     without a definition of the corresponding sized deallocation
     function
          void operator delete (void *, std::size_t) noexcept;
          void operator delete[] (void *, std::size_t) noexcept;
     or vice versa.  Enabled by '-Wextra' along with
     '-fsized-deallocation'.

'-Wsizeof-pointer-div'
     Warn for suspicious divisions of two sizeof expressions that divide
     the pointer size by the element size, which is the usual way to
     compute the array size but won't work out correctly with pointers.
     This warning warns e.g. about 'sizeof (ptr) / sizeof (ptr[0])' if
     'ptr' is not an array, but a pointer.  This warning is enabled by
     '-Wall'.

'-Wsizeof-pointer-memaccess'
     Warn for suspicious length parameters to certain string and memory
     built-in functions if the argument uses 'sizeof'.  This warning
     triggers for example for 'memset (ptr, 0, sizeof (ptr));' if 'ptr'
     is not an array, but a pointer, and suggests a possible fix, or
     about 'memcpy (&foo, ptr, sizeof (&foo));'.
     '-Wsizeof-pointer-memaccess' also warns about calls to bounded
     string copy functions like 'strncat' or 'strncpy' that specify as
     the bound a 'sizeof' expression of the source array.  For example,
     in the following function the call to 'strncat' specifies the size
     of the source string as the bound.  That is almost certainly a
     mistake and so the call is diagnosed.
          void make_file (const char *name)
          {
            char path[PATH_MAX];
            strncpy (path, name, sizeof path - 1);
            strncat (path, ".text", sizeof ".text");
            ...
          }

     The '-Wsizeof-pointer-memaccess' option is enabled by '-Wall'.

'-Wsizeof-array-argument'
     Warn when the 'sizeof' operator is applied to a parameter that is
     declared as an array in a function definition.  This warning is
     enabled by default for C and C++ programs.

'-Wmemset-elt-size'
     Warn for suspicious calls to the 'memset' built-in function, if the
     first argument references an array, and the third argument is a
     number equal to the number of elements, but not equal to the size
     of the array in memory.  This indicates that the user has omitted a
     multiplication by the element size.  This warning is enabled by
     '-Wall'.

'-Wmemset-transposed-args'
     Warn for suspicious calls to the 'memset' built-in function where
     the second argument is not zero and the third argument is zero.
     For example, the call 'memset (buf, sizeof buf, 0)' is diagnosed
     because 'memset (buf, 0, sizeof buf)' was meant instead.  The
     diagnostic is only emitted if the third argument is a literal zero.
     Otherwise, if it is an expression that is folded to zero, or a cast
     of zero to some type, it is far less likely that the arguments have
     been mistakenly transposed and no warning is emitted.  This warning
     is enabled by '-Wall'.

'-Waddress'
     Warn about suspicious uses of memory addresses.  These include
     using the address of a function in a conditional expression, such
     as 'void func(void); if (func)', and comparisons against the memory
     address of a string literal, such as 'if (x == "abc")'.  Such uses
     typically indicate a programmer error: the address of a function
     always evaluates to true, so their use in a conditional usually
     indicate that the programmer forgot the parentheses in a function
     call; and comparisons against string literals result in unspecified
     behavior and are not portable in C, so they usually indicate that
     the programmer intended to use 'strcmp'.  This warning is enabled
     by '-Wall'.

'-Waddress-of-packed-member'
     Warn when the address of packed member of struct or union is taken,
     which usually results in an unaligned pointer value.  This is
     enabled by default.

'-Wlogical-op'
     Warn about suspicious uses of logical operators in expressions.
     This includes using logical operators in contexts where a bit-wise
     operator is likely to be expected.  Also warns when the operands of
     a logical operator are the same:
          extern int a;
          if (a < 0 && a < 0) { ... }

'-Wlogical-not-parentheses'
     Warn about logical not used on the left hand side operand of a
     comparison.  This option does not warn if the right operand is
     considered to be a boolean expression.  Its purpose is to detect
     suspicious code like the following:
          int a;
          ...
          if (!a > 1) { ... }

     It is possible to suppress the warning by wrapping the LHS into
     parentheses:
          if ((!a) > 1) { ... }

     This warning is enabled by '-Wall'.

'-Waggregate-return'
     Warn if any functions that return structures or unions are defined
     or called.  (In languages where you can return an array, this also
     elicits a warning.)

'-Wno-aggressive-loop-optimizations'
     Warn if in a loop with constant number of iterations the compiler
     detects undefined behavior in some statement during one or more of
     the iterations.

'-Wno-attributes'
     Do not warn if an unexpected '__attribute__' is used, such as
     unrecognized attributes, function attributes applied to variables,
     etc.  This does not stop errors for incorrect use of supported
     attributes.

'-Wno-builtin-declaration-mismatch'
     Warn if a built-in function is declared with an incompatible
     signature or as a non-function, or when a built-in function
     declared with a type that does not include a prototype is called
     with arguments whose promoted types do not match those expected by
     the function.  When '-Wextra' is specified, also warn when a
     built-in function that takes arguments is declared without a
     prototype.  The '-Wno-builtin-declaration-mismatch' warning is
     enabled by default.  To avoid the warning include the appropriate
     header to bring the prototypes of built-in functions into scope.

     For example, the call to 'memset' below is diagnosed by the warning
     because the function expects a value of type 'size_t' as its
     argument but the type of '32' is 'int'.  With '-Wextra', the
     declaration of the function is diagnosed as well.
          extern void* memset ();
          void f (void *d)
          {
            memset (d, '\0', 32);
          }

'-Wno-builtin-macro-redefined'
     Do not warn if certain built-in macros are redefined.  This
     suppresses warnings for redefinition of '__TIMESTAMP__',
     '__TIME__', '__DATE__', '__FILE__', and '__BASE_FILE__'.

'-Wstrict-prototypes (C and Objective-C only)'
     Warn if a function is declared or defined without specifying the
     argument types.  (An old-style function definition is permitted
     without a warning if preceded by a declaration that specifies the
     argument types.)

'-Wold-style-declaration (C and Objective-C only)'
     Warn for obsolescent usages, according to the C Standard, in a
     declaration.  For example, warn if storage-class specifiers like
     'static' are not the first things in a declaration.  This warning
     is also enabled by '-Wextra'.

'-Wold-style-definition (C and Objective-C only)'
     Warn if an old-style function definition is used.  A warning is
     given even if there is a previous prototype.

'-Wmissing-parameter-type (C and Objective-C only)'
     A function parameter is declared without a type specifier in
     K&R-style functions:

          void foo(bar) { }

     This warning is also enabled by '-Wextra'.

'-Wmissing-prototypes (C and Objective-C only)'
     Warn if a global function is defined without a previous prototype
     declaration.  This warning is issued even if the definition itself
     provides a prototype.  Use this option to detect global functions
     that do not have a matching prototype declaration in a header file.
     This option is not valid for C++ because all function declarations
     provide prototypes and a non-matching declaration declares an
     overload rather than conflict with an earlier declaration.  Use
     '-Wmissing-declarations' to detect missing declarations in C++.

'-Wmissing-declarations'
     Warn if a global function is defined without a previous
     declaration.  Do so even if the definition itself provides a
     prototype.  Use this option to detect global functions that are not
     declared in header files.  In C, no warnings are issued for
     functions with previous non-prototype declarations; use
     '-Wmissing-prototypes' to detect missing prototypes.  In C++, no
     warnings are issued for function templates, or for inline
     functions, or for functions in anonymous namespaces.

'-Wmissing-field-initializers'
     Warn if a structure's initializer has some fields missing.  For
     example, the following code causes such a warning, because 'x.h' is
     implicitly zero:

          struct s { int f, g, h; };
          struct s x = { 3, 4 };

     This option does not warn about designated initializers, so the
     following modification does not trigger a warning:

          struct s { int f, g, h; };
          struct s x = { .f = 3, .g = 4 };

     In C this option does not warn about the universal zero initializer
     '{ 0 }':

          struct s { int f, g, h; };
          struct s x = { 0 };

     Likewise, in C++ this option does not warn about the empty { }
     initializer, for example:

          struct s { int f, g, h; };
          s x = { };

     This warning is included in '-Wextra'.  To get other '-Wextra'
     warnings without this one, use '-Wextra
     -Wno-missing-field-initializers'.

'-Wno-multichar'
     Do not warn if a multicharacter constant (''FOOF'') is used.
     Usually they indicate a typo in the user's code, as they have
     implementation-defined values, and should not be used in portable
     code.

'-Wnormalized=[none|id|nfc|nfkc]'
     In ISO C and ISO C++, two identifiers are different if they are
     different sequences of characters.  However, sometimes when
     characters outside the basic ASCII character set are used, you can
     have two different character sequences that look the same.  To
     avoid confusion, the ISO 10646 standard sets out some
     "normalization rules" which when applied ensure that two sequences
     that look the same are turned into the same sequence.  GCC can warn
     you if you are using identifiers that have not been normalized;
     this option controls that warning.

     There are four levels of warning supported by GCC.  The default is
     '-Wnormalized=nfc', which warns about any identifier that is not in
     the ISO 10646 "C" normalized form, "NFC". NFC is the recommended
     form for most uses.  It is equivalent to '-Wnormalized'.

     Unfortunately, there are some characters allowed in identifiers by
     ISO C and ISO C++ that, when turned into NFC, are not allowed in
     identifiers.  That is, there's no way to use these symbols in
     portable ISO C or C++ and have all your identifiers in NFC.
     '-Wnormalized=id' suppresses the warning for these characters.  It
     is hoped that future versions of the standards involved will
     correct this, which is why this option is not the default.

     You can switch the warning off for all characters by writing
     '-Wnormalized=none' or '-Wno-normalized'.  You should only do this
     if you are using some other normalization scheme (like "D"),
     because otherwise you can easily create bugs that are literally
     impossible to see.

     Some characters in ISO 10646 have distinct meanings but look
     identical in some fonts or display methodologies, especially once
     formatting has been applied.  For instance '\u207F', "SUPERSCRIPT
     LATIN SMALL LETTER N", displays just like a regular 'n' that has
     been placed in a superscript.  ISO 10646 defines the "NFKC"
     normalization scheme to convert all these into a standard form as
     well, and GCC warns if your code is not in NFKC if you use
     '-Wnormalized=nfkc'.  This warning is comparable to warning about
     every identifier that contains the letter O because it might be
     confused with the digit 0, and so is not the default, but may be
     useful as a local coding convention if the programming environment
     cannot be fixed to display these characters distinctly.

'-Wno-attribute-warning'
     Do not warn about usage of functions (*note Function Attributes::)
     declared with 'warning' attribute.  By default, this warning is
     enabled.  '-Wno-attribute-warning' can be used to disable the
     warning or '-Wno-error=attribute-warning' can be used to disable
     the error when compiled with '-Werror' flag.

'-Wno-deprecated'
     Do not warn about usage of deprecated features.  *Note Deprecated
     Features::.

'-Wno-deprecated-declarations'
     Do not warn about uses of functions (*note Function Attributes::),
     variables (*note Variable Attributes::), and types (*note Type
     Attributes::) marked as deprecated by using the 'deprecated'
     attribute.

'-Wno-overflow'
     Do not warn about compile-time overflow in constant expressions.

'-Wno-odr'
     Warn about One Definition Rule violations during link-time
     optimization.  Requires '-flto-odr-type-merging' to be enabled.
     Enabled by default.

'-Wopenmp-simd'
     Warn if the vectorizer cost model overrides the OpenMP simd
     directive set by user.  The '-fsimd-cost-model=unlimited' option
     can be used to relax the cost model.

'-Woverride-init (C and Objective-C only)'
     Warn if an initialized field without side effects is overridden
     when using designated initializers (*note Designated Initializers:
     Designated Inits.).

     This warning is included in '-Wextra'.  To get other '-Wextra'
     warnings without this one, use '-Wextra -Wno-override-init'.

'-Woverride-init-side-effects (C and Objective-C only)'
     Warn if an initialized field with side effects is overridden when
     using designated initializers (*note Designated Initializers:
     Designated Inits.).  This warning is enabled by default.

'-Wpacked'
     Warn if a structure is given the packed attribute, but the packed
     attribute has no effect on the layout or size of the structure.
     Such structures may be mis-aligned for little benefit.  For
     instance, in this code, the variable 'f.x' in 'struct bar' is
     misaligned even though 'struct bar' does not itself have the packed
     attribute:

          struct foo {
            int x;
            char a, b, c, d;
          } __attribute__((packed));
          struct bar {
            char z;
            struct foo f;
          };

'-Wpacked-bitfield-compat'
     The 4.1, 4.2 and 4.3 series of GCC ignore the 'packed' attribute on
     bit-fields of type 'char'.  This has been fixed in GCC 4.4 but the
     change can lead to differences in the structure layout.  GCC
     informs you when the offset of such a field has changed in GCC 4.4.
     For example there is no longer a 4-bit padding between field 'a'
     and 'b' in this structure:

          struct foo
          {
            char a:4;
            char b:8;
          } __attribute__ ((packed));

     This warning is enabled by default.  Use
     '-Wno-packed-bitfield-compat' to disable this warning.

'-Wpacked-not-aligned (C, C++, Objective-C and Objective-C++ only)'
     Warn if a structure field with explicitly specified alignment in a
     packed struct or union is misaligned.  For example, a warning will
     be issued on 'struct S', like, 'warning: alignment 1 of 'struct S'
     is less than 8', in this code:

          struct __attribute__ ((aligned (8))) S8 { char a[8]; };
          struct __attribute__ ((packed)) S {
            struct S8 s8;
          };

     This warning is enabled by '-Wall'.

'-Wpadded'
     Warn if padding is included in a structure, either to align an
     element of the structure or to align the whole structure.
     Sometimes when this happens it is possible to rearrange the fields
     of the structure to reduce the padding and so make the structure
     smaller.

'-Wredundant-decls'
     Warn if anything is declared more than once in the same scope, even
     in cases where multiple declaration is valid and changes nothing.

'-Wno-restrict'
     Warn when an object referenced by a 'restrict'-qualified parameter
     (or, in C++, a '__restrict'-qualified parameter) is aliased by
     another argument, or when copies between such objects overlap.  For
     example, the call to the 'strcpy' function below attempts to
     truncate the string by replacing its initial characters with the
     last four.  However, because the call writes the terminating NUL
     into 'a[4]', the copies overlap and the call is diagnosed.

          void foo (void)
          {
            char a[] = "abcd1234";
            strcpy (a, a + 4);
            ...
          }
     The '-Wrestrict' option detects some instances of simple overlap
     even without optimization but works best at '-O2' and above.  It is
     included in '-Wall'.

'-Wnested-externs (C and Objective-C only)'
     Warn if an 'extern' declaration is encountered within a function.

'-Wno-inherited-variadic-ctor'
     Suppress warnings about use of C++11 inheriting constructors when
     the base class inherited from has a C variadic constructor; the
     warning is on by default because the ellipsis is not inherited.

'-Winline'
     Warn if a function that is declared as inline cannot be inlined.
     Even with this option, the compiler does not warn about failures to
     inline functions declared in system headers.

     The compiler uses a variety of heuristics to determine whether or
     not to inline a function.  For example, the compiler takes into
     account the size of the function being inlined and the amount of
     inlining that has already been done in the current function.
     Therefore, seemingly insignificant changes in the source program
     can cause the warnings produced by '-Winline' to appear or
     disappear.

'-Wno-invalid-offsetof (C++ and Objective-C++ only)'
     Suppress warnings from applying the 'offsetof' macro to a non-POD
     type.  According to the 2014 ISO C++ standard, applying 'offsetof'
     to a non-standard-layout type is undefined.  In existing C++
     implementations, however, 'offsetof' typically gives meaningful
     results.  This flag is for users who are aware that they are
     writing nonportable code and who have deliberately chosen to ignore
     the warning about it.

     The restrictions on 'offsetof' may be relaxed in a future version
     of the C++ standard.

'-Wint-in-bool-context'
     Warn for suspicious use of integer values where boolean values are
     expected, such as conditional expressions (?:) using non-boolean
     integer constants in boolean context, like 'if (a <= b ? 2 : 3)'.
     Or left shifting of signed integers in boolean context, like 'for
     (a = 0; 1 << a; a++);'.  Likewise for all kinds of multiplications
     regardless of the data type.  This warning is enabled by '-Wall'.

'-Wno-int-to-pointer-cast'
     Suppress warnings from casts to pointer type of an integer of a
     different size.  In C++, casting to a pointer type of smaller size
     is an error.  'Wint-to-pointer-cast' is enabled by default.

'-Wno-pointer-to-int-cast (C and Objective-C only)'
     Suppress warnings from casts from a pointer to an integer type of a
     different size.

'-Winvalid-pch'
     Warn if a precompiled header (*note Precompiled Headers::) is found
     in the search path but cannot be used.

'-Wlong-long'
     Warn if 'long long' type is used.  This is enabled by either
     '-Wpedantic' or '-Wtraditional' in ISO C90 and C++98 modes.  To
     inhibit the warning messages, use '-Wno-long-long'.

'-Wvariadic-macros'
     Warn if variadic macros are used in ISO C90 mode, or if the GNU
     alternate syntax is used in ISO C99 mode.  This is enabled by
     either '-Wpedantic' or '-Wtraditional'.  To inhibit the warning
     messages, use '-Wno-variadic-macros'.

'-Wvarargs'
     Warn upon questionable usage of the macros used to handle variable
     arguments like 'va_start'.  This is default.  To inhibit the
     warning messages, use '-Wno-varargs'.

'-Wvector-operation-performance'
     Warn if vector operation is not implemented via SIMD capabilities
     of the architecture.  Mainly useful for the performance tuning.
     Vector operation can be implemented 'piecewise', which means that
     the scalar operation is performed on every vector element; 'in
     parallel', which means that the vector operation is implemented
     using scalars of wider type, which normally is more performance
     efficient; and 'as a single scalar', which means that vector fits
     into a scalar type.

'-Wno-virtual-move-assign'
     Suppress warnings about inheriting from a virtual base with a
     non-trivial C++11 move assignment operator.  This is dangerous
     because if the virtual base is reachable along more than one path,
     it is moved multiple times, which can mean both objects end up in
     the moved-from state.  If the move assignment operator is written
     to avoid moving from a moved-from object, this warning can be
     disabled.

'-Wvla'
     Warn if a variable-length array is used in the code.  '-Wno-vla'
     prevents the '-Wpedantic' warning of the variable-length array.

'-Wvla-larger-than=BYTE-SIZE'
     If this option is used, the compiler will warn for declarations of
     variable-length arrays whose size is either unbounded, or bounded
     by an argument that allows the array size to exceed BYTE-SIZE
     bytes.  This is similar to how '-Walloca-larger-than='BYTE-SIZE
     works, but with variable-length arrays.

     Note that GCC may optimize small variable-length arrays of a known
     value into plain arrays, so this warning may not get triggered for
     such arrays.

     '-Wvla-larger-than=''PTRDIFF_MAX' is enabled by default but is
     typically only effective when '-ftree-vrp' is active (default for
     '-O2' and above).

     See also '-Walloca-larger-than=BYTE-SIZE'.

'-Wno-vla-larger-than'
     Disable '-Wvla-larger-than=' warnings.  The option is equivalent to
     '-Wvla-larger-than=''SIZE_MAX' or larger.

'-Wvolatile-register-var'
     Warn if a register variable is declared volatile.  The volatile
     modifier does not inhibit all optimizations that may eliminate
     reads and/or writes to register variables.  This warning is enabled
     by '-Wall'.

'-Wdisabled-optimization'
     Warn if a requested optimization pass is disabled.  This warning
     does not generally indicate that there is anything wrong with your
     code; it merely indicates that GCC's optimizers are unable to
     handle the code effectively.  Often, the problem is that your code
     is too big or too complex; GCC refuses to optimize programs when
     the optimization itself is likely to take inordinate amounts of
     time.

'-Wpointer-sign (C and Objective-C only)'
     Warn for pointer argument passing or assignment with different
     signedness.  This option is only supported for C and Objective-C.
     It is implied by '-Wall' and by '-Wpedantic', which can be disabled
     with '-Wno-pointer-sign'.

'-Wstack-protector'
     This option is only active when '-fstack-protector' is active.  It
     warns about functions that are not protected against stack
     smashing.

'-Woverlength-strings'
     Warn about string constants that are longer than the "minimum
     maximum" length specified in the C standard.  Modern compilers
     generally allow string constants that are much longer than the
     standard's minimum limit, but very portable programs should avoid
     using longer strings.

     The limit applies _after_ string constant concatenation, and does
     not count the trailing NUL.  In C90, the limit was 509 characters;
     in C99, it was raised to 4095.  C++98 does not specify a normative
     minimum maximum, so we do not diagnose overlength strings in C++.

     This option is implied by '-Wpedantic', and can be disabled with
     '-Wno-overlength-strings'.

'-Wunsuffixed-float-constants (C and Objective-C only)'

     Issue a warning for any floating constant that does not have a
     suffix.  When used together with '-Wsystem-headers' it warns about
     such constants in system header files.  This can be useful when
     preparing code to use with the 'FLOAT_CONST_DECIMAL64' pragma from
     the decimal floating-point extension to C99.

'-Wno-designated-init (C and Objective-C only)'
     Suppress warnings when a positional initializer is used to
     initialize a structure that has been marked with the
     'designated_init' attribute.

'-Whsa'
     Issue a warning when HSAIL cannot be emitted for the compiled
     function or OpenMP construct.

==============================================================================
File: gcc.info,  Node: |Debugging_Options|,  Next: |Optimize_Options|,  Prev: |Warning_Options|,  Up: |Invoking_GCC|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Debugging_Options*

3.9 Options for Debugging Your Program
==========----------------------------

To tell GCC to emit extra information for use by a debugger, in almost
all cases you need only to add '-g' to your other options.

 GCC allows you to use '-g' with '-O'.  The shortcuts taken by optimized
code may occasionally be surprising: some variables you declared may not
exist at all; flow of control may briefly move where you did not expect
it; some statements may not be executed because they compute constant
results or their values are already at hand; some statements may execute
in different places because they have been moved out of loops.
Nevertheless it is possible to debug optimized output.  This makes it
reasonable to use the optimizer for programs that might have bugs.

 If you are not using some other optimization option, consider using
'-Og' (*note Optimize Options::) with '-g'.  With no '-O' option at all,
some compiler passes that collect information useful for debugging do
not run at all, so that '-Og' may result in a better debugging
experience.

'-g'
     Produce debugging information in the operating system's native
     format (stabs, COFF, XCOFF, or DWARF).  GDB can work with this
     debugging information.

     On most systems that use stabs format, '-g' enables use of extra
     debugging information that only GDB can use; this extra information
     makes debugging work better in GDB but probably makes other
     debuggers crash or refuse to read the program.  If you want to
     control for certain whether to generate the extra information, use
     '-gstabs+', '-gstabs', '-gxcoff+', '-gxcoff', or '-gvms' (see
     below).

'-ggdb'
     Produce debugging information for use by GDB.  This means to use
     the most expressive format available (DWARF, stabs, or the native
     format if neither of those are supported), including GDB extensions
     if at all possible.

'-gdwarf'
'-gdwarf-VERSION'
     Produce debugging information in DWARF format (if that is
     supported).  The value of VERSION may be either 2, 3, 4 or 5; the
     default version for most targets is 4.  DWARF Version 5 is only
     experimental.

     Note that with DWARF Version 2, some ports require and always use
     some non-conflicting DWARF 3 extensions in the unwind tables.

     Version 4 may require GDB 7.0 and '-fvar-tracking-assignments' for
     maximum benefit.

     GCC no longer supports DWARF Version 1, which is substantially
     different than Version 2 and later.  For historical reasons, some
     other DWARF-related options such as '-fno-dwarf2-cfi-asm') retain a
     reference to DWARF Version 2 in their names, but apply to all
     currently-supported versions of DWARF.

'-gstabs'
     Produce debugging information in stabs format (if that is
     supported), without GDB extensions.  This is the format used by DBX
     on most BSD systems.  On MIPS, Alpha and System V Release 4 systems
     this option produces stabs debugging output that is not understood
     by DBX.  On System V Release 4 systems this option requires the GNU
     assembler.

'-gstabs+'
     Produce debugging information in stabs format (if that is
     supported), using GNU extensions understood only by the GNU
     debugger (GDB).  The use of these extensions is likely to make
     other debuggers crash or refuse to read the program.

'-gxcoff'
     Produce debugging information in XCOFF format (if that is
     supported).  This is the format used by the DBX debugger on IBM
     RS/6000 systems.

'-gxcoff+'
     Produce debugging information in XCOFF format (if that is
     supported), using GNU extensions understood only by the GNU
     debugger (GDB).  The use of these extensions is likely to make
     other debuggers crash or refuse to read the program, and may cause
     assemblers other than the GNU assembler (GAS) to fail with an
     error.

'-gvms'
     Produce debugging information in Alpha/VMS debug format (if that is
     supported).  This is the format used by DEBUG on Alpha/VMS systems.

'-gLEVEL'
'-ggdbLEVEL'
'-gstabsLEVEL'
'-gxcoffLEVEL'
'-gvmsLEVEL'
     Request debugging information and also use LEVEL to specify how
     much information.  The default level is 2.

     Level 0 produces no debug information at all.  Thus, '-g0' negates
     '-g'.

     Level 1 produces minimal information, enough for making backtraces
     in parts of the program that you don't plan to debug.  This
     includes descriptions of functions and external variables, and line
     number tables, but no information about local variables.

     Level 3 includes extra information, such as all the macro
     definitions present in the program.  Some debuggers support macro
     expansion when you use '-g3'.

     If you use multiple '-g' options, with or without level numbers,
     the last such option is the one that is effective.

     '-gdwarf' does not accept a concatenated debug level, to avoid
     confusion with '-gdwarf-LEVEL'.  Instead use an additional
     '-gLEVEL' option to change the debug level for DWARF.

'-feliminate-unused-debug-symbols'
     Produce debugging information in stabs format (if that is
     supported), for only symbols that are actually used.

'-femit-class-debug-always'
     Instead of emitting debugging information for a C++ class in only
     one object file, emit it in all object files using the class.  This
     option should be used only with debuggers that are unable to handle
     the way GCC normally emits debugging information for classes
     because using this option increases the size of debugging
     information by as much as a factor of two.

'-fno-merge-debug-strings'
     Direct the linker to not merge together strings in the debugging
     information that are identical in different object files.  Merging
     is not supported by all assemblers or linkers.  Merging decreases
     the size of the debug information in the output file at the cost of
     increasing link processing time.  Merging is enabled by default.

'-fdebug-prefix-map=OLD=NEW'
     When compiling files residing in directory 'OLD', record debugging
     information describing them as if the files resided in directory
     'NEW' instead.  This can be used to replace a build-time path with
     an install-time path in the debug info.  It can also be used to
     change an absolute path to a relative path by using '.' for NEW.
     This can give more reproducible builds, which are location
     independent, but may require an extra command to tell GDB where to
     find the source files.  See also '-ffile-prefix-map'.

'-fvar-tracking'
     Run variable tracking pass.  It computes where variables are stored
     at each position in code.  Better debugging information is then
     generated (if the debugging information format supports this
     information).

     It is enabled by default when compiling with optimization ('-Os',
     '-O', '-O2', ...), debugging information ('-g') and the debug info
     format supports it.

'-fvar-tracking-assignments'
     Annotate assignments to user variables early in the compilation and
     attempt to carry the annotations over throughout the compilation
     all the way to the end, in an attempt to improve debug information
     while optimizing.  Use of '-gdwarf-4' is recommended along with it.

     It can be enabled even if var-tracking is disabled, in which case
     annotations are created and maintained, but discarded at the end.
     By default, this flag is enabled together with '-fvar-tracking',
     except when selective scheduling is enabled.

'-gsplit-dwarf'
     Separate as much DWARF debugging information as possible into a
     separate output file with the extension '.dwo'.  This option allows
     the build system to avoid linking files with debug information.  To
     be useful, this option requires a debugger capable of reading
     '.dwo' files.

'-gdescribe-dies'
     Add description attributes to some DWARF DIEs that have no name
     attribute, such as artificial variables, external references and
     call site parameter DIEs.

'-gpubnames'
     Generate DWARF '.debug_pubnames' and '.debug_pubtypes' sections.

'-ggnu-pubnames'
     Generate '.debug_pubnames' and '.debug_pubtypes' sections in a
     format suitable for conversion into a GDB index.  This option is
     only useful with a linker that can produce GDB index version 7.

'-fdebug-types-section'
     When using DWARF Version 4 or higher, type DIEs can be put into
     their own '.debug_types' section instead of making them part of the
     '.debug_info' section.  It is more efficient to put them in a
     separate comdat section since the linker can then remove
     duplicates.  But not all DWARF consumers support '.debug_types'
     sections yet and on some objects '.debug_types' produces larger
     instead of smaller debugging information.

'-grecord-gcc-switches'
'-gno-record-gcc-switches'
     This switch causes the command-line options used to invoke the
     compiler that may affect code generation to be appended to the
     DW_AT_producer attribute in DWARF debugging information.  The
     options are concatenated with spaces separating them from each
     other and from the compiler version.  It is enabled by default.
     See also '-frecord-gcc-switches' for another way of storing
     compiler options into the object file.

'-gstrict-dwarf'
     Disallow using extensions of later DWARF standard version than
     selected with '-gdwarf-VERSION'.  On most targets using
     non-conflicting DWARF extensions from later standard versions is
     allowed.

'-gno-strict-dwarf'
     Allow using extensions of later DWARF standard version than
     selected with '-gdwarf-VERSION'.

'-gas-loc-support'
     Inform the compiler that the assembler supports '.loc' directives.
     It may then use them for the assembler to generate DWARF2+ line
     number tables.

     This is generally desirable, because assembler-generated
     line-number tables are a lot more compact than those the compiler
     can generate itself.

     This option will be enabled by default if, at GCC configure time,
     the assembler was found to support such directives.

'-gno-as-loc-support'
     Force GCC to generate DWARF2+ line number tables internally, if
     DWARF2+ line number tables are to be generated.

'gas-locview-support'
     Inform the compiler that the assembler supports 'view' assignment
     and reset assertion checking in '.loc' directives.

     This option will be enabled by default if, at GCC configure time,
     the assembler was found to support them.

'gno-as-locview-support'
     Force GCC to assign view numbers internally, if
     '-gvariable-location-views' are explicitly requested.

'-gcolumn-info'
'-gno-column-info'
     Emit location column information into DWARF debugging information,
     rather than just file and line.  This option is enabled by default.

'-gstatement-frontiers'
'-gno-statement-frontiers'
     This option causes GCC to create markers in the internal
     representation at the beginning of statements, and to keep them
     roughly in place throughout compilation, using them to guide the
     output of 'is_stmt' markers in the line number table.  This is
     enabled by default when compiling with optimization ('-Os', '-O',
     '-O2', ...), and outputting DWARF 2 debug information at the normal
     level.

'-gvariable-location-views'
'-gvariable-location-views=incompat5'
'-gno-variable-location-views'
     Augment variable location lists with progressive view numbers
     implied from the line number table.  This enables debug information
     consumers to inspect state at certain points of the program, even
     if no instructions associated with the corresponding source
     locations are present at that point.  If the assembler lacks
     support for view numbers in line number tables, this will cause the
     compiler to emit the line number table, which generally makes them
     somewhat less compact.  The augmented line number tables and
     location lists are fully backward-compatible, so they can be
     consumed by debug information consumers that are not aware of these
     augmentations, but they won't derive any benefit from them either.

     This is enabled by default when outputting DWARF 2 debug
     information at the normal level, as long as there is assembler
     support, '-fvar-tracking-assignments' is enabled and
     '-gstrict-dwarf' is not.  When assembler support is not available,
     this may still be enabled, but it will force GCC to output internal
     line number tables, and if '-ginternal-reset-location-views' is not
     enabled, that will most certainly lead to silently mismatching
     location views.

     There is a proposed representation for view numbers that is not
     backward compatible with the location list format introduced in
     DWARF 5, that can be enabled with
     '-gvariable-location-views=incompat5'.  This option may be removed
     in the future, is only provided as a reference implementation of
     the proposed representation.  Debug information consumers are not
     expected to support this extended format, and they would be
     rendered unable to decode location lists using it.

'-ginternal-reset-location-views'
'-gnointernal-reset-location-views'
     Attempt to determine location views that can be omitted from
     location view lists.  This requires the compiler to have very
     accurate insn length estimates, which isn't always the case, and it
     may cause incorrect view lists to be generated silently when using
     an assembler that does not support location view lists.  The GNU
     assembler will flag any such error as a 'view number mismatch'.
     This is only enabled on ports that define a reliable estimation
     function.

'-ginline-points'
'-gno-inline-points'
     Generate extended debug information for inlined functions.
     Location view tracking markers are inserted at inlined entry
     points, so that address and view numbers can be computed and output
     in debug information.  This can be enabled independently of
     location views, in which case the view numbers won't be output, but
     it can only be enabled along with statement frontiers, and it is
     only enabled by default if location views are enabled.

'-gz[=TYPE]'
     Produce compressed debug sections in DWARF format, if that is
     supported.  If TYPE is not given, the default type depends on the
     capabilities of the assembler and linker used.  TYPE may be one of
     'none' (don't compress debug sections), 'zlib' (use zlib
     compression in ELF gABI format), or 'zlib-gnu' (use zlib
     compression in traditional GNU format).  If the linker doesn't
     support writing compressed debug sections, the option is rejected.
     Otherwise, if the assembler does not support them, '-gz' is
     silently ignored when producing object files.

'-femit-struct-debug-baseonly'
     Emit debug information for struct-like types only when the base
     name of the compilation source file matches the base name of file
     in which the struct is defined.

     This option substantially reduces the size of debugging
     information, but at significant potential loss in type information
     to the debugger.  See '-femit-struct-debug-reduced' for a less
     aggressive option.  See '-femit-struct-debug-detailed' for more
     detailed control.

     This option works only with DWARF debug output.

'-femit-struct-debug-reduced'
     Emit debug information for struct-like types only when the base
     name of the compilation source file matches the base name of file
     in which the type is defined, unless the struct is a template or
     defined in a system header.

     This option significantly reduces the size of debugging
     information, with some potential loss in type information to the
     debugger.  See '-femit-struct-debug-baseonly' for a more aggressive
     option.  See '-femit-struct-debug-detailed' for more detailed
     control.

     This option works only with DWARF debug output.

'-femit-struct-debug-detailed[=SPEC-LIST]'
     Specify the struct-like types for which the compiler generates
     debug information.  The intent is to reduce duplicate struct debug
     information between different object files within the same program.

     This option is a detailed version of '-femit-struct-debug-reduced'
     and '-femit-struct-debug-baseonly', which serves for most needs.

     A specification has the syntax
     ['dir:'|'ind:']['ord:'|'gen:']('any'|'sys'|'base'|'none')

     The optional first word limits the specification to structs that
     are used directly ('dir:') or used indirectly ('ind:').  A struct
     type is used directly when it is the type of a variable, member.
     Indirect uses arise through pointers to structs.  That is, when use
     of an incomplete struct is valid, the use is indirect.  An example
     is 'struct one direct; struct two * indirect;'.

     The optional second word limits the specification to ordinary
     structs ('ord:') or generic structs ('gen:').  Generic structs are
     a bit complicated to explain.  For C++, these are non-explicit
     specializations of template classes, or non-template classes within
     the above.  Other programming languages have generics, but
     '-femit-struct-debug-detailed' does not yet implement them.

     The third word specifies the source files for those structs for
     which the compiler should emit debug information.  The values
     'none' and 'any' have the normal meaning.  The value 'base' means
     that the base of name of the file in which the type declaration
     appears must match the base of the name of the main compilation
     file.  In practice, this means that when compiling 'foo.c', debug
     information is generated for types declared in that file and
     'foo.h', but not other header files.  The value 'sys' means those
     types satisfying 'base' or declared in system or compiler headers.

     You may need to experiment to determine the best settings for your
     application.

     The default is '-femit-struct-debug-detailed=all'.

     This option works only with DWARF debug output.

'-fno-dwarf2-cfi-asm'
     Emit DWARF unwind info as compiler generated '.eh_frame' section
     instead of using GAS '.cfi_*' directives.

'-fno-eliminate-unused-debug-types'
     Normally, when producing DWARF output, GCC avoids producing debug
     symbol output for types that are nowhere used in the source file
     being compiled.  Sometimes it is useful to have GCC emit debugging
     information for all types declared in a compilation unit,
     regardless of whether or not they are actually used in that
     compilation unit, for example if, in the debugger, you want to cast
     a value to a type that is not actually used in your program (but is
     declared).  More often, however, this results in a significant
     amount of wasted space.

==============================================================================
File: gcc.info,  Node: |Optimize_Options|,  Next: |Instrumentation_Options|,  Prev: |Debugging_Options|,  Up: |Invoking_GCC|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Optimize_Options*

3.10 Options That Control Optimization
==========----------------------------

These options control various sorts of optimizations.

 Without any optimization option, the compiler's goal is to reduce the
cost of compilation and to make debugging produce the expected results.
Statements are independent: if you stop the program with a breakpoint
between statements, you can then assign a new value to any variable or
change the program counter to any other statement in the function and
get exactly the results you expect from the source code.

 Turning on optimization flags makes the compiler attempt to improve the
performance and/or code size at the expense of compilation time and
possibly the ability to debug the program.

 The compiler performs optimization based on the knowledge it has of the
program.  Compiling multiple files at once to a single output file mode
allows the compiler to use information gained from all of the files when
compiling each of them.

 Not all optimizations are controlled directly by a flag.  Only
optimizations that have a flag are listed in this section.

 Most optimizations are completely disabled at '-O0' or if an '-O' level
is not set on the command line, even if individual optimization flags
are specified.  Similarly, '-Og' suppresses many optimization passes.

 Depending on the target and how GCC was configured, a slightly
different set of optimizations may be enabled at each '-O' level than
those listed here.  You can invoke GCC with '-Q --help=optimizers' to
find out the exact set of optimizations that are enabled at each level.
*Note Overall Options::, for examples.

'-O'
'-O1'
     Optimize.  Optimizing compilation takes somewhat more time, and a
     lot more memory for a large function.

     With '-O', the compiler tries to reduce code size and execution
     time, without performing any optimizations that take a great deal
     of compilation time.

     '-O' turns on the following optimization flags:

          -fauto-inc-dec
          -fbranch-count-reg
          -fcombine-stack-adjustments
          -fcompare-elim
          -fcprop-registers
          -fdce
          -fdefer-pop
          -fdelayed-branch
          -fdse
          -fforward-propagate
          -fguess-branch-probability
          -fif-conversion
          -fif-conversion2
          -finline-functions-called-once
          -fipa-profile
          -fipa-pure-const
          -fipa-reference
          -fipa-reference-addressable
          -fmerge-constants
          -fmove-loop-invariants
          -fomit-frame-pointer
          -freorder-blocks
          -fshrink-wrap
          -fshrink-wrap-separate
          -fsplit-wide-types
          -fssa-backprop
          -fssa-phiopt
          -ftree-bit-ccp
          -ftree-ccp
          -ftree-ch
          -ftree-coalesce-vars
          -ftree-copy-prop
          -ftree-dce
          -ftree-dominator-opts
          -ftree-dse
          -ftree-forwprop
          -ftree-fre
          -ftree-phiprop
          -ftree-pta
          -ftree-scev-cprop
          -ftree-sink
          -ftree-slsr
          -ftree-sra
          -ftree-ter
          -funit-at-a-time

'-O2'
     Optimize even more.  GCC performs nearly all supported
     optimizations that do not involve a space-speed tradeoff.  As
     compared to '-O', this option increases both compilation time and
     the performance of the generated code.

     '-O2' turns on all optimization flags specified by '-O'.  It also
     turns on the following optimization flags:

          -falign-functions  -falign-jumps
          -falign-labels  -falign-loops
          -fcaller-saves
          -fcode-hoisting
          -fcrossjumping
          -fcse-follow-jumps  -fcse-skip-blocks
          -fdelete-null-pointer-checks
          -fdevirtualize  -fdevirtualize-speculatively
          -fexpensive-optimizations
          -fgcse  -fgcse-lm
          -fhoist-adjacent-loads
          -finline-small-functions
          -findirect-inlining
          -fipa-bit-cp  -fipa-cp  -fipa-icf
          -fipa-ra  -fipa-sra  -fipa-vrp
          -fisolate-erroneous-paths-dereference
          -flra-remat
          -foptimize-sibling-calls
          -foptimize-strlen
          -fpartial-inlining
          -fpeephole2
          -freorder-blocks-algorithm=stc
          -freorder-blocks-and-partition  -freorder-functions
          -frerun-cse-after-loop
          -fschedule-insns  -fschedule-insns2
          -fsched-interblock  -fsched-spec
          -fstore-merging
          -fstrict-aliasing
          -fthread-jumps
          -ftree-builtin-call-dce
          -ftree-pre
          -ftree-switch-conversion  -ftree-tail-merge
          -ftree-vrp

     Please note the warning under '-fgcse' about invoking '-O2' on
     programs that use computed gotos.

'-O3'
     Optimize yet more.  '-O3' turns on all optimizations specified by
     '-O2' and also turns on the following optimization flags:

          -fgcse-after-reload
          -finline-functions
          -fipa-cp-clone
          -floop-interchange
          -floop-unroll-and-jam
          -fpeel-loops
          -fpredictive-commoning
          -fsplit-paths
          -ftree-loop-distribute-patterns
          -ftree-loop-distribution
          -ftree-loop-vectorize
          -ftree-partial-pre
          -ftree-slp-vectorize
          -funswitch-loops
          -fvect-cost-model
          -fversion-loops-for-strides

'-O0'
     Reduce compilation time and make debugging produce the expected
     results.  This is the default.

'-Os'
     Optimize for size.  '-Os' enables all '-O2' optimizations except
     those that often increase code size:

          -falign-functions  -falign-jumps
          -falign-labels  -falign-loops
          -fprefetch-loop-arrays  -freorder-blocks-algorithm=stc

     It also enables '-finline-functions', causes the compiler to tune
     for code size rather than execution speed, and performs further
     optimizations designed to reduce code size.

'-Ofast'
     Disregard strict standards compliance.  '-Ofast' enables all '-O3'
     optimizations.  It also enables optimizations that are not valid
     for all standard-compliant programs.  It turns on '-ffast-math' and
     the Fortran-specific '-fstack-arrays', unless
     '-fmax-stack-var-size' is specified, and '-fno-protect-parens'.

'-Og'
     Optimize debugging experience.  '-Og' should be the optimization
     level of choice for the standard edit-compile-debug cycle, offering
     a reasonable level of optimization while maintaining fast
     compilation and a good debugging experience.  It is a better choice
     than '-O0' for producing debuggable code because some compiler
     passes that collect debug information are disabled at '-O0'.

     Like '-O0', '-Og' completely disables a number of optimization
     passes so that individual options controlling them have no effect.
     Otherwise '-Og' enables all '-O1' optimization flags except for
     those that may interfere with debugging:

          -fbranch-count-reg  -fdelayed-branch
          -fif-conversion  -fif-conversion2
          -finline-functions-called-once
          -fmove-loop-invariants  -fssa-phiopt
          -ftree-bit-ccp  -ftree-pta  -ftree-sra

 If you use multiple '-O' options, with or without level numbers, the
last such option is the one that is effective.

 Options of the form '-fFLAG' specify machine-independent flags.  Most
flags have both positive and negative forms; the negative form of
'-ffoo' is '-fno-foo'.  In the table below, only one of the forms is
listed--the one you typically use.  You can figure out the other form by
either removing 'no-' or adding it.

 The following options control specific optimizations.  They are either
activated by '-O' options or are related to ones that are.  You can use
the following flags in the rare cases when "fine-tuning" of
optimizations to be performed is desired.

'-fno-defer-pop'
     For machines that must pop arguments after a function call, always
     pop the arguments as soon as each function returns.  At levels
     '-O1' and higher, '-fdefer-pop' is the default; this allows the
     compiler to let arguments accumulate on the stack for several
     function calls and pop them all at once.

'-fforward-propagate'
     Perform a forward propagation pass on RTL.  The pass tries to
     combine two instructions and checks if the result can be
     simplified.  If loop unrolling is active, two passes are performed
     and the second is scheduled after loop unrolling.

     This option is enabled by default at optimization levels '-O',
     '-O2', '-O3', '-Os'.

'-ffp-contract=STYLE'
     '-ffp-contract=off' disables floating-point expression contraction.
     '-ffp-contract=fast' enables floating-point expression contraction
     such as forming of fused multiply-add operations if the target has
     native support for them.  '-ffp-contract=on' enables floating-point
     expression contraction if allowed by the language standard.  This
     is currently not implemented and treated equal to
     '-ffp-contract=off'.

     The default is '-ffp-contract=fast'.

'-fomit-frame-pointer'
     Omit the frame pointer in functions that don't need one.  This
     avoids the instructions to save, set up and restore the frame
     pointer; on many targets it also makes an extra register available.

     On some targets this flag has no effect because the standard
     calling sequence always uses a frame pointer, so it cannot be
     omitted.

     Note that '-fno-omit-frame-pointer' doesn't guarantee the frame
     pointer is used in all functions.  Several targets always omit the
     frame pointer in leaf functions.

     Enabled by default at '-O' and higher.

'-foptimize-sibling-calls'
     Optimize sibling and tail recursive calls.

     Enabled at levels '-O2', '-O3', '-Os'.

'-foptimize-strlen'
     Optimize various standard C string functions (e.g. 'strlen',
     'strchr' or 'strcpy') and their '_FORTIFY_SOURCE' counterparts into
     faster alternatives.

     Enabled at levels '-O2', '-O3'.

'-fno-inline'
     Do not expand any functions inline apart from those marked with the
     'always_inline' attribute.  This is the default when not
     optimizing.

     Single functions can be exempted from inlining by marking them with
     the 'noinline' attribute.

'-finline-small-functions'
     Integrate functions into their callers when their body is smaller
     than expected function call code (so overall size of program gets
     smaller).  The compiler heuristically decides which functions are
     simple enough to be worth integrating in this way.  This inlining
     applies to all functions, even those not declared inline.

     Enabled at levels '-O2', '-O3', '-Os'.

'-findirect-inlining'
     Inline also indirect calls that are discovered to be known at
     compile time thanks to previous inlining.  This option has any
     effect only when inlining itself is turned on by the
     '-finline-functions' or '-finline-small-functions' options.

     Enabled at levels '-O2', '-O3', '-Os'.

'-finline-functions'
     Consider all functions for inlining, even if they are not declared
     inline.  The compiler heuristically decides which functions are
     worth integrating in this way.

     If all calls to a given function are integrated, and the function
     is declared 'static', then the function is normally not output as
     assembler code in its own right.

     Enabled at levels '-O3', '-Os'.  Also enabled by '-fprofile-use'
     and '-fauto-profile'.

'-finline-functions-called-once'
     Consider all 'static' functions called once for inlining into their
     caller even if they are not marked 'inline'.  If a call to a given
     function is integrated, then the function is not output as
     assembler code in its own right.

     Enabled at levels '-O1', '-O2', '-O3' and '-Os', but not '-Og'.

'-fearly-inlining'
     Inline functions marked by 'always_inline' and functions whose body
     seems smaller than the function call overhead early before doing
     '-fprofile-generate' instrumentation and real inlining pass.  Doing
     so makes profiling significantly cheaper and usually inlining
     faster on programs having large chains of nested wrapper functions.

     Enabled by default.

'-fipa-sra'
     Perform interprocedural scalar replacement of aggregates, removal
     of unused parameters and replacement of parameters passed by
     reference by parameters passed by value.

     Enabled at levels '-O2', '-O3' and '-Os'.

'-finline-limit=N'
     By default, GCC limits the size of functions that can be inlined.
     This flag allows coarse control of this limit.  N is the size of
     functions that can be inlined in number of pseudo instructions.

     Inlining is actually controlled by a number of parameters, which
     may be specified individually by using '--param NAME=VALUE'.  The
     '-finline-limit=N' option sets some of these parameters as follows:

     'max-inline-insns-single'
          is set to N/2.
     'max-inline-insns-auto'
          is set to N/2.

     See below for a documentation of the individual parameters
     controlling inlining and for the defaults of these parameters.

     _Note:_ there may be no value to '-finline-limit' that results in
     default behavior.

     _Note:_ pseudo instruction represents, in this particular context,
     an abstract measurement of function's size.  In no way does it
     represent a count of assembly instructions and as such its exact
     meaning might change from one release to an another.

'-fno-keep-inline-dllexport'
     This is a more fine-grained version of '-fkeep-inline-functions',
     which applies only to functions that are declared using the
     'dllexport' attribute or declspec.  *Note Declaring Attributes of
     Functions: Function Attributes.

'-fkeep-inline-functions'
     In C, emit 'static' functions that are declared 'inline' into the
     object file, even if the function has been inlined into all of its
     callers.  This switch does not affect functions using the 'extern
     inline' extension in GNU C90.  In C++, emit any and all inline
     functions into the object file.

'-fkeep-static-functions'
     Emit 'static' functions into the object file, even if the function
     is never used.

'-fkeep-static-consts'
     Emit variables declared 'static const' when optimization isn't
     turned on, even if the variables aren't referenced.

     GCC enables this option by default.  If you want to force the
     compiler to check if a variable is referenced, regardless of
     whether or not optimization is turned on, use the
     '-fno-keep-static-consts' option.

'-fmerge-constants'
     Attempt to merge identical constants (string constants and
     floating-point constants) across compilation units.

     This option is the default for optimized compilation if the
     assembler and linker support it.  Use '-fno-merge-constants' to
     inhibit this behavior.

     Enabled at levels '-O', '-O2', '-O3', '-Os'.

'-fmerge-all-constants'
     Attempt to merge identical constants and identical variables.

     This option implies '-fmerge-constants'.  In addition to
     '-fmerge-constants' this considers e.g. even constant initialized
     arrays or initialized constant variables with integral or
     floating-point types.  Languages like C or C++ require each
     variable, including multiple instances of the same variable in
     recursive calls, to have distinct locations, so using this option
     results in non-conforming behavior.

'-fmodulo-sched'
     Perform swing modulo scheduling immediately before the first
     scheduling pass.  This pass looks at innermost loops and reorders
     their instructions by overlapping different iterations.

'-fmodulo-sched-allow-regmoves'
     Perform more aggressive SMS-based modulo scheduling with register
     moves allowed.  By setting this flag certain anti-dependences edges
     are deleted, which triggers the generation of reg-moves based on
     the life-range analysis.  This option is effective only with
     '-fmodulo-sched' enabled.

'-fno-branch-count-reg'
     Disable the optimization pass that scans for opportunities to use
     "decrement and branch" instructions on a count register instead of
     instruction sequences that decrement a register, compare it against
     zero, and then branch based upon the result.  This option is only
     meaningful on architectures that support such instructions, which
     include x86, PowerPC, IA-64 and S/390.  Note that the
     '-fno-branch-count-reg' option doesn't remove the decrement and
     branch instructions from the generated instruction stream
     introduced by other optimization passes.

     The default is '-fbranch-count-reg' at '-O1' and higher, except for
     '-Og'.

'-fno-function-cse'
     Do not put function addresses in registers; make each instruction
     that calls a constant function contain the function's address
     explicitly.

     This option results in less efficient code, but some strange hacks
     that alter the assembler output may be confused by the
     optimizations performed when this option is not used.

     The default is '-ffunction-cse'

'-fno-zero-initialized-in-bss'
     If the target supports a BSS section, GCC by default puts variables
     that are initialized to zero into BSS.  This can save space in the
     resulting code.

     This option turns off this behavior because some programs
     explicitly rely on variables going to the data section--e.g., so
     that the resulting executable can find the beginning of that
     section and/or make assumptions based on that.

     The default is '-fzero-initialized-in-bss'.

'-fthread-jumps'
     Perform optimizations that check to see if a jump branches to a
     location where another comparison subsumed by the first is found.
     If so, the first branch is redirected to either the destination of
     the second branch or a point immediately following it, depending on
     whether the condition is known to be true or false.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fsplit-wide-types'
     When using a type that occupies multiple registers, such as 'long
     long' on a 32-bit system, split the registers apart and allocate
     them independently.  This normally generates better code for those
     types, but may make debugging more difficult.

     Enabled at levels '-O', '-O2', '-O3', '-Os'.

'-fcse-follow-jumps'
     In common subexpression elimination (CSE), scan through jump
     instructions when the target of the jump is not reached by any
     other path.  For example, when CSE encounters an 'if' statement
     with an 'else' clause, CSE follows the jump when the condition
     tested is false.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fcse-skip-blocks'
     This is similar to '-fcse-follow-jumps', but causes CSE to follow
     jumps that conditionally skip over blocks.  When CSE encounters a
     simple 'if' statement with no else clause, '-fcse-skip-blocks'
     causes CSE to follow the jump around the body of the 'if'.

     Enabled at levels '-O2', '-O3', '-Os'.

'-frerun-cse-after-loop'
     Re-run common subexpression elimination after loop optimizations
     are performed.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fgcse'
     Perform a global common subexpression elimination pass.  This pass
     also performs global constant and copy propagation.

     _Note:_ When compiling a program using computed gotos, a GCC
     extension, you may get better run-time performance if you disable
     the global common subexpression elimination pass by adding
     '-fno-gcse' to the command line.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fgcse-lm'
     When '-fgcse-lm' is enabled, global common subexpression
     elimination attempts to move loads that are only killed by stores
     into themselves.  This allows a loop containing a load/store
     sequence to be changed to a load outside the loop, and a copy/store
     within the loop.

     Enabled by default when '-fgcse' is enabled.

'-fgcse-sm'
     When '-fgcse-sm' is enabled, a store motion pass is run after
     global common subexpression elimination.  This pass attempts to
     move stores out of loops.  When used in conjunction with
     '-fgcse-lm', loops containing a load/store sequence can be changed
     to a load before the loop and a store after the loop.

     Not enabled at any optimization level.

'-fgcse-las'
     When '-fgcse-las' is enabled, the global common subexpression
     elimination pass eliminates redundant loads that come after stores
     to the same memory location (both partial and full redundancies).

     Not enabled at any optimization level.

'-fgcse-after-reload'
     When '-fgcse-after-reload' is enabled, a redundant load elimination
     pass is performed after reload.  The purpose of this pass is to
     clean up redundant spilling.

     Enabled by '-fprofile-use' and '-fauto-profile'.

'-faggressive-loop-optimizations'
     This option tells the loop optimizer to use language constraints to
     derive bounds for the number of iterations of a loop.  This assumes
     that loop code does not invoke undefined behavior by for example
     causing signed integer overflows or out-of-bound array accesses.
     The bounds for the number of iterations of a loop are used to guide
     loop unrolling and peeling and loop exit test optimizations.  This
     option is enabled by default.

'-funconstrained-commons'
     This option tells the compiler that variables declared in common
     blocks (e.g. Fortran) may later be overridden with longer trailing
     arrays.  This prevents certain optimizations that depend on knowing
     the array bounds.

'-fcrossjumping'
     Perform cross-jumping transformation.  This transformation unifies
     equivalent code and saves code size.  The resulting code may or may
     not perform better than without cross-jumping.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fauto-inc-dec'
     Combine increments or decrements of addresses with memory accesses.
     This pass is always skipped on architectures that do not have
     instructions to support this.  Enabled by default at '-O' and
     higher on architectures that support this.

'-fdce'
     Perform dead code elimination (DCE) on RTL.  Enabled by default at
     '-O' and higher.

'-fdse'
     Perform dead store elimination (DSE) on RTL.  Enabled by default at
     '-O' and higher.

'-fif-conversion'
     Attempt to transform conditional jumps into branch-less
     equivalents.  This includes use of conditional moves, min, max, set
     flags and abs instructions, and some tricks doable by standard
     arithmetics.  The use of conditional execution on chips where it is
     available is controlled by '-fif-conversion2'.

     Enabled at levels '-O', '-O2', '-O3', '-Os', but not with '-Og'.

'-fif-conversion2'
     Use conditional execution (where available) to transform
     conditional jumps into branch-less equivalents.

     Enabled at levels '-O', '-O2', '-O3', '-Os', but not with '-Og'.

'-fdeclone-ctor-dtor'
     The C++ ABI requires multiple entry points for constructors and
     destructors: one for a base subobject, one for a complete object,
     and one for a virtual destructor that calls operator delete
     afterwards.  For a hierarchy with virtual bases, the base and
     complete variants are clones, which means two copies of the
     function.  With this option, the base and complete variants are
     changed to be thunks that call a common implementation.

     Enabled by '-Os'.

'-fdelete-null-pointer-checks'
     Assume that programs cannot safely dereference null pointers, and
     that no code or data element resides at address zero.  This option
     enables simple constant folding optimizations at all optimization
     levels.  In addition, other optimization passes in GCC use this
     flag to control global dataflow analyses that eliminate useless
     checks for null pointers; these assume that a memory access to
     address zero always results in a trap, so that if a pointer is
     checked after it has already been dereferenced, it cannot be null.

     Note however that in some environments this assumption is not true.
     Use '-fno-delete-null-pointer-checks' to disable this optimization
     for programs that depend on that behavior.

     This option is enabled by default on most targets.  On Nios II ELF,
     it defaults to off.  On AVR, CR16, and MSP430, this option is
     completely disabled.

     Passes that use the dataflow information are enabled independently
     at different optimization levels.

'-fdevirtualize'
     Attempt to convert calls to virtual functions to direct calls.
     This is done both within a procedure and interprocedurally as part
     of indirect inlining ('-findirect-inlining') and interprocedural
     constant propagation ('-fipa-cp').  Enabled at levels '-O2', '-O3',
     '-Os'.

'-fdevirtualize-speculatively'
     Attempt to convert calls to virtual functions to speculative direct
     calls.  Based on the analysis of the type inheritance graph,
     determine for a given call the set of likely targets.  If the set
     is small, preferably of size 1, change the call into a conditional
     deciding between direct and indirect calls.  The speculative calls
     enable more optimizations, such as inlining.  When they seem
     useless after further optimization, they are converted back into
     original form.

'-fdevirtualize-at-ltrans'
     Stream extra information needed for aggressive devirtualization
     when running the link-time optimizer in local transformation mode.
     This option enables more devirtualization but significantly
     increases the size of streamed data.  For this reason it is
     disabled by default.

'-fexpensive-optimizations'
     Perform a number of minor optimizations that are relatively
     expensive.

     Enabled at levels '-O2', '-O3', '-Os'.

'-free'
     Attempt to remove redundant extension instructions.  This is
     especially helpful for the x86-64 architecture, which implicitly
     zero-extends in 64-bit registers after writing to their lower
     32-bit half.

     Enabled for Alpha, AArch64 and x86 at levels '-O2', '-O3', '-Os'.

'-fno-lifetime-dse'
     In C++ the value of an object is only affected by changes within
     its lifetime: when the constructor begins, the object has an
     indeterminate value, and any changes during the lifetime of the
     object are dead when the object is destroyed.  Normally dead store
     elimination will take advantage of this; if your code relies on the
     value of the object storage persisting beyond the lifetime of the
     object, you can use this flag to disable this optimization.  To
     preserve stores before the constructor starts (e.g. because your
     operator new clears the object storage) but still treat the object
     as dead after the destructor you, can use '-flifetime-dse=1'.  The
     default behavior can be explicitly selected with
     '-flifetime-dse=2'.  '-flifetime-dse=0' is equivalent to
     '-fno-lifetime-dse'.

'-flive-range-shrinkage'
     Attempt to decrease register pressure through register live range
     shrinkage.  This is helpful for fast processors with small or
     moderate size register sets.

'-fira-algorithm=ALGORITHM'
     Use the specified coloring algorithm for the integrated register
     allocator.  The ALGORITHM argument can be 'priority', which
     specifies Chow's priority coloring, or 'CB', which specifies
     Chaitin-Briggs coloring.  Chaitin-Briggs coloring is not
     implemented for all architectures, but for those targets that do
     support it, it is the default because it generates better code.

'-fira-region=REGION'
     Use specified regions for the integrated register allocator.  The
     REGION argument should be one of the following:

     'all'
          Use all loops as register allocation regions.  This can give
          the best results for machines with a small and/or irregular
          register set.

     'mixed'
          Use all loops except for loops with small register pressure as
          the regions.  This value usually gives the best results in
          most cases and for most architectures, and is enabled by
          default when compiling with optimization for speed ('-O',
          '-O2', ...).

     'one'
          Use all functions as a single region.  This typically results
          in the smallest code size, and is enabled by default for '-Os'
          or '-O0'.

'-fira-hoist-pressure'
     Use IRA to evaluate register pressure in the code hoisting pass for
     decisions to hoist expressions.  This option usually results in
     smaller code, but it can slow the compiler down.

     This option is enabled at level '-Os' for all targets.

'-fira-loop-pressure'
     Use IRA to evaluate register pressure in loops for decisions to
     move loop invariants.  This option usually results in generation of
     faster and smaller code on machines with large register files (>=
     32 registers), but it can slow the compiler down.

     This option is enabled at level '-O3' for some targets.

'-fno-ira-share-save-slots'
     Disable sharing of stack slots used for saving call-used hard
     registers living through a call.  Each hard register gets a
     separate stack slot, and as a result function stack frames are
     larger.

'-fno-ira-share-spill-slots'
     Disable sharing of stack slots allocated for pseudo-registers.
     Each pseudo-register that does not get a hard register gets a
     separate stack slot, and as a result function stack frames are
     larger.

'-flra-remat'
     Enable CFG-sensitive rematerialization in LRA. Instead of loading
     values of spilled pseudos, LRA tries to rematerialize (recalculate)
     values if it is profitable.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fdelayed-branch'
     If supported for the target machine, attempt to reorder
     instructions to exploit instruction slots available after delayed
     branch instructions.

     Enabled at levels '-O', '-O2', '-O3', '-Os', but not at '-Og'.

'-fschedule-insns'
     If supported for the target machine, attempt to reorder
     instructions to eliminate execution stalls due to required data
     being unavailable.  This helps machines that have slow floating
     point or memory load instructions by allowing other instructions to
     be issued until the result of the load or floating-point
     instruction is required.

     Enabled at levels '-O2', '-O3'.

'-fschedule-insns2'
     Similar to '-fschedule-insns', but requests an additional pass of
     instruction scheduling after register allocation has been done.
     This is especially useful on machines with a relatively small
     number of registers and where memory load instructions take more
     than one cycle.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fno-sched-interblock'
     Disable instruction scheduling across basic blocks, which is
     normally enabled when scheduling before register allocation, i.e.
     with '-fschedule-insns' or at '-O2' or higher.

'-fno-sched-spec'
     Disable speculative motion of non-load instructions, which is
     normally enabled when scheduling before register allocation, i.e.
     with '-fschedule-insns' or at '-O2' or higher.

'-fsched-pressure'
     Enable register pressure sensitive insn scheduling before register
     allocation.  This only makes sense when scheduling before register
     allocation is enabled, i.e. with '-fschedule-insns' or at '-O2' or
     higher.  Usage of this option can improve the generated code and
     decrease its size by preventing register pressure increase above
     the number of available hard registers and subsequent spills in
     register allocation.

'-fsched-spec-load'
     Allow speculative motion of some load instructions.  This only
     makes sense when scheduling before register allocation, i.e. with
     '-fschedule-insns' or at '-O2' or higher.

'-fsched-spec-load-dangerous'
     Allow speculative motion of more load instructions.  This only
     makes sense when scheduling before register allocation, i.e. with
     '-fschedule-insns' or at '-O2' or higher.

'-fsched-stalled-insns'
'-fsched-stalled-insns=N'
     Define how many insns (if any) can be moved prematurely from the
     queue of stalled insns into the ready list during the second
     scheduling pass.  '-fno-sched-stalled-insns' means that no insns
     are moved prematurely, '-fsched-stalled-insns=0' means there is no
     limit on how many queued insns can be moved prematurely.
     '-fsched-stalled-insns' without a value is equivalent to
     '-fsched-stalled-insns=1'.

'-fsched-stalled-insns-dep'
'-fsched-stalled-insns-dep=N'
     Define how many insn groups (cycles) are examined for a dependency
     on a stalled insn that is a candidate for premature removal from
     the queue of stalled insns.  This has an effect only during the
     second scheduling pass, and only if '-fsched-stalled-insns' is
     used.  '-fno-sched-stalled-insns-dep' is equivalent to
     '-fsched-stalled-insns-dep=0'.  '-fsched-stalled-insns-dep' without
     a value is equivalent to '-fsched-stalled-insns-dep=1'.

'-fsched2-use-superblocks'
     When scheduling after register allocation, use superblock
     scheduling.  This allows motion across basic block boundaries,
     resulting in faster schedules.  This option is experimental, as not
     all machine descriptions used by GCC model the CPU closely enough
     to avoid unreliable results from the algorithm.

     This only makes sense when scheduling after register allocation,
     i.e. with '-fschedule-insns2' or at '-O2' or higher.

'-fsched-group-heuristic'
     Enable the group heuristic in the scheduler.  This heuristic favors
     the instruction that belongs to a schedule group.  This is enabled
     by default when scheduling is enabled, i.e. with '-fschedule-insns'
     or '-fschedule-insns2' or at '-O2' or higher.

'-fsched-critical-path-heuristic'
     Enable the critical-path heuristic in the scheduler.  This
     heuristic favors instructions on the critical path.  This is
     enabled by default when scheduling is enabled, i.e. with
     '-fschedule-insns' or '-fschedule-insns2' or at '-O2' or higher.

'-fsched-spec-insn-heuristic'
     Enable the speculative instruction heuristic in the scheduler.
     This heuristic favors speculative instructions with greater
     dependency weakness.  This is enabled by default when scheduling is
     enabled, i.e. with '-fschedule-insns' or '-fschedule-insns2' or at
     '-O2' or higher.

'-fsched-rank-heuristic'
     Enable the rank heuristic in the scheduler.  This heuristic favors
     the instruction belonging to a basic block with greater size or
     frequency.  This is enabled by default when scheduling is enabled,
     i.e. with '-fschedule-insns' or '-fschedule-insns2' or at '-O2' or
     higher.

'-fsched-last-insn-heuristic'
     Enable the last-instruction heuristic in the scheduler.  This
     heuristic favors the instruction that is less dependent on the last
     instruction scheduled.  This is enabled by default when scheduling
     is enabled, i.e. with '-fschedule-insns' or '-fschedule-insns2' or
     at '-O2' or higher.

'-fsched-dep-count-heuristic'
     Enable the dependent-count heuristic in the scheduler.  This
     heuristic favors the instruction that has more instructions
     depending on it.  This is enabled by default when scheduling is
     enabled, i.e. with '-fschedule-insns' or '-fschedule-insns2' or at
     '-O2' or higher.

'-freschedule-modulo-scheduled-loops'
     Modulo scheduling is performed before traditional scheduling.  If a
     loop is modulo scheduled, later scheduling passes may change its
     schedule.  Use this option to control that behavior.

'-fselective-scheduling'
     Schedule instructions using selective scheduling algorithm.
     Selective scheduling runs instead of the first scheduler pass.

'-fselective-scheduling2'
     Schedule instructions using selective scheduling algorithm.
     Selective scheduling runs instead of the second scheduler pass.

'-fsel-sched-pipelining'
     Enable software pipelining of innermost loops during selective
     scheduling.  This option has no effect unless one of
     '-fselective-scheduling' or '-fselective-scheduling2' is turned on.

'-fsel-sched-pipelining-outer-loops'
     When pipelining loops during selective scheduling, also pipeline
     outer loops.  This option has no effect unless
     '-fsel-sched-pipelining' is turned on.

'-fsemantic-interposition'
     Some object formats, like ELF, allow interposing of symbols by the
     dynamic linker.  This means that for symbols exported from the DSO,
     the compiler cannot perform interprocedural propagation, inlining
     and other optimizations in anticipation that the function or
     variable in question may change.  While this feature is useful, for
     example, to rewrite memory allocation functions by a debugging
     implementation, it is expensive in the terms of code quality.  With
     '-fno-semantic-interposition' the compiler assumes that if
     interposition happens for functions the overwriting function will
     have precisely the same semantics (and side effects).  Similarly if
     interposition happens for variables, the constructor of the
     variable will be the same.  The flag has no effect for functions
     explicitly declared inline (where it is never allowed for
     interposition to change semantics) and for symbols explicitly
     declared weak.

'-fshrink-wrap'
     Emit function prologues only before parts of the function that need
     it, rather than at the top of the function.  This flag is enabled
     by default at '-O' and higher.

'-fshrink-wrap-separate'
     Shrink-wrap separate parts of the prologue and epilogue separately,
     so that those parts are only executed when needed.  This option is
     on by default, but has no effect unless '-fshrink-wrap' is also
     turned on and the target supports this.

'-fcaller-saves'
     Enable allocation of values to registers that are clobbered by
     function calls, by emitting extra instructions to save and restore
     the registers around such calls.  Such allocation is done only when
     it seems to result in better code.

     This option is always enabled by default on certain machines,
     usually those which have no call-preserved registers to use
     instead.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fcombine-stack-adjustments'
     Tracks stack adjustments (pushes and pops) and stack memory
     references and then tries to find ways to combine them.

     Enabled by default at '-O1' and higher.

'-fipa-ra'
     Use caller save registers for allocation if those registers are not
     used by any called function.  In that case it is not necessary to
     save and restore them around calls.  This is only possible if
     called functions are part of same compilation unit as current
     function and they are compiled before it.

     Enabled at levels '-O2', '-O3', '-Os', however the option is
     disabled if generated code will be instrumented for profiling
     ('-p', or '-pg') or if callee's register usage cannot be known
     exactly (this happens on targets that do not expose prologues and
     epilogues in RTL).

'-fconserve-stack'
     Attempt to minimize stack usage.  The compiler attempts to use less
     stack space, even if that makes the program slower.  This option
     implies setting the 'large-stack-frame' parameter to 100 and the
     'large-stack-frame-growth' parameter to 400.

'-ftree-reassoc'
     Perform reassociation on trees.  This flag is enabled by default at
     '-O' and higher.

'-fcode-hoisting'
     Perform code hoisting.  Code hoisting tries to move the evaluation
     of expressions executed on all paths to the function exit as early
     as possible.  This is especially useful as a code size
     optimization, but it often helps for code speed as well.  This flag
     is enabled by default at '-O2' and higher.

'-ftree-pre'
     Perform partial redundancy elimination (PRE) on trees.  This flag
     is enabled by default at '-O2' and '-O3'.

'-ftree-partial-pre'
     Make partial redundancy elimination (PRE) more aggressive.  This
     flag is enabled by default at '-O3'.

'-ftree-forwprop'
     Perform forward propagation on trees.  This flag is enabled by
     default at '-O' and higher.

'-ftree-fre'
     Perform full redundancy elimination (FRE) on trees.  The difference
     between FRE and PRE is that FRE only considers expressions that are
     computed on all paths leading to the redundant computation.  This
     analysis is faster than PRE, though it exposes fewer redundancies.
     This flag is enabled by default at '-O' and higher.

'-ftree-phiprop'
     Perform hoisting of loads from conditional pointers on trees.  This
     pass is enabled by default at '-O' and higher.

'-fhoist-adjacent-loads'
     Speculatively hoist loads from both branches of an if-then-else if
     the loads are from adjacent locations in the same structure and the
     target architecture has a conditional move instruction.  This flag
     is enabled by default at '-O2' and higher.

'-ftree-copy-prop'
     Perform copy propagation on trees.  This pass eliminates
     unnecessary copy operations.  This flag is enabled by default at
     '-O' and higher.

'-fipa-pure-const'
     Discover which functions are pure or constant.  Enabled by default
     at '-O' and higher.

'-fipa-reference'
     Discover which static variables do not escape the compilation unit.
     Enabled by default at '-O' and higher.

'-fipa-reference-addressable'
     Discover read-only, write-only and non-addressable static
     variables.  Enabled by default at '-O' and higher.

'-fipa-stack-alignment'
     Reduce stack alignment on call sites if possible.  Enabled by
     default.

'-fipa-pta'
     Perform interprocedural pointer analysis and interprocedural
     modification and reference analysis.  This option can cause
     excessive memory and compile-time usage on large compilation units.
     It is not enabled by default at any optimization level.

'-fipa-profile'
     Perform interprocedural profile propagation.  The functions called
     only from cold functions are marked as cold.  Also functions
     executed once (such as 'cold', 'noreturn', static constructors or
     destructors) are identified.  Cold functions and loop less parts of
     functions executed once are then optimized for size.  Enabled by
     default at '-O' and higher.

'-fipa-cp'
     Perform interprocedural constant propagation.  This optimization
     analyzes the program to determine when values passed to functions
     are constants and then optimizes accordingly.  This optimization
     can substantially increase performance if the application has
     constants passed to functions.  This flag is enabled by default at
     '-O2', '-Os' and '-O3'.  It is also enabled by '-fprofile-use' and
     '-fauto-profile'.

'-fipa-cp-clone'
     Perform function cloning to make interprocedural constant
     propagation stronger.  When enabled, interprocedural constant
     propagation performs function cloning when externally visible
     function can be called with constant arguments.  Because this
     optimization can create multiple copies of functions, it may
     significantly increase code size (see '--param
     ipcp-unit-growth=VALUE').  This flag is enabled by default at
     '-O3'.  It is also enabled by '-fprofile-use' and '-fauto-profile'.

'-fipa-bit-cp'
     When enabled, perform interprocedural bitwise constant propagation.
     This flag is enabled by default at '-O2' and by '-fprofile-use' and
     '-fauto-profile'.  It requires that '-fipa-cp' is enabled.

'-fipa-vrp'
     When enabled, perform interprocedural propagation of value ranges.
     This flag is enabled by default at '-O2'.  It requires that
     '-fipa-cp' is enabled.

'-fipa-icf'
     Perform Identical Code Folding for functions and read-only
     variables.  The optimization reduces code size and may disturb
     unwind stacks by replacing a function by equivalent one with a
     different name.  The optimization works more effectively with
     link-time optimization enabled.

     Although the behavior is similar to the Gold Linker's ICF
     optimization, GCC ICF works on different levels and thus the
     optimizations are not same - there are equivalences that are found
     only by GCC and equivalences found only by Gold.

     This flag is enabled by default at '-O2' and '-Os'.

'-flive-patching=LEVEL'
     Control GCC's optimizations to produce output suitable for
     live-patching.

     If the compiler's optimization uses a function's body or
     information extracted from its body to optimize/change another
     function, the latter is called an impacted function of the former.
     If a function is patched, its impacted functions should be patched
     too.

     The impacted functions are determined by the compiler's
     interprocedural optimizations.  For example, a caller is impacted
     when inlining a function into its caller, cloning a function and
     changing its caller to call this new clone, or extracting a
     function's pureness/constness information to optimize its direct or
     indirect callers, etc.

     Usually, the more IPA optimizations enabled, the larger the number
     of impacted functions for each function.  In order to control the
     number of impacted functions and more easily compute the list of
     impacted function, IPA optimizations can be partially enabled at
     two different levels.

     The LEVEL argument should be one of the following:

     'inline-clone'

          Only enable inlining and cloning optimizations, which includes
          inlining, cloning, interprocedural scalar replacement of
          aggregates and partial inlining.  As a result, when patching a
          function, all its callers and its clones' callers are
          impacted, therefore need to be patched as well.

          '-flive-patching=inline-clone' disables the following
          optimization flags:
               -fwhole-program  -fipa-pta  -fipa-reference  -fipa-ra
               -fipa-icf  -fipa-icf-functions  -fipa-icf-variables
               -fipa-bit-cp  -fipa-vrp  -fipa-pure-const  -fipa-reference-addressable
               -fipa-stack-alignment

     'inline-only-static'

          Only enable inlining of static functions.  As a result, when
          patching a static function, all its callers are impacted and
          so need to be patched as well.

          In addition to all the flags that
          '-flive-patching=inline-clone' disables,
          '-flive-patching=inline-only-static' disables the following
          additional optimization flags:
               -fipa-cp-clone  -fipa-sra  -fpartial-inlining  -fipa-cp

     When '-flive-patching' is specified without any value, the default
     value is INLINE-CLONE.

     This flag is disabled by default.

     Note that '-flive-patching' is not supported with link-time
     optimization ('-flto').

'-fisolate-erroneous-paths-dereference'
     Detect paths that trigger erroneous or undefined behavior due to
     dereferencing a null pointer.  Isolate those paths from the main
     control flow and turn the statement with erroneous or undefined
     behavior into a trap.  This flag is enabled by default at '-O2' and
     higher and depends on '-fdelete-null-pointer-checks' also being
     enabled.

'-fisolate-erroneous-paths-attribute'
     Detect paths that trigger erroneous or undefined behavior due to a
     null value being used in a way forbidden by a 'returns_nonnull' or
     'nonnull' attribute.  Isolate those paths from the main control
     flow and turn the statement with erroneous or undefined behavior
     into a trap.  This is not currently enabled, but may be enabled by
     '-O2' in the future.

'-ftree-sink'
     Perform forward store motion on trees.  This flag is enabled by
     default at '-O' and higher.

'-ftree-bit-ccp'
     Perform sparse conditional bit constant propagation on trees and
     propagate pointer alignment information.  This pass only operates
     on local scalar variables and is enabled by default at '-O1' and
     higher, except for '-Og'.  It requires that '-ftree-ccp' is
     enabled.

'-ftree-ccp'
     Perform sparse conditional constant propagation (CCP) on trees.
     This pass only operates on local scalar variables and is enabled by
     default at '-O' and higher.

'-fssa-backprop'
     Propagate information about uses of a value up the definition chain
     in order to simplify the definitions.  For example, this pass
     strips sign operations if the sign of a value never matters.  The
     flag is enabled by default at '-O' and higher.

'-fssa-phiopt'
     Perform pattern matching on SSA PHI nodes to optimize conditional
     code.  This pass is enabled by default at '-O1' and higher, except
     for '-Og'.

'-ftree-switch-conversion'
     Perform conversion of simple initializations in a switch to
     initializations from a scalar array.  This flag is enabled by
     default at '-O2' and higher.

'-ftree-tail-merge'
     Look for identical code sequences.  When found, replace one with a
     jump to the other.  This optimization is known as tail merging or
     cross jumping.  This flag is enabled by default at '-O2' and
     higher.  The compilation time in this pass can be limited using
     'max-tail-merge-comparisons' parameter and
     'max-tail-merge-iterations' parameter.

'-ftree-dce'
     Perform dead code elimination (DCE) on trees.  This flag is enabled
     by default at '-O' and higher.

'-ftree-builtin-call-dce'
     Perform conditional dead code elimination (DCE) for calls to
     built-in functions that may set 'errno' but are otherwise free of
     side effects.  This flag is enabled by default at '-O2' and higher
     if '-Os' is not also specified.

'-ftree-dominator-opts'
     Perform a variety of simple scalar cleanups (constant/copy
     propagation, redundancy elimination, range propagation and
     expression simplification) based on a dominator tree traversal.
     This also performs jump threading (to reduce jumps to jumps).  This
     flag is enabled by default at '-O' and higher.

'-ftree-dse'
     Perform dead store elimination (DSE) on trees.  A dead store is a
     store into a memory location that is later overwritten by another
     store without any intervening loads.  In this case the earlier
     store can be deleted.  This flag is enabled by default at '-O' and
     higher.

'-ftree-ch'
     Perform loop header copying on trees.  This is beneficial since it
     increases effectiveness of code motion optimizations.  It also
     saves one jump.  This flag is enabled by default at '-O' and
     higher.  It is not enabled for '-Os', since it usually increases
     code size.

'-ftree-loop-optimize'
     Perform loop optimizations on trees.  This flag is enabled by
     default at '-O' and higher.

'-ftree-loop-linear'
'-floop-strip-mine'
'-floop-block'
     Perform loop nest optimizations.  Same as '-floop-nest-optimize'.
     To use this code transformation, GCC has to be configured with
     '--with-isl' to enable the Graphite loop transformation
     infrastructure.

'-fgraphite-identity'
     Enable the identity transformation for graphite.  For every SCoP we
     generate the polyhedral representation and transform it back to
     gimple.  Using '-fgraphite-identity' we can check the costs or
     benefits of the GIMPLE -> GRAPHITE -> GIMPLE transformation.  Some
     minimal optimizations are also performed by the code generator isl,
     like index splitting and dead code elimination in loops.

'-floop-nest-optimize'
     Enable the isl based loop nest optimizer.  This is a generic loop
     nest optimizer based on the Pluto optimization algorithms.  It
     calculates a loop structure optimized for data-locality and
     parallelism.  This option is experimental.

'-floop-parallelize-all'
     Use the Graphite data dependence analysis to identify loops that
     can be parallelized.  Parallelize all the loops that can be
     analyzed to not contain loop carried dependences without checking
     that it is profitable to parallelize the loops.

'-ftree-coalesce-vars'
     While transforming the program out of the SSA representation,
     attempt to reduce copying by coalescing versions of different
     user-defined variables, instead of just compiler temporaries.  This
     may severely limit the ability to debug an optimized program
     compiled with '-fno-var-tracking-assignments'.  In the negated
     form, this flag prevents SSA coalescing of user variables.  This
     option is enabled by default if optimization is enabled, and it
     does very little otherwise.

'-ftree-loop-if-convert'
     Attempt to transform conditional jumps in the innermost loops to
     branch-less equivalents.  The intent is to remove control-flow from
     the innermost loops in order to improve the ability of the
     vectorization pass to handle these loops.  This is enabled by
     default if vectorization is enabled.

'-ftree-loop-distribution'
     Perform loop distribution.  This flag can improve cache performance
     on big loop bodies and allow further loop optimizations, like
     parallelization or vectorization, to take place.  For example, the
     loop
          DO I = 1, N
            A(I) = B(I) + C
            D(I) = E(I) * F
          ENDDO
     is transformed to
          DO I = 1, N
             A(I) = B(I) + C
          ENDDO
          DO I = 1, N
             D(I) = E(I) * F
          ENDDO
     This flag is enabled by default at '-O3'.  It is also enabled by
     '-fprofile-use' and '-fauto-profile'.

'-ftree-loop-distribute-patterns'
     Perform loop distribution of patterns that can be code generated
     with calls to a library.  This flag is enabled by default at '-O3',
     and by '-fprofile-use' and '-fauto-profile'.

     This pass distributes the initialization loops and generates a call
     to memset zero.  For example, the loop
          DO I = 1, N
            A(I) = 0
            B(I) = A(I) + I
          ENDDO
     is transformed to
          DO I = 1, N
             A(I) = 0
          ENDDO
          DO I = 1, N
             B(I) = A(I) + I
          ENDDO
     and the initialization loop is transformed into a call to memset
     zero.  This flag is enabled by default at '-O3'.  It is also
     enabled by '-fprofile-use' and '-fauto-profile'.

'-floop-interchange'
     Perform loop interchange outside of graphite.  This flag can
     improve cache performance on loop nest and allow further loop
     optimizations, like vectorization, to take place.  For example, the
     loop
          for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
              for (int k = 0; k < N; k++)
                c[i][j] = c[i][j] + a[i][k]*b[k][j];
     is transformed to
          for (int i = 0; i < N; i++)
            for (int k = 0; k < N; k++)
              for (int j = 0; j < N; j++)
                c[i][j] = c[i][j] + a[i][k]*b[k][j];
     This flag is enabled by default at '-O3'.  It is also enabled by
     '-fprofile-use' and '-fauto-profile'.

'-floop-unroll-and-jam'
     Apply unroll and jam transformations on feasible loops.  In a loop
     nest this unrolls the outer loop by some factor and fuses the
     resulting multiple inner loops.  This flag is enabled by default at
     '-O3'.  It is also enabled by '-fprofile-use' and '-fauto-profile'.

'-ftree-loop-im'
     Perform loop invariant motion on trees.  This pass moves only
     invariants that are hard to handle at RTL level (function calls,
     operations that expand to nontrivial sequences of insns).  With
     '-funswitch-loops' it also moves operands of conditions that are
     invariant out of the loop, so that we can use just trivial
     invariantness analysis in loop unswitching.  The pass also includes
     store motion.

'-ftree-loop-ivcanon'
     Create a canonical counter for number of iterations in loops for
     which determining number of iterations requires complicated
     analysis.  Later optimizations then may determine the number
     easily.  Useful especially in connection with unrolling.

'-ftree-scev-cprop'
     Perform final value replacement.  If a variable is modified in a
     loop in such a way that its value when exiting the loop can be
     determined using only its initial value and the number of loop
     iterations, replace uses of the final value by such a computation,
     provided it is sufficiently cheap.  This reduces data dependencies
     and may allow further simplifications.  Enabled by default at '-O'
     and higher.

'-fivopts'
     Perform induction variable optimizations (strength reduction,
     induction variable merging and induction variable elimination) on
     trees.

'-ftree-parallelize-loops=n'
     Parallelize loops, i.e., split their iteration space to run in n
     threads.  This is only possible for loops whose iterations are
     independent and can be arbitrarily reordered.  The optimization is
     only profitable on multiprocessor machines, for loops that are
     CPU-intensive, rather than constrained e.g. by memory bandwidth.
     This option implies '-pthread', and thus is only supported on
     targets that have support for '-pthread'.

'-ftree-pta'
     Perform function-local points-to analysis on trees.  This flag is
     enabled by default at '-O1' and higher, except for '-Og'.

'-ftree-sra'
     Perform scalar replacement of aggregates.  This pass replaces
     structure references with scalars to prevent committing structures
     to memory too early.  This flag is enabled by default at '-O1' and
     higher, except for '-Og'.

'-fstore-merging'
     Perform merging of narrow stores to consecutive memory addresses.
     This pass merges contiguous stores of immediate values narrower
     than a word into fewer wider stores to reduce the number of
     instructions.  This is enabled by default at '-O2' and higher as
     well as '-Os'.

'-ftree-ter'
     Perform temporary expression replacement during the SSA->normal
     phase.  Single use/single def temporaries are replaced at their use
     location with their defining expression.  This results in
     non-GIMPLE code, but gives the expanders much more complex trees to
     work on resulting in better RTL generation.  This is enabled by
     default at '-O' and higher.

'-ftree-slsr'
     Perform straight-line strength reduction on trees.  This recognizes
     related expressions involving multiplications and replaces them by
     less expensive calculations when possible.  This is enabled by
     default at '-O' and higher.

'-ftree-vectorize'
     Perform vectorization on trees.  This flag enables
     '-ftree-loop-vectorize' and '-ftree-slp-vectorize' if not
     explicitly specified.

'-ftree-loop-vectorize'
     Perform loop vectorization on trees.  This flag is enabled by
     default at '-O3' and by '-ftree-vectorize', '-fprofile-use', and
     '-fauto-profile'.

'-ftree-slp-vectorize'
     Perform basic block vectorization on trees.  This flag is enabled
     by default at '-O3' and by '-ftree-vectorize', '-fprofile-use', and
     '-fauto-profile'.

'-fvect-cost-model=MODEL'
     Alter the cost model used for vectorization.  The MODEL argument
     should be one of 'unlimited', 'dynamic' or 'cheap'.  With the
     'unlimited' model the vectorized code-path is assumed to be
     profitable while with the 'dynamic' model a runtime check guards
     the vectorized code-path to enable it only for iteration counts
     that will likely execute faster than when executing the original
     scalar loop.  The 'cheap' model disables vectorization of loops
     where doing so would be cost prohibitive for example due to
     required runtime checks for data dependence or alignment but
     otherwise is equal to the 'dynamic' model.  The default cost model
     depends on other optimization flags and is either 'dynamic' or
     'cheap'.

'-fsimd-cost-model=MODEL'
     Alter the cost model used for vectorization of loops marked with
     the OpenMP simd directive.  The MODEL argument should be one of
     'unlimited', 'dynamic', 'cheap'.  All values of MODEL have the same
     meaning as described in '-fvect-cost-model' and by default a cost
     model defined with '-fvect-cost-model' is used.

'-ftree-vrp'
     Perform Value Range Propagation on trees.  This is similar to the
     constant propagation pass, but instead of values, ranges of values
     are propagated.  This allows the optimizers to remove unnecessary
     range checks like array bound checks and null pointer checks.  This
     is enabled by default at '-O2' and higher.  Null pointer check
     elimination is only done if '-fdelete-null-pointer-checks' is
     enabled.

'-fsplit-paths'
     Split paths leading to loop backedges.  This can improve dead code
     elimination and common subexpression elimination.  This is enabled
     by default at '-O3' and above.

'-fsplit-ivs-in-unroller'
     Enables expression of values of induction variables in later
     iterations of the unrolled loop using the value in the first
     iteration.  This breaks long dependency chains, thus improving
     efficiency of the scheduling passes.

     A combination of '-fweb' and CSE is often sufficient to obtain the
     same effect.  However, that is not reliable in cases where the loop
     body is more complicated than a single basic block.  It also does
     not work at all on some architectures due to restrictions in the
     CSE pass.

     This optimization is enabled by default.

'-fvariable-expansion-in-unroller'
     With this option, the compiler creates multiple copies of some
     local variables when unrolling a loop, which can result in superior
     code.

'-fpartial-inlining'
     Inline parts of functions.  This option has any effect only when
     inlining itself is turned on by the '-finline-functions' or
     '-finline-small-functions' options.

     Enabled at levels '-O2', '-O3', '-Os'.

'-fpredictive-commoning'
     Perform predictive commoning optimization, i.e., reusing
     computations (especially memory loads and stores) performed in
     previous iterations of loops.

     This option is enabled at level '-O3'.  It is also enabled by
     '-fprofile-use' and '-fauto-profile'.

'-fprefetch-loop-arrays'
     If supported by the target machine, generate instructions to
     prefetch memory to improve the performance of loops that access
     large arrays.

     This option may generate better or worse code; results are highly
     dependent on the structure of loops within the source code.

     Disabled at level '-Os'.

'-fno-printf-return-value'
     Do not substitute constants for known return value of formatted
     output functions such as 'sprintf', 'snprintf', 'vsprintf', and
     'vsnprintf' (but not 'printf' of 'fprintf').  This transformation
     allows GCC to optimize or even eliminate branches based on the
     known return value of these functions called with arguments that
     are either constant, or whose values are known to be in a range
     that makes determining the exact return value possible.  For
     example, when '-fprintf-return-value' is in effect, both the branch
     and the body of the 'if' statement (but not the call to 'snprint')
     can be optimized away when 'i' is a 32-bit or smaller integer
     because the return value is guaranteed to be at most 8.

          char buf[9];
          if (snprintf (buf, "%08x", i) >= sizeof buf)
            ...

     The '-fprintf-return-value' option relies on other optimizations
     and yields best results with '-O2' and above.  It works in tandem
     with the '-Wformat-overflow' and '-Wformat-truncation' options.
     The '-fprintf-return-value' option is enabled by default.

'-fno-peephole'
'-fno-peephole2'
     Disable any machine-specific peephole optimizations.  The
     difference between '-fno-peephole' and '-fno-peephole2' is in how
     they are implemented in the compiler; some targets use one, some
     use the other, a few use both.

     '-fpeephole' is enabled by default.  '-fpeephole2' enabled at
     levels '-O2', '-O3', '-Os'.

'-fno-guess-branch-probability'
     Do not guess branch probabilities using heuristics.

     GCC uses heuristics to guess branch probabilities if they are not
     provided by profiling feedback ('-fprofile-arcs').  These
     heuristics are based on the control flow graph.  If some branch
     probabilities are specified by '__builtin_expect', then the
     heuristics are used to guess branch probabilities for the rest of
     the control flow graph, taking the '__builtin_expect' info into
     account.  The interactions between the heuristics and
     '__builtin_expect' can be complex, and in some cases, it may be
     useful to disable the heuristics so that the effects of
     '__builtin_expect' are easier to understand.

     It is also possible to specify expected probability of the
     expression with '__builtin_expect_with_probability' built-in
     function.

     The default is '-fguess-branch-probability' at levels '-O', '-O2',
     '-O3', '-Os'.

'-freorder-blocks'
     Reorder basic blocks in the compiled function in order to reduce
     number of taken branches and improve code locality.

     Enabled at levels '-O', '-O2', '-O3', '-Os'.

'-freorder-blocks-algorithm=ALGORITHM'
     Use the specified algorithm for basic block reordering.  The
     ALGORITHM argument can be 'simple', which does not increase code
     size (except sometimes due to secondary effects like alignment), or
     'stc', the "software trace cache" algorithm, which tries to put all
     often executed code together, minimizing the number of branches
     executed by making extra copies of code.

     The default is 'simple' at levels '-O', '-Os', and 'stc' at levels
     '-O2', '-O3'.

'-freorder-blocks-and-partition'
     In addition to reordering basic blocks in the compiled function, in
     order to reduce number of taken branches, partitions hot and cold
     basic blocks into separate sections of the assembly and '.o' files,
     to improve paging and cache locality performance.

     This optimization is automatically turned off in the presence of
     exception handling or unwind tables (on targets using
     setjump/longjump or target specific scheme), for linkonce sections,
     for functions with a user-defined section attribute and on any
     architecture that does not support named sections.  When
     '-fsplit-stack' is used this option is not enabled by default (to
     avoid linker errors), but may be enabled explicitly (if using a
     working linker).

     Enabled for x86 at levels '-O2', '-O3', '-Os'.

'-freorder-functions'
     Reorder functions in the object file in order to improve code
     locality.  This is implemented by using special subsections
     '.text.hot' for most frequently executed functions and
     '.text.unlikely' for unlikely executed functions.  Reordering is
     done by the linker so object file format must support named
     sections and linker must place them in a reasonable way.

     This option isn't effective unless you either provide profile
     feedback (see '-fprofile-arcs' for details) or manually annotate
     functions with 'hot' or 'cold' attributes (*note Common Function
     Attributes::).

     Enabled at levels '-O2', '-O3', '-Os'.

'-fstrict-aliasing'
     Allow the compiler to assume the strictest aliasing rules
     applicable to the language being compiled.  For C (and C++), this
     activates optimizations based on the type of expressions.  In
     particular, an object of one type is assumed never to reside at the
     same address as an object of a different type, unless the types are
     almost the same.  For example, an 'unsigned int' can alias an
     'int', but not a 'void*' or a 'double'.  A character type may alias
     any other type.

     Pay special attention to code like this:
          union a_union {
            int i;
            double d;
          };

          int f() {
            union a_union t;
            t.d = 3.0;
            return t.i;
          }
     The practice of reading from a different union member than the one
     most recently written to (called "type-punning") is common.  Even
     with '-fstrict-aliasing', type-punning is allowed, provided the
     memory is accessed through the union type.  So, the code above
     works as expected.  *Note Structures unions enumerations and
     bit-fields implementation::.  However, this code might not:
          int f() {
            union a_union t;
            int* ip;
            t.d = 3.0;
            ip = &t.i;
            return *ip;
          }

     Similarly, access by taking the address, casting the resulting
     pointer and dereferencing the result has undefined behavior, even
     if the cast uses a union type, e.g.:
          int f() {
            double d = 3.0;
            return ((union a_union *) &d)->i;
          }

     The '-fstrict-aliasing' option is enabled at levels '-O2', '-O3',
     '-Os'.

'-falign-functions'
'-falign-functions=N'
'-falign-functions=N:M'
'-falign-functions=N:M:N2'
'-falign-functions=N:M:N2:M2'
     Align the start of functions to the next power-of-two greater than
     N, skipping up to M-1 bytes.  This ensures that at least the first
     M bytes of the function can be fetched by the CPU without crossing
     an N-byte alignment boundary.

     If M is not specified, it defaults to N.

     Examples: '-falign-functions=32' aligns functions to the next
     32-byte boundary, '-falign-functions=24' aligns to the next 32-byte
     boundary only if this can be done by skipping 23 bytes or less,
     '-falign-functions=32:7' aligns to the next 32-byte boundary only
     if this can be done by skipping 6 bytes or less.

     The second pair of N2:M2 values allows you to specify a secondary
     alignment: '-falign-functions=64:7:32:3' aligns to the next 64-byte
     boundary if this can be done by skipping 6 bytes or less, otherwise
     aligns to the next 32-byte boundary if this can be done by skipping
     2 bytes or less.  If M2 is not specified, it defaults to N2.

     Some assemblers only support this flag when N is a power of two; in
     that case, it is rounded up.

     '-fno-align-functions' and '-falign-functions=1' are equivalent and
     mean that functions are not aligned.

     If N is not specified or is zero, use a machine-dependent default.
     The maximum allowed N option value is 65536.

     Enabled at levels '-O2', '-O3'.

'-flimit-function-alignment'
     If this option is enabled, the compiler tries to avoid
     unnecessarily overaligning functions.  It attempts to instruct the
     assembler to align by the amount specified by '-falign-functions',
     but not to skip more bytes than the size of the function.

'-falign-labels'
'-falign-labels=N'
'-falign-labels=N:M'
'-falign-labels=N:M:N2'
'-falign-labels=N:M:N2:M2'
     Align all branch targets to a power-of-two boundary.

     Parameters of this option are analogous to the '-falign-functions'
     option.  '-fno-align-labels' and '-falign-labels=1' are equivalent
     and mean that labels are not aligned.

     If '-falign-loops' or '-falign-jumps' are applicable and are
     greater than this value, then their values are used instead.

     If N is not specified or is zero, use a machine-dependent default
     which is very likely to be '1', meaning no alignment.  The maximum
     allowed N option value is 65536.

     Enabled at levels '-O2', '-O3'.

'-falign-loops'
'-falign-loops=N'
'-falign-loops=N:M'
'-falign-loops=N:M:N2'
'-falign-loops=N:M:N2:M2'
     Align loops to a power-of-two boundary.  If the loops are executed
     many times, this makes up for any execution of the dummy padding
     instructions.

     Parameters of this option are analogous to the '-falign-functions'
     option.  '-fno-align-loops' and '-falign-loops=1' are equivalent
     and mean that loops are not aligned.  The maximum allowed N option
     value is 65536.

     If N is not specified or is zero, use a machine-dependent default.

     Enabled at levels '-O2', '-O3'.

'-falign-jumps'
'-falign-jumps=N'
'-falign-jumps=N:M'
'-falign-jumps=N:M:N2'
'-falign-jumps=N:M:N2:M2'
     Align branch targets to a power-of-two boundary, for branch targets
     where the targets can only be reached by jumping.  In this case, no
     dummy operations need be executed.

     Parameters of this option are analogous to the '-falign-functions'
     option.  '-fno-align-jumps' and '-falign-jumps=1' are equivalent
     and mean that loops are not aligned.

     If N is not specified or is zero, use a machine-dependent default.
     The maximum allowed N option value is 65536.

     Enabled at levels '-O2', '-O3'.

'-funit-at-a-time'
     This option is left for compatibility reasons.  '-funit-at-a-time'
     has no effect, while '-fno-unit-at-a-time' implies
     '-fno-toplevel-reorder' and '-fno-section-anchors'.

     Enabled by default.

'-fno-toplevel-reorder'
     Do not reorder top-level functions, variables, and 'asm'
     statements.  Output them in the same order that they appear in the
     input file.  When this option is used, unreferenced static
     variables are not removed.  This option is intended to support
     existing code that relies on a particular ordering.  For new code,
     it is better to use attributes when possible.

     '-ftoplevel-reorder' is the default at '-O1' and higher, and also
     at '-O0' if '-fsection-anchors' is explicitly requested.
     Additionally '-fno-toplevel-reorder' implies
     '-fno-section-anchors'.

'-fweb'
     Constructs webs as commonly used for register allocation purposes
     and assign each web individual pseudo register.  This allows the
     register allocation pass to operate on pseudos directly, but also
     strengthens several other optimization passes, such as CSE, loop
     optimizer and trivial dead code remover.  It can, however, make
     debugging impossible, since variables no longer stay in a "home
     register".

     Enabled by default with '-funroll-loops'.

'-fwhole-program'
     Assume that the current compilation unit represents the whole
     program being compiled.  All public functions and variables with
     the exception of 'main' and those merged by attribute
     'externally_visible' become static functions and in effect are
     optimized more aggressively by interprocedural optimizers.

     This option should not be used in combination with '-flto'.
     Instead relying on a linker plugin should provide safer and more
     precise information.

'-flto[=N]'
     This option runs the standard link-time optimizer.  When invoked
     with source code, it generates GIMPLE (one of GCC's internal
     representations) and writes it to special ELF sections in the
     object file.  When the object files are linked together, all the
     function bodies are read from these ELF sections and instantiated
     as if they had been part of the same translation unit.

     To use the link-time optimizer, '-flto' and optimization options
     should be specified at compile time and during the final link.  It
     is recommended that you compile all the files participating in the
     same link with the same options and also specify those options at
     link time.  For example:

          gcc -c -O2 -flto foo.c
          gcc -c -O2 -flto bar.c
          gcc -o myprog -flto -O2 foo.o bar.o

     The first two invocations to GCC save a bytecode representation of
     GIMPLE into special ELF sections inside 'foo.o' and 'bar.o'.  The
     final invocation reads the GIMPLE bytecode from 'foo.o' and
     'bar.o', merges the two files into a single internal image, and
     compiles the result as usual.  Since both 'foo.o' and 'bar.o' are
     merged into a single image, this causes all the interprocedural
     analyses and optimizations in GCC to work across the two files as
     if they were a single one.  This means, for example, that the
     inliner is able to inline functions in 'bar.o' into functions in
     'foo.o' and vice-versa.

     Another (simpler) way to enable link-time optimization is:

          gcc -o myprog -flto -O2 foo.c bar.c

     The above generates bytecode for 'foo.c' and 'bar.c', merges them
     together into a single GIMPLE representation and optimizes them as
     usual to produce 'myprog'.

     The important thing to keep in mind is that to enable link-time
     optimizations you need to use the GCC driver to perform the link
     step.  GCC automatically performs link-time optimization if any of
     the objects involved were compiled with the '-flto' command-line
     option.  You can always override the automatic decision to do
     link-time optimization by passing '-fno-lto' to the link command.

     To make whole program optimization effective, it is necessary to
     make certain whole program assumptions.  The compiler needs to know
     what functions and variables can be accessed by libraries and
     runtime outside of the link-time optimized unit.  When supported by
     the linker, the linker plugin (see '-fuse-linker-plugin') passes
     information to the compiler about used and externally visible
     symbols.  When the linker plugin is not available,
     '-fwhole-program' should be used to allow the compiler to make
     these assumptions, which leads to more aggressive optimization
     decisions.

     When a file is compiled with '-flto' without '-fuse-linker-plugin',
     the generated object file is larger than a regular object file
     because it contains GIMPLE bytecodes and the usual final code (see
     '-ffat-lto-objects'.  This means that object files with LTO
     information can be linked as normal object files; if '-fno-lto' is
     passed to the linker, no interprocedural optimizations are applied.
     Note that when '-fno-fat-lto-objects' is enabled the compile stage
     is faster but you cannot perform a regular, non-LTO link on them.

     When producing the final binary, GCC only applies link-time
     optimizations to those files that contain bytecode.  Therefore, you
     can mix and match object files and libraries with GIMPLE bytecodes
     and final object code.  GCC automatically selects which files to
     optimize in LTO mode and which files to link without further
     processing.

     Generally, options specified at link time override those specified
     at compile time, although in some cases GCC attempts to infer
     link-time options from the settings used to compile the input
     files.

     If you do not specify an optimization level option '-O' at link
     time, then GCC uses the highest optimization level used when
     compiling the object files.  Note that it is generally ineffective
     to specify an optimization level option only at link time and not
     at compile time, for two reasons.  First, compiling without
     optimization suppresses compiler passes that gather information
     needed for effective optimization at link time.  Second, some early
     optimization passes can be performed only at compile time and not
     at link time.

     There are some code generation flags preserved by GCC when
     generating bytecodes, as they need to be used during the final
     link.  Currently, the following options and their settings are
     taken from the first object file that explicitly specifies them:
     '-fPIC', '-fpic', '-fpie', '-fcommon', '-fexceptions',
     '-fnon-call-exceptions', '-fgnu-tm' and all the '-m' target flags.

     Certain ABI-changing flags are required to match in all compilation
     units, and trying to override this at link time with a conflicting
     value is ignored.  This includes options such as
     '-freg-struct-return' and '-fpcc-struct-return'.

     Other options such as '-ffp-contract', '-fno-strict-overflow',
     '-fwrapv', '-fno-trapv' or '-fno-strict-aliasing' are passed
     through to the link stage and merged conservatively for conflicting
     translation units.  Specifically '-fno-strict-overflow', '-fwrapv'
     and '-fno-trapv' take precedence; and for example
     '-ffp-contract=off' takes precedence over '-ffp-contract=fast'.
     You can override them at link time.

     If LTO encounters objects with C linkage declared with incompatible
     types in separate translation units to be linked together
     (undefined behavior according to ISO C99 6.2.7), a non-fatal
     diagnostic may be issued.  The behavior is still undefined at run
     time.  Similar diagnostics may be raised for other languages.

     Another feature of LTO is that it is possible to apply
     interprocedural optimizations on files written in different
     languages:

          gcc -c -flto foo.c
          g++ -c -flto bar.cc
          gfortran -c -flto baz.f90
          g++ -o myprog -flto -O3 foo.o bar.o baz.o -lgfortran

     Notice that the final link is done with 'g++' to get the C++
     runtime libraries and '-lgfortran' is added to get the Fortran
     runtime libraries.  In general, when mixing languages in LTO mode,
     you should use the same link command options as when mixing
     languages in a regular (non-LTO) compilation.

     If object files containing GIMPLE bytecode are stored in a library
     archive, say 'libfoo.a', it is possible to extract and use them in
     an LTO link if you are using a linker with plugin support.  To
     create static libraries suitable for LTO, use 'gcc-ar' and
     'gcc-ranlib' instead of 'ar' and 'ranlib'; to show the symbols of
     object files with GIMPLE bytecode, use 'gcc-nm'.  Those commands
     require that 'ar', 'ranlib' and 'nm' have been compiled with plugin
     support.  At link time, use the flag '-fuse-linker-plugin' to
     ensure that the library participates in the LTO optimization
     process:

          gcc -o myprog -O2 -flto -fuse-linker-plugin a.o b.o -lfoo

     With the linker plugin enabled, the linker extracts the needed
     GIMPLE files from 'libfoo.a' and passes them on to the running GCC
     to make them part of the aggregated GIMPLE image to be optimized.

     If you are not using a linker with plugin support and/or do not
     enable the linker plugin, then the objects inside 'libfoo.a' are
     extracted and linked as usual, but they do not participate in the
     LTO optimization process.  In order to make a static library
     suitable for both LTO optimization and usual linkage, compile its
     object files with '-flto' '-ffat-lto-objects'.

     Link-time optimizations do not require the presence of the whole
     program to operate.  If the program does not require any symbols to
     be exported, it is possible to combine '-flto' and
     '-fwhole-program' to allow the interprocedural optimizers to use
     more aggressive assumptions which may lead to improved optimization
     opportunities.  Use of '-fwhole-program' is not needed when linker
     plugin is active (see '-fuse-linker-plugin').

     The current implementation of LTO makes no attempt to generate
     bytecode that is portable between different types of hosts.  The
     bytecode files are versioned and there is a strict version check,
     so bytecode files generated in one version of GCC do not work with
     an older or newer version of GCC.

     Link-time optimization does not work well with generation of
     debugging information on systems other than those using a
     combination of ELF and DWARF.

     If you specify the optional N, the optimization and code generation
     done at link time is executed in parallel using N parallel jobs by
     utilizing an installed 'make' program.  The environment variable
     'MAKE' may be used to override the program used.  The default value
     for N is 1.

     You can also specify '-flto=jobserver' to use GNU make's job server
     mode to determine the number of parallel jobs.  This is useful when
     the Makefile calling GCC is already executing in parallel.  You
     must prepend a '+' to the command recipe in the parent Makefile for
     this to work.  This option likely only works if 'MAKE' is GNU make.

'-flto-partition=ALG'
     Specify the partitioning algorithm used by the link-time optimizer.
     The value is either '1to1' to specify a partitioning mirroring the
     original source files or 'balanced' to specify partitioning into
     equally sized chunks (whenever possible) or 'max' to create new
     partition for every symbol where possible.  Specifying 'none' as an
     algorithm disables partitioning and streaming completely.  The
     default value is 'balanced'.  While '1to1' can be used as an
     workaround for various code ordering issues, the 'max' partitioning
     is intended for internal testing only.  The value 'one' specifies
     that exactly one partition should be used while the value 'none'
     bypasses partitioning and executes the link-time optimization step
     directly from the WPA phase.

'-flto-odr-type-merging'
     Enable streaming of mangled types names of C++ types and their
     unification at link time.  This increases size of LTO object files,
     but enables diagnostics about One Definition Rule violations.

'-flto-compression-level=N'
     This option specifies the level of compression used for
     intermediate language written to LTO object files, and is only
     meaningful in conjunction with LTO mode ('-flto').  Valid values
     are 0 (no compression) to 9 (maximum compression).  Values outside
     this range are clamped to either 0 or 9.  If the option is not
     given, a default balanced compression setting is used.

'-fuse-linker-plugin'
     Enables the use of a linker plugin during link-time optimization.
     This option relies on plugin support in the linker, which is
     available in gold or in GNU ld 2.21 or newer.

     This option enables the extraction of object files with GIMPLE
     bytecode out of library archives.  This improves the quality of
     optimization by exposing more code to the link-time optimizer.
     This information specifies what symbols can be accessed externally
     (by non-LTO object or during dynamic linking).  Resulting code
     quality improvements on binaries (and shared libraries that use
     hidden visibility) are similar to '-fwhole-program'.  See '-flto'
     for a description of the effect of this flag and how to use it.

     This option is enabled by default when LTO support in GCC is
     enabled and GCC was configured for use with a linker supporting
     plugins (GNU ld 2.21 or newer or gold).

'-ffat-lto-objects'
     Fat LTO objects are object files that contain both the intermediate
     language and the object code.  This makes them usable for both LTO
     linking and normal linking.  This option is effective only when
     compiling with '-flto' and is ignored at link time.

     '-fno-fat-lto-objects' improves compilation time over plain LTO,
     but requires the complete toolchain to be aware of LTO. It requires
     a linker with linker plugin support for basic functionality.
     Additionally, 'nm', 'ar' and 'ranlib' need to support linker
     plugins to allow a full-featured build environment (capable of
     building static libraries etc).  GCC provides the 'gcc-ar',
     'gcc-nm', 'gcc-ranlib' wrappers to pass the right options to these
     tools.  With non fat LTO makefiles need to be modified to use them.

     Note that modern binutils provide plugin auto-load mechanism.
     Installing the linker plugin into '$libdir/bfd-plugins' has the
     same effect as usage of the command wrappers ('gcc-ar', 'gcc-nm'
     and 'gcc-ranlib').

     The default is '-fno-fat-lto-objects' on targets with linker plugin
     support.

'-fcompare-elim'
     After register allocation and post-register allocation instruction
     splitting, identify arithmetic instructions that compute processor
     flags similar to a comparison operation based on that arithmetic.
     If possible, eliminate the explicit comparison operation.

     This pass only applies to certain targets that cannot explicitly
     represent the comparison operation before register allocation is
     complete.

     Enabled at levels '-O', '-O2', '-O3', '-Os'.

'-fcprop-registers'
     After register allocation and post-register allocation instruction
     splitting, perform a copy-propagation pass to try to reduce
     scheduling dependencies and occasionally eliminate the copy.

     Enabled at levels '-O', '-O2', '-O3', '-Os'.

'-fprofile-correction'
     Profiles collected using an instrumented binary for multi-threaded
     programs may be inconsistent due to missed counter updates.  When
     this option is specified, GCC uses heuristics to correct or smooth
     out such inconsistencies.  By default, GCC emits an error message
     when an inconsistent profile is detected.

     This option is enabled by '-fauto-profile'.

'-fprofile-use'
'-fprofile-use=PATH'
     Enable profile feedback-directed optimizations, and the following
     optimizations, many of which are generally profitable only with
     profile feedback available:

          -fbranch-probabilities  -fprofile-values
          -funroll-loops  -fpeel-loops  -ftracer  -fvpt
          -finline-functions  -fipa-cp  -fipa-cp-clone  -fipa-bit-cp
          -fpredictive-commoning  -fsplit-loops  -funswitch-loops
          -fgcse-after-reload  -ftree-loop-vectorize  -ftree-slp-vectorize
          -fvect-cost-model=dynamic  -ftree-loop-distribute-patterns
          -fprofile-reorder-functions

     Before you can use this option, you must first generate profiling
     information.  *Note Instrumentation Options::, for information
     about the '-fprofile-generate' option.

     By default, GCC emits an error message if the feedback profiles do
     not match the source code.  This error can be turned into a warning
     by using '-Wno-error=coverage-mismatch'.  Note this may result in
     poorly optimized code.  Additionally, by default, GCC also emits a
     warning message if the feedback profiles do not exist (see
     '-Wmissing-profile').

     If PATH is specified, GCC looks at the PATH to find the profile
     feedback data files.  See '-fprofile-dir'.

'-fauto-profile'
'-fauto-profile=PATH'
     Enable sampling-based feedback-directed optimizations, and the
     following optimizations, many of which are generally profitable
     only with profile feedback available:

          -fbranch-probabilities  -fprofile-values
          -funroll-loops  -fpeel-loops  -ftracer  -fvpt
          -finline-functions  -fipa-cp  -fipa-cp-clone  -fipa-bit-cp
          -fpredictive-commoning  -fsplit-loops  -funswitch-loops
          -fgcse-after-reload  -ftree-loop-vectorize  -ftree-slp-vectorize
          -fvect-cost-model=dynamic  -ftree-loop-distribute-patterns
          -fprofile-correction

     PATH is the name of a file containing AutoFDO profile information.
     If omitted, it defaults to 'fbdata.afdo' in the current directory.

     Producing an AutoFDO profile data file requires running your
     program with the 'perf' utility on a supported GNU/Linux target
     system.  For more information, see <https://perf.wiki.kernel.org/>.

     E.g.
          perf record -e br_inst_retired:near_taken -b -o perf.data \
              -- your_program

     Then use the 'create_gcov' tool to convert the raw profile data to
     a format that can be used by GCC.  You must also supply the
     unstripped binary for your program to this tool.  See
     <https://github.com/google/autofdo>.

     E.g.
          create_gcov --binary=your_program.unstripped --profile=perf.data \
              --gcov=profile.afdo

 The following options control compiler behavior regarding
floating-point arithmetic.  These options trade off between speed and
correctness.  All must be specifically enabled.

'-ffloat-store'
     Do not store floating-point variables in registers, and inhibit
     other options that might change whether a floating-point value is
     taken from a register or memory.

     This option prevents undesirable excess precision on machines such
     as the 68000 where the floating registers (of the 68881) keep more
     precision than a 'double' is supposed to have.  Similarly for the
     x86 architecture.  For most programs, the excess precision does
     only good, but a few programs rely on the precise definition of
     IEEE floating point.  Use '-ffloat-store' for such programs, after
     modifying them to store all pertinent intermediate computations
     into variables.

'-fexcess-precision=STYLE'
     This option allows further control over excess precision on
     machines where floating-point operations occur in a format with
     more precision or range than the IEEE standard and interchange
     floating-point types.  By default, '-fexcess-precision=fast' is in
     effect; this means that operations may be carried out in a wider
     precision than the types specified in the source if that would
     result in faster code, and it is unpredictable when rounding to the
     types specified in the source code takes place.  When compiling C,
     if '-fexcess-precision=standard' is specified then excess precision
     follows the rules specified in ISO C99; in particular, both casts
     and assignments cause values to be rounded to their semantic types
     (whereas '-ffloat-store' only affects assignments).  This option is
     enabled by default for C if a strict conformance option such as
     '-std=c99' is used.  '-ffast-math' enables
     '-fexcess-precision=fast' by default regardless of whether a strict
     conformance option is used.

     '-fexcess-precision=standard' is not implemented for languages
     other than C. On the x86, it has no effect if '-mfpmath=sse' or
     '-mfpmath=sse+387' is specified; in the former case, IEEE semantics
     apply without excess precision, and in the latter, rounding is
     unpredictable.

'-ffast-math'
     Sets the options '-fno-math-errno', '-funsafe-math-optimizations',
     '-ffinite-math-only', '-fno-rounding-math', '-fno-signaling-nans',
     '-fcx-limited-range' and '-fexcess-precision=fast'.

     This option causes the preprocessor macro '__FAST_MATH__' to be
     defined.

     This option is not turned on by any '-O' option besides '-Ofast'
     since it can result in incorrect output for programs that depend on
     an exact implementation of IEEE or ISO rules/specifications for
     math functions.  It may, however, yield faster code for programs
     that do not require the guarantees of these specifications.

'-fno-math-errno'
     Do not set 'errno' after calling math functions that are executed
     with a single instruction, e.g., 'sqrt'.  A program that relies on
     IEEE exceptions for math error handling may want to use this flag
     for speed while maintaining IEEE arithmetic compatibility.

     This option is not turned on by any '-O' option since it can result
     in incorrect output for programs that depend on an exact
     implementation of IEEE or ISO rules/specifications for math
     functions.  It may, however, yield faster code for programs that do
     not require the guarantees of these specifications.

     The default is '-fmath-errno'.

     On Darwin systems, the math library never sets 'errno'.  There is
     therefore no reason for the compiler to consider the possibility
     that it might, and '-fno-math-errno' is the default.

'-funsafe-math-optimizations'

     Allow optimizations for floating-point arithmetic that (a) assume
     that arguments and results are valid and (b) may violate IEEE or
     ANSI standards.  When used at link time, it may include libraries
     or startup files that change the default FPU control word or other
     similar optimizations.

     This option is not turned on by any '-O' option since it can result
     in incorrect output for programs that depend on an exact
     implementation of IEEE or ISO rules/specifications for math
     functions.  It may, however, yield faster code for programs that do
     not require the guarantees of these specifications.  Enables
     '-fno-signed-zeros', '-fno-trapping-math', '-fassociative-math' and
     '-freciprocal-math'.

     The default is '-fno-unsafe-math-optimizations'.

'-fassociative-math'

     Allow re-association of operands in series of floating-point
     operations.  This violates the ISO C and C++ language standard by
     possibly changing computation result.  NOTE: re-ordering may change
     the sign of zero as well as ignore NaNs and inhibit or create
     underflow or overflow (and thus cannot be used on code that relies
     on rounding behavior like '(x + 2**52) - 2**52'.  May also reorder
     floating-point comparisons and thus may not be used when ordered
     comparisons are required.  This option requires that both
     '-fno-signed-zeros' and '-fno-trapping-math' be in effect.
     Moreover, it doesn't make much sense with '-frounding-math'.  For
     Fortran the option is automatically enabled when both
     '-fno-signed-zeros' and '-fno-trapping-math' are in effect.

     The default is '-fno-associative-math'.

'-freciprocal-math'

     Allow the reciprocal of a value to be used instead of dividing by
     the value if this enables optimizations.  For example 'x / y' can
     be replaced with 'x * (1/y)', which is useful if '(1/y)' is subject
     to common subexpression elimination.  Note that this loses
     precision and increases the number of flops operating on the value.

     The default is '-fno-reciprocal-math'.

'-ffinite-math-only'
     Allow optimizations for floating-point arithmetic that assume that
     arguments and results are not NaNs or +-Infs.

     This option is not turned on by any '-O' option since it can result
     in incorrect output for programs that depend on an exact
     implementation of IEEE or ISO rules/specifications for math
     functions.  It may, however, yield faster code for programs that do
     not require the guarantees of these specifications.

     The default is '-fno-finite-math-only'.

'-fno-signed-zeros'
     Allow optimizations for floating-point arithmetic that ignore the
     signedness of zero.  IEEE arithmetic specifies the behavior of
     distinct +0.0 and -0.0 values, which then prohibits simplification
     of expressions such as x+0.0 or 0.0*x (even with
     '-ffinite-math-only').  This option implies that the sign of a zero
     result isn't significant.

     The default is '-fsigned-zeros'.

'-fno-trapping-math'
     Compile code assuming that floating-point operations cannot
     generate user-visible traps.  These traps include division by zero,
     overflow, underflow, inexact result and invalid operation.  This
     option requires that '-fno-signaling-nans' be in effect.  Setting
     this option may allow faster code if one relies on "non-stop" IEEE
     arithmetic, for example.

     This option should never be turned on by any '-O' option since it
     can result in incorrect output for programs that depend on an exact
     implementation of IEEE or ISO rules/specifications for math
     functions.

     The default is '-ftrapping-math'.

'-frounding-math'
     Disable transformations and optimizations that assume default
     floating-point rounding behavior.  This is round-to-zero for all
     floating point to integer conversions, and round-to-nearest for all
     other arithmetic truncations.  This option should be specified for
     programs that change the FP rounding mode dynamically, or that may
     be executed with a non-default rounding mode.  This option disables
     constant folding of floating-point expressions at compile time
     (which may be affected by rounding mode) and arithmetic
     transformations that are unsafe in the presence of sign-dependent
     rounding modes.

     The default is '-fno-rounding-math'.

     This option is experimental and does not currently guarantee to
     disable all GCC optimizations that are affected by rounding mode.
     Future versions of GCC may provide finer control of this setting
     using C99's 'FENV_ACCESS' pragma.  This command-line option will be
     used to specify the default state for 'FENV_ACCESS'.

'-fsignaling-nans'
     Compile code assuming that IEEE signaling NaNs may generate
     user-visible traps during floating-point operations.  Setting this
     option disables optimizations that may change the number of
     exceptions visible with signaling NaNs.  This option implies
     '-ftrapping-math'.

     This option causes the preprocessor macro '__SUPPORT_SNAN__' to be
     defined.

     The default is '-fno-signaling-nans'.

     This option is experimental and does not currently guarantee to
     disable all GCC optimizations that affect signaling NaN behavior.

'-fno-fp-int-builtin-inexact'
     Do not allow the built-in functions 'ceil', 'floor', 'round' and
     'trunc', and their 'float' and 'long double' variants, to generate
     code that raises the "inexact" floating-point exception for
     noninteger arguments.  ISO C99 and C11 allow these functions to
     raise the "inexact" exception, but ISO/IEC TS 18661-1:2014, the C
     bindings to IEEE 754-2008, does not allow these functions to do so.

     The default is '-ffp-int-builtin-inexact', allowing the exception
     to be raised.  This option does nothing unless '-ftrapping-math' is
     in effect.

     Even if '-fno-fp-int-builtin-inexact' is used, if the functions
     generate a call to a library function then the "inexact" exception
     may be raised if the library implementation does not follow TS
     18661.

'-fsingle-precision-constant'
     Treat floating-point constants as single precision instead of
     implicitly converting them to double-precision constants.

'-fcx-limited-range'
     When enabled, this option states that a range reduction step is not
     needed when performing complex division.  Also, there is no
     checking whether the result of a complex multiplication or division
     is 'NaN + I*NaN', with an attempt to rescue the situation in that
     case.  The default is '-fno-cx-limited-range', but is enabled by
     '-ffast-math'.

     This option controls the default setting of the ISO C99
     'CX_LIMITED_RANGE' pragma.  Nevertheless, the option applies to all
     languages.

'-fcx-fortran-rules'
     Complex multiplication and division follow Fortran rules.  Range
     reduction is done as part of complex division, but there is no
     checking whether the result of a complex multiplication or division
     is 'NaN + I*NaN', with an attempt to rescue the situation in that
     case.

     The default is '-fno-cx-fortran-rules'.

 The following options control optimizations that may improve
performance, but are not enabled by any '-O' options.  This section
includes experimental options that may produce broken code.

'-fbranch-probabilities'
     After running a program compiled with '-fprofile-arcs' (*note
     Instrumentation Options::), you can compile it a second time using
     '-fbranch-probabilities', to improve optimizations based on the
     number of times each branch was taken.  When a program compiled
     with '-fprofile-arcs' exits, it saves arc execution counts to a
     file called 'SOURCENAME.gcda' for each source file.  The
     information in this data file is very dependent on the structure of
     the generated code, so you must use the same source code and the
     same optimization options for both compilations.

     With '-fbranch-probabilities', GCC puts a 'REG_BR_PROB' note on
     each 'JUMP_INSN' and 'CALL_INSN'.  These can be used to improve
     optimization.  Currently, they are only used in one place: in
     'reorg.c', instead of guessing which path a branch is most likely
     to take, the 'REG_BR_PROB' values are used to exactly determine
     which path is taken more often.

     Enabled by '-fprofile-use' and '-fauto-profile'.

'-fprofile-values'
     If combined with '-fprofile-arcs', it adds code so that some data
     about values of expressions in the program is gathered.

     With '-fbranch-probabilities', it reads back the data gathered from
     profiling values of expressions for usage in optimizations.

     Enabled by '-fprofile-generate', '-fprofile-use', and
     '-fauto-profile'.

'-fprofile-reorder-functions'
     Function reordering based on profile instrumentation collects first
     time of execution of a function and orders these functions in
     ascending order.

     Enabled with '-fprofile-use'.

'-fvpt'
     If combined with '-fprofile-arcs', this option instructs the
     compiler to add code to gather information about values of
     expressions.

     With '-fbranch-probabilities', it reads back the data gathered and
     actually performs the optimizations based on them.  Currently the
     optimizations include specialization of division operations using
     the knowledge about the value of the denominator.

     Enabled with '-fprofile-use' and '-fauto-profile'.

'-frename-registers'
     Attempt to avoid false dependencies in scheduled code by making use
     of registers left over after register allocation.  This
     optimization most benefits processors with lots of registers.
     Depending on the debug information format adopted by the target,
     however, it can make debugging impossible, since variables no
     longer stay in a "home register".

     Enabled by default with '-funroll-loops'.

'-fschedule-fusion'
     Performs a target dependent pass over the instruction stream to
     schedule instructions of same type together because target machine
     can execute them more efficiently if they are adjacent to each
     other in the instruction flow.

     Enabled at levels '-O2', '-O3', '-Os'.

'-ftracer'
     Perform tail duplication to enlarge superblock size.  This
     transformation simplifies the control flow of the function allowing
     other optimizations to do a better job.

     Enabled by '-fprofile-use' and '-fauto-profile'.

'-funroll-loops'
     Unroll loops whose number of iterations can be determined at
     compile time or upon entry to the loop.  '-funroll-loops' implies
     '-frerun-cse-after-loop', '-fweb' and '-frename-registers'.  It
     also turns on complete loop peeling (i.e. complete removal of loops
     with a small constant number of iterations).  This option makes
     code larger, and may or may not make it run faster.

     Enabled by '-fprofile-use' and '-fauto-profile'.

'-funroll-all-loops'
     Unroll all loops, even if their number of iterations is uncertain
     when the loop is entered.  This usually makes programs run more
     slowly.  '-funroll-all-loops' implies the same options as
     '-funroll-loops'.

'-fpeel-loops'
     Peels loops for which there is enough information that they do not
     roll much (from profile feedback or static analysis).  It also
     turns on complete loop peeling (i.e. complete removal of loops with
     small constant number of iterations).

     Enabled by '-O3', '-fprofile-use', and '-fauto-profile'.

'-fmove-loop-invariants'
     Enables the loop invariant motion pass in the RTL loop optimizer.
     Enabled at level '-O1' and higher, except for '-Og'.

'-fsplit-loops'
     Split a loop into two if it contains a condition that's always true
     for one side of the iteration space and false for the other.

     Enabled by '-fprofile-use' and '-fauto-profile'.

'-funswitch-loops'
     Move branches with loop invariant conditions out of the loop, with
     duplicates of the loop on both branches (modified according to
     result of the condition).

     Enabled by '-fprofile-use' and '-fauto-profile'.

'-fversion-loops-for-strides'
     If a loop iterates over an array with a variable stride, create
     another version of the loop that assumes the stride is always one.
     For example:

          for (int i = 0; i < n; ++i)
            x[i * stride] = ...;

     becomes:

          if (stride == 1)
            for (int i = 0; i < n; ++i)
              x[i] = ...;
          else
            for (int i = 0; i < n; ++i)
              x[i * stride] = ...;

     This is particularly useful for assumed-shape arrays in Fortran
     where (for example) it allows better vectorization assuming
     contiguous accesses.  This flag is enabled by default at '-O3'.  It
     is also enabled by '-fprofile-use' and '-fauto-profile'.

'-ffunction-sections'
'-fdata-sections'
     Place each function or data item into its own section in the output
     file if the target supports arbitrary sections.  The name of the
     function or the name of the data item determines the section's name
     in the output file.

     Use these options on systems where the linker can perform
     optimizations to improve locality of reference in the instruction
     space.  Most systems using the ELF object format have linkers with
     such optimizations.  On AIX, the linker rearranges sections
     (CSECTs) based on the call graph.  The performance impact varies.

     Together with a linker garbage collection (linker '--gc-sections'
     option) these options may lead to smaller statically-linked
     executables (after stripping).

     On ELF/DWARF systems these options do not degenerate the quality of
     the debug information.  There could be issues with other object
     files/debug info formats.

     Only use these options when there are significant benefits from
     doing so.  When you specify these options, the assembler and linker
     create larger object and executable files and are also slower.
     These options affect code generation.  They prevent optimizations
     by the compiler and assembler using relative locations inside a
     translation unit since the locations are unknown until link time.
     An example of such an optimization is relaxing calls to short call
     instructions.

'-fbranch-target-load-optimize'
     Perform branch target register load optimization before prologue /
     epilogue threading.  The use of target registers can typically be
     exposed only during reload, thus hoisting loads out of loops and
     doing inter-block scheduling needs a separate optimization pass.

'-fbranch-target-load-optimize2'
     Perform branch target register load optimization after prologue /
     epilogue threading.

'-fbtr-bb-exclusive'
     When performing branch target register load optimization, don't
     reuse branch target registers within any basic block.

'-fstdarg-opt'
     Optimize the prologue of variadic argument functions with respect
     to usage of those arguments.

'-fsection-anchors'
     Try to reduce the number of symbolic address calculations by using
     shared "anchor" symbols to address nearby objects.  This
     transformation can help to reduce the number of GOT entries and GOT
     accesses on some targets.

     For example, the implementation of the following function 'foo':

          static int a, b, c;
          int foo (void) { return a + b + c; }

     usually calculates the addresses of all three variables, but if you
     compile it with '-fsection-anchors', it accesses the variables from
     a common anchor point instead.  The effect is similar to the
     following pseudocode (which isn't valid C):

          int foo (void)
          {
            register int *xr = &x;
            return xr[&a - &x] + xr[&b - &x] + xr[&c - &x];
          }

     Not all targets support this option.

'--param NAME=VALUE'
     In some places, GCC uses various constants to control the amount of
     optimization that is done.  For example, GCC does not inline
     functions that contain more than a certain number of instructions.
     You can control some of these constants on the command line using
     the '--param' option.

     The names of specific parameters, and the meaning of the values,
     are tied to the internals of the compiler, and are subject to
     change without notice in future releases.

     In order to get minimal, maximal and default value of a parameter,
     one can use '--help=param -Q' options.

     In each case, the VALUE is an integer.  The allowable choices for
     NAME are:

     'predictable-branch-outcome'
          When branch is predicted to be taken with probability lower
          than this threshold (in percent), then it is considered well
          predictable.

     'max-rtl-if-conversion-insns'
          RTL if-conversion tries to remove conditional branches around
          a block and replace them with conditionally executed
          instructions.  This parameter gives the maximum number of
          instructions in a block which should be considered for
          if-conversion.  The compiler will also use other heuristics to
          decide whether if-conversion is likely to be profitable.

     'max-rtl-if-conversion-predictable-cost'
     'max-rtl-if-conversion-unpredictable-cost'
          RTL if-conversion will try to remove conditional branches
          around a block and replace them with conditionally executed
          instructions.  These parameters give the maximum permissible
          cost for the sequence that would be generated by if-conversion
          depending on whether the branch is statically determined to be
          predictable or not.  The units for this parameter are the same
          as those for the GCC internal seq_cost metric.  The compiler
          will try to provide a reasonable default for this parameter
          using the BRANCH_COST target macro.

     'max-crossjump-edges'
          The maximum number of incoming edges to consider for
          cross-jumping.  The algorithm used by '-fcrossjumping' is
          vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
