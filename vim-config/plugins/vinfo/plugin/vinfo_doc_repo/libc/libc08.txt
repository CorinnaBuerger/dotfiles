atanf128      -               -               -               -               1
atan2f        1               1               1               1               -
atan2         -               -               -               -               1
atan2l        1               1               -               1               1
atan2f128     -               -               -               -               1
atanhf        2               2               2               2               -
atanh         2               2               2               2               1
atanhl        3               3               -               3               3
atanhf128     -               -               -               -               3
cabsf         -               -               -               -               -
cabs          1               1               1               1               1
cabsl         1               1               -               1               1
cabsf128      -               -               -               -               1
cacosf        2 + i 2         2 + i 2         2 + i 2         2 + i 2         2 + i 2
cacos         1 + i 2         1 + i 2         1 + i 2         1 + i 2         1 + i 2
cacosl        2 + i 2         2 + i 2         -               2 + i 2         1 + i 2
cacosf128     -               -               -               -               2 + i 2
cacoshf       2 + i 2         2 + i 2         2 + i 2         2 + i 2         2 + i 2
cacosh        2 + i 1         2 + i 1         2 + i 1         2 + i 1         2 + i 1
cacoshl       2 + i 2         2 + i 2         -               2 + i 2         2 + i 1
cacoshf128    -               -               -               -               2 + i 2
cargf         1               1               1               1               -
carg          -               -               -               -               1
cargl         2               2               -               2               1
cargf128      -               -               -               -               2
casinf        1 + i 2         1 + i 2         1 + i 2         1 + i 2         1 + i 2
casin         1 + i 2         1 + i 2         1 + i 2         1 + i 2         1 + i 2
casinl        2 + i 2         2 + i 2         -               2 + i 2         1 + i 2
casinf128     -               -               -               -               2 + i 2
casinhf       2 + i 1         2 + i 1         2 + i 1         2 + i 1         2 + i 1
casinh        2 + i 1         2 + i 1         2 + i 1         2 + i 1         2 + i 1
casinhl       2 + i 2         2 + i 2         -               2 + i 2         2 + i 1
casinhf128    -               -               -               -               2 + i 2
catanf        1 + i 1         1 + i 1         1 + i 1         1 + i 1         0 + i 1
catan         1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
catanl        1 + i 1         1 + i 1         -               1 + i 1         1 + i 1
catanf128     -               -               -               -               1 + i 1
catanhf       1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 0
catanh        1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
catanhl       1 + i 1         1 + i 1         -               1 + i 1         1 + i 1
catanhf128    -               -               -               -               1 + i 1
cbrtf         1               1               1               1               1
cbrt          3               3               3               3               1
cbrtl         1               1               -               1               3
cbrtf128      -               -               -               -               1
ccosf         1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccos          1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccosl         1 + i 1         1 + i 1         -               1 + i 1         1 + i 1
ccosf128      -               -               -               -               1 + i 1
ccoshf        1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccosh         1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
ccoshl        1 + i 1         1 + i 1         -               1 + i 1         1 + i 1
ccoshf128     -               -               -               -               1 + i 1
cexpf         1 + i 2         1 + i 2         1 + i 2         1 + i 2         1 + i 2
cexp          2 + i 1         2 + i 1         2 + i 1         2 + i 1         2 + i 1
cexpl         1 + i 1         1 + i 1         -               1 + i 1         1 + i 1
cexpf128      -               -               -               -               1 + i 1
clogf         3 + i 1         3 + i 1         3 + i 1         3 + i 1         3 + i 0
clog          3 + i 0         3 + i 0         3 + i 0         3 + i 0         2 + i 1
clogl         2 + i 1         2 + i 1         -               4 + i 1         3 + i 1
clogf128      -               -               -               -               2 + i 1
clog10f       4 + i 2         4 + i 2         4 + i 2         4 + i 2         4 + i 1
clog10        3 + i 2         3 + i 2         3 + i 2         3 + i 2         3 + i 2
clog10l       2 + i 2         2 + i 2         -               4 + i 2         4 + i 2
clog10f128    -               -               -               -               2 + i 2
cosf          -               -               1               1               -
cos           -               1               1               1               1
cosl          1               1               -               1               1
cosf128       -               -               -               -               1
coshf         1               1               1               1               1
cosh          1               1               1               1               1
coshl         1               1               -               1               2
coshf128      -               -               -               -               1
cpowf         5 + i 2         5 + i 2         5 + i 2         5 + i 2         5 + i 2
cpow          2 + i 0         2 + i 0         2 + i 0         2 + i 0         2 + i 1
cpowl         4 + i 1         4 + i 1         -               4 + i 1         3 + i 4
cpowf128      -               -               -               -               4 + i 1
csinf         1 + i 0         1 + i 0         1 + i 0         1 + i 0         1 + i 1
csin          1 + i 0         1 + i 0         1 + i 0         1 + i 0         1 + i 1
csinl         1 + i 1         1 + i 1         -               1 + i 1         1 + i 0
csinf128      -               -               -               -               1 + i 1
csinhf        1 + i 1         1 + i 1         1 + i 1         1 + i 1         1 + i 1
csinh         0 + i 1         0 + i 1         0 + i 1         0 + i 1         1 + i 1
csinhl        1 + i 1         1 + i 1         -               1 + i 1         1 + i 1
csinhf128     -               -               -               -               1 + i 1
csqrtf        2 + i 2         2 + i 2         2 + i 2         2 + i 2         2 + i 2
csqrt         2 + i 2         2 + i 2         2 + i 2         2 + i 2         2 + i 2
csqrtl        2 + i 2         2 + i 2         -               2 + i 2         2 + i 2
csqrtf128     -               -               -               -               2 + i 2
ctanf         1 + i 2         1 + i 2         1 + i 2         1 + i 2         1 + i 2
ctan          1 + i 2         1 + i 2         1 + i 2         1 + i 2         1 + i 2
ctanl         3 + i 3         3 + i 3         -               3 + i 3         2 + i 1
ctanf128      -               -               -               -               3 + i 3
ctanhf        2 + i 2         2 + i 1         2 + i 2         2 + i 2         2 + i 2
ctanh         2 + i 2         2 + i 2         2 + i 2         2 + i 2         2 + i 2
ctanhl        3 + i 3         3 + i 3         -               3 + i 3         1 + i 2
ctanhf128     -               -               -               -               3 + i 3
div_ldoublef  -               -               -               -               -
div_ldouble   -               -               -               -               -
div_ldoublel  -               -               -               -               -
div_ldoublef128-              -               -               -               -
erff          1               1               1               1               1
erf           1               1               1               1               1
erfl          1               1               -               1               1
erff128       -               -               -               -               1
erfcf         2               2               2               2               2
erfc          3               2               3               3               3
erfcl         2               2               -               2               3
erfcf128      -               -               -               -               2
expf          -               -               -               1               -
exp           -               -               -               -               1
expl          1               1               -               1               1
expf128       -               -               -               -               1
exp10f        -               -               -               -               -
exp10         2               2               2               2               1
exp10l        2               2               -               2               1
exp10f128     -               -               -               -               2
exp2f         -               -               -               1               -
exp2          1               1               1               1               1
exp2l         1               1               -               1               1
exp2f128      -               -               -               -               1
expm1f        1               1               1               1               -
expm1         1               1               1               1               1
expm1l        1               1               -               1               2
expm1f128     -               -               -               -               1
fmaf          -               -               -               -               -
fma           -               -               -               -               -
fmal          -               -               -               -               -
fmaf128       -               -               -               -               -
fmodf         -               -               -               -               -
fmod          -               -               -               -               -
fmodl         -               -               -               -               -
fmodf128      -               -               -               -               -
gammaf        3               3               3               4               3
gamma         4               3               4               4               4
gammal        5               5               -               5               4
gammaf128     -               -               -               -               -
hypotf        -               -               -               -               -
hypot         1               1               1               1               1
hypotl        1               1               -               1               1
hypotf128     -               -               -               -               1
j0f           2               2               2               2               2
j0            2               2               2               2               2
j0l           2               2               -               2               2
j0f128        -               -               -               -               2
j1f           2               2               2               2               2
j1            1               1               1               1               2
j1l           4               4               -               4               1
j1f128        -               -               -               -               4
jnf           4               4               4               4               4
jn            4               4               4               4               4
jnl           7               7               -               7               4
jnf128        -               -               -               -               7
lgammaf       3               3               3               4               3
lgamma        4               3               4               4               4
lgammal       5               5               -               5               4
lgammaf128    -               -               -               -               5
logf          -               -               1               1               -
log           -               -               -               -               1
logl          1               1               -               1               1
logf128       -               -               -               -               1
log10f        2               2               2               2               -
log10         2               2               2               2               1
log10l        1               1               -               1               1
log10f128     -               -               -               -               1
log1pf        1               1               1               1               -
log1p         1               1               1               1               1
log1pl        2               2               -               2               2
log1pf128     -               -               -               -               2
log2f         1               1               1               1               1
log2          2               1               2               2               1
log2l         2               2               -               2               1
log2f128      -               -               -               -               2
mul_ldoublef  -               -               -               -               -
mul_ldouble   -               -               -               -               -
mul_ldoublel  -               -               -               -               -
mul_ldoublef128-              -               -               -               -
powf          -               -               1               3               -
pow           -               1               1               1               1
powl          2               2               -               2               1
powf128       -               -               -               -               2
sinf          -               -               1               1               -
sin           -               1               1               1               1
sinl          1               1               -               1               1
sinf128       -               -               -               -               1
sincosf       -               -               1               1               -
sincos        -               1               1               1               1
sincosl       1               1               -               1               1
sincosf128    -               -               -               -               1
sinhf         2               2               2               2               2
sinh          2               2               2               2               2
sinhl         2               2               -               2               2
sinhf128      -               -               -               -               2
sqrtf         -               -               -               -               -
sqrt          -               -               -               -               -
sqrtl         -               -               -               -               -
sqrtf128      -               -               -               -               -
sub_ldoublef  -               -               -               -               -
sub_ldouble   -               -               -               -               -
sub_ldoublel  -               -               -               -               -
sub_ldoublef128-              -               -               -               -
tanf          1               1               1               1               1
tan           -               -               -               -               -
tanl          1               1               -               1               2
tanf128       -               -               -               -               1
tanhf         2               2               2               2               2
tanh          2               2               2               2               2
tanhl         2               2               -               2               3
tanhf128      -               -               -               -               2
tgammaf       4               4               4               5               4
tgamma        5               5               5               5               5
tgammal       4               4               -               4               5
tgammaf128    -               -               -               -               4
y0f           1               1               1               1               1
y0            2               2               2               2               2
y0l           3               3               -               3               1
y0f128        -               -               -               -               3
y1f           2               2               2               2               2
y1            3               3               3               3               3
y1l           2               2               -               2               2
y1f128        -               -               -               -               2
ynf           3               3               3               3               3
yn            3               3               3               3               3
ynl           5               5               -               5               4
ynf128        -               -               -               -               5
Function      ix86            x86_64
acosf         -               1
acos          1               -
acosl         1               1
acosf128      1               1
acoshf        -               2
acosh         1               2
acoshl        2               2
acoshf128     2               2
add_ldoublef  -               -
add_ldouble   -               -
add_ldoublel  -               -
add_ldoublef128-              -
asinf         -               1
asin          1               -
asinl         1               1
asinf128      1               1
asinhf        -               1
asinh         1               1
asinhl        3               3
asinhf128     3               3
atanf         -               1
atan          1               -
atanl         1               1
atanf128      1               1
atan2f        -               1
atan2         1               -
atan2l        1               1
atan2f128     1               1
atanhf        -               2
atanh         1               2
atanhl        3               3
atanhf128     3               3
cabsf         -               -
cabs          1               1
cabsl         1               1
cabsf128      1               1
cacosf        2 + i 2         2 + i 2
cacos         1 + i 2         1 + i 2
cacosl        1 + i 2         1 + i 2
cacosf128     2 + i 2         2 + i 2
cacoshf       2 + i 2         2 + i 2
cacosh        2 + i 1         2 + i 1
cacoshl       2 + i 1         2 + i 1
cacoshf128    2 + i 2         2 + i 2
cargf         -               1
carg          1               -
cargl         1               1
cargf128      2               2
casinf        1 + i 2         1 + i 2
casin         1 + i 2         1 + i 2
casinl        1 + i 2         1 + i 2
casinf128     2 + i 2         2 + i 2
casinhf       2 + i 1         2 + i 1
casinh        2 + i 1         2 + i 1
casinhl       2 + i 1         2 + i 1
casinhf128    2 + i 2         2 + i 2
catanf        0 + i 1         1 + i 1
catan         1 + i 1         1 + i 1
catanl        1 + i 1         1 + i 1
catanf128     1 + i 1         1 + i 1
catanhf       1 + i 0         1 + i 1
catanh        1 + i 1         1 + i 1
catanhl       1 + i 1         1 + i 1
catanhf128    1 + i 1         1 + i 1
cbrtf         1               1
cbrt          1               3
cbrtl         3               1
cbrtf128      1               1
ccosf         1 + i 1         1 + i 1
ccos          1 + i 1         1 + i 1
ccosl         1 + i 1         1 + i 1
ccosf128      1 + i 1         1 + i 1
ccoshf        1 + i 1         1 + i 1
ccosh         1 + i 1         1 + i 1
ccoshl        1 + i 1         1 + i 1
ccoshf128     1 + i 1         1 + i 1
cexpf         1 + i 2         1 + i 2
cexp          2 + i 1         2 + i 1
cexpl         1 + i 1         1 + i 1
cexpf128      1 + i 1         1 + i 1
clogf         3 + i 0         3 + i 1
clog          2 + i 1         3 + i 0
clogl         3 + i 1         3 + i 1
clogf128      2 + i 1         2 + i 1
clog10f       4 + i 1         4 + i 2
clog10        3 + i 2         3 + i 2
clog10l       4 + i 2         4 + i 2
clog10f128    2 + i 2         2 + i 2
cosf          1               -
cos           1               1
cosl          1               1
cosf128       1               1
coshf         1               1
cosh          1               1
coshl         2               2
coshf128      1               1
cpowf         5 + i 2         5 + i 2
cpow          2 + i 0         2 + i 0
cpowl         3 + i 4         3 + i 4
cpowf128      4 + i 1         4 + i 1
csinf         1 + i 1         1 + i 0
csin          1 + i 0         1 + i 0
csinl         1 + i 0         1 + i 0
csinf128      1 + i 1         1 + i 1
csinhf        1 + i 1         1 + i 1
csinh         0 + i 1         0 + i 1
csinhl        1 + i 1         1 + i 1
csinhf128     1 + i 1         1 + i 1
csqrtf        2 + i 2         2 + i 2
csqrt         2 + i 2         2 + i 2
csqrtl        2 + i 2         2 + i 2
csqrtf128     2 + i 2         2 + i 2
ctanf         1 + i 2         1 + i 2
ctan          1 + i 2         1 + i 2
ctanl         2 + i 1         2 + i 1
ctanf128      3 + i 3         3 + i 3
ctanhf        2 + i 2         2 + i 2
ctanh         2 + i 2         2 + i 2
ctanhl        1 + i 2         1 + i 2
ctanhf128     3 + i 3         3 + i 3
div_ldoublef  -               -
div_ldouble   -               -
div_ldoublel  -               -
div_ldoublef128-              -
erff          1               1
erf           1               1
erfl          1               1
erff128       1               1
erfcf         2               2
erfc          3               3
erfcl         3               3
erfcf128      2               2
expf          -               -
exp           1               -
expl          1               1
expf128       1               1
exp10f        -               -
exp10         1               2
exp10l        1               1
exp10f128     2               2
exp2f         -               1
exp2          1               1
exp2l         1               1
exp2f128      1               1
expm1f        -               1
expm1         1               1
expm1l        2               2
expm1f128     1               1
fmaf          -               -
fma           -               -
fmal          -               -
fmaf128       -               -
fmodf         -               -
fmod          -               -
fmodl         -               -
fmodf128      -               -
gammaf        3               4
gamma         4               4
gammal        4               4
gammaf128     -               -
hypotf        -               -
hypot         1               1
hypotl        1               1
hypotf128     1               1
j0f           2               2
j0            2               2
j0l           2               2
j0f128        2               2
j1f           2               2
j1            2               1
j1l           1               1
j1f128        4               4
jnf           4               4
jn            4               4
jnl           4               4
jnf128        7               7
lgammaf       3               4
lgamma        4               4
lgammal       4               4
lgammaf128    5               5
logf          -               1
log           1               -
logl          1               1
logf128       1               1
log10f        -               2
log10         1               2
log10l        1               1
log10f128     1               1
log1pf        -               1
log1p         1               1
log1pl        2               2
log1pf128     2               2
log2f         1               1
log2          1               2
log2l         1               1
log2f128      2               2
mul_ldoublef  -               -
mul_ldouble   -               -
mul_ldoublel  -               -
mul_ldoublef128-              -
powf          -               1
pow           1               1
powl          1               1
powf128       2               2
sinf          1               -
sin           1               1
sinl          1               1
sinf128       1               1
sincosf       1               -
sincos        1               1
sincosl       1               1
sincosf128    1               1
sinhf         2               2
sinh          2               2
sinhl         2               2
sinhf128      2               2
sqrtf         -               -
sqrt          -               -
sqrtl         -               -
sqrtf128      -               -
sub_ldoublef  -               -
sub_ldouble   -               -
sub_ldoublel  -               -
sub_ldoublef128-              -
tanf          1               1
tan           -               -
tanl          2               2
tanf128       1               1
tanhf         2               2
tanh          2               2
tanhl         3               3
tanhf128      2               2
tgammaf       4               5
tgamma        5               5
tgammal       5               5
tgammaf128    4               4
y0f           1               1
y0            2               2
y0l           1               1
y0f128        3               3
y1f           2               2
y1            3               3
y1l           2               2
y1f128        2               2
ynf           3               3
yn            3               3
ynl           4               4
ynf128        5               5

==============================================================================
File: libc.info,  Node: |Pseudo_Random_Numbers|,  Next: |FP_Function_Optimizations|,  Prev: |Errors_in_Math_Functions|,  Up: |Mathematics|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Pseudo_Random_Numbers*

19.8 Pseudo-Random Numbers
--------------------------

This section describes the GNU facilities for generating a series of
pseudo-random numbers.  The numbers generated are not truly random;
typically, they form a sequence that repeats periodically, with a period
so large that you can ignore it for ordinary purposes.  The random
number generator works by remembering a "seed" value which it uses to
compute the next random number and also to compute a new seed.

   Although the generated numbers look unpredictable within one run of a
program, the sequence of numbers is _exactly the same_ from one run to
the next.  This is because the initial seed is always the same.  This is
convenient when you are debugging a program, but it is unhelpful if you
want the program to behave unpredictably.  If you want a different
pseudo-random series each time your program runs, you must specify a
different seed each time.  For ordinary purposes, basing the seed on the
current time works well.  For random numbers in cryptography, *note
Unpredictable Bytes::.

   You can obtain repeatable sequences of numbers on a particular
machine type by specifying the same initial seed value for the random
number generator.  There is no standard meaning for a particular seed
value; the same seed, used in different C libraries or on different CPU
types, will give you different random numbers.

   The GNU C Library supports the standard ISO C random number functions
plus two other sets derived from BSD and SVID. The BSD and ISO C
functions provide identical, somewhat limited functionality.  If only a
small number of random bits are required, we recommend you use the ISO C
interface, 'rand' and 'srand'.  The SVID functions provide a more
flexible interface, which allows better random number generator
algorithms, provides more random bits (up to 48) per call, and can
provide random floating-point numbers.  These functions are required by
the XPG standard and therefore will be present in all modern Unix
systems.

MENU

* |ISO_Random|::                  'rand' and friends.
* |BSD_Random|::                  'random' and friends.
* |SVID_Random|::                 'drand48' and friends.

==============================================================================
File: libc.info,  Node: |ISO_Random|,  Next: |BSD_Random|,  Up: |Pseudo_Random_Numbers|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *ISO_Random*

19.8.1 ISO C Random Number Functions
------------------------------------

This section describes the random number functions that are part of the
ISO C standard.

   To use these facilities, you should include the header file
'stdlib.h' in your program.

 -- Macro: int RAND_MAX

     The value of this macro is an integer constant representing the
     largest value the 'rand' function can return.  In the GNU C
     Library, it is '2147483647', which is the largest signed integer
     representable in 32 bits.  In other libraries, it may be as low as
     '32767'.

 -- Function: int rand (void)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     The 'rand' function returns the next pseudo-random number in the
     series.  The value ranges from '0' to 'RAND_MAX'.

 -- Function: void srand (unsigned int SEED)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function establishes SEED as the seed for a new series of
     pseudo-random numbers.  If you call 'rand' before a seed has been
     established with 'srand', it uses the value '1' as a default seed.

     To produce a different pseudo-random series each time your program
     is run, do 'srand (time (0))'.

   POSIX.1 extended the C standard functions to support reproducible
random numbers in multi-threaded programs.  However, the extension is
badly designed and unsuitable for serious work.

 -- Function: int rand_r (unsigned int *SEED)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns a random number in the range 0 to 'RAND_MAX'
     just as 'rand' does.  However, all its state is stored in the SEED
     argument.  This means the RNG's state can only have as many bits as
     the type 'unsigned int' has.  This is far too few to provide a good
     RNG.

     If your program requires a reentrant RNG, we recommend you use the
     reentrant GNU extensions to the SVID random number generator.  The
     POSIX.1 interface should only be used when the GNU extensions are
     not available.

==============================================================================
File: libc.info,  Node: |BSD_Random|,  Next: |SVID_Random|,  Prev: |ISO_Random|,  Up: |Pseudo_Random_Numbers|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *BSD_Random*

19.8.2 BSD Random Number Functions
----------------------------------

This section describes a set of random number generation functions that
are derived from BSD. There is no advantage to using these functions
with the GNU C Library; we support them for BSD compatibility only.

   The prototypes for these functions are in 'stdlib.h'.

 -- Function: long int random (void)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function returns the next pseudo-random number in the
     sequence.  The value returned ranges from '0' to '2147483647'.

     NB: Temporarily this function was defined to return a 'int32_t'
     value to indicate that the return value always contains 32 bits
     even if 'long int' is wider.  The standard demands it differently.
     Users must always be aware of the 32-bit limitation, though.

 -- Function: void srandom (unsigned int SEED)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     The 'srandom' function sets the state of the random number
     generator based on the integer SEED.  If you supply a SEED value of
     '1', this will cause 'random' to reproduce the default set of
     random numbers.

     To produce a different set of pseudo-random numbers each time your
     program runs, do 'srandom (time (0))'.

 -- Function: char * initstate (unsigned int SEED, char *STATE, size_t
          SIZE)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     The 'initstate' function is used to initialize the random number
     generator state.  The argument STATE is an array of SIZE bytes,
     used to hold the state information.  It is initialized based on
     SEED.  The size must be between 8 and 256 bytes, and should be a
     power of two.  The bigger the STATE array, the better.

     The return value is the previous value of the state information
     array.  You can use this value later as an argument to 'setstate'
     to restore that state.

 -- Function: char * setstate (char *STATE)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     The 'setstate' function restores the random number state
     information STATE.  The argument must have been the result of a
     previous call to INITSTATE or SETSTATE.

     The return value is the previous value of the state information
     array.  You can use this value later as an argument to 'setstate'
     to restore that state.

     If the function fails the return value is 'NULL'.

   The four functions described so far in this section all work on a
state which is shared by all threads.  The state is not directly
accessible to the user and can only be modified by these functions.
This makes it hard to deal with situations where each thread should have
its own pseudo-random number generator.

   The GNU C Library contains four additional functions which contain
the state as an explicit parameter and therefore make it possible to
handle thread-local PRNGs.  Besides this there is no difference.  In
fact, the four functions already discussed are implemented internally
using the following interfaces.

   The 'stdlib.h' header contains a definition of the following type:

 -- Data Type: struct random_data

     Objects of type 'struct random_data' contain the information
     necessary to represent the state of the PRNG. Although a complete
     definition of the type is present the type should be treated as
     opaque.

   The functions modifying the state follow exactly the already
described functions.

 -- Function: int random_r (struct random_data *restrict BUF, int32_t
          *restrict RESULT)

     Preliminary: | MT-Safe race:buf | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'random_r' function behaves exactly like the 'random' function
     except that it uses and modifies the state in the object pointed to
     by the first parameter instead of the global state.

 -- Function: int srandom_r (unsigned int SEED, struct random_data *BUF)

     Preliminary: | MT-Safe race:buf | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'srandom_r' function behaves exactly like the 'srandom'
     function except that it uses and modifies the state in the object
     pointed to by the second parameter instead of the global state.

 -- Function: int initstate_r (unsigned int SEED, char *restrict
          STATEBUF, size_t STATELEN, struct random_data *restrict BUF)

     Preliminary: | MT-Safe race:buf | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'initstate_r' function behaves exactly like the 'initstate'
     function except that it uses and modifies the state in the object
     pointed to by the fourth parameter instead of the global state.

 -- Function: int setstate_r (char *restrict STATEBUF, struct
          random_data *restrict BUF)

     Preliminary: | MT-Safe race:buf | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'setstate_r' function behaves exactly like the 'setstate'
     function except that it uses and modifies the state in the object
     pointed to by the first parameter instead of the global state.

==============================================================================
File: libc.info,  Node: |SVID_Random|,  Prev: |BSD_Random|,  Up: |Pseudo_Random_Numbers|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *SVID_Random*

19.8.3 SVID Random Number Function
----------------------------------

The C library on SVID systems contains yet another kind of random number
generator functions.  They use a state of 48 bits of data.  The user can
choose among a collection of functions which return the random bits in
different forms.

   Generally there are two kinds of function.  The first uses a state of
the random number generator which is shared among several functions and
by all threads of the process.  The second requires the user to handle
the state.

   All functions have in common that they use the same congruential
formula with the same constants.  The formula is

     Y = (a * X + c) mod m

where X is the state of the generator at the beginning and Y the state
at the end.  'a' and 'c' are constants determining the way the generator
works.  By default they are

     a = 0x5DEECE66D = 25214903917
     c = 0xb = 11

but they can also be changed by the user.  'm' is of course 2^48 since
the state consists of a 48-bit array.

   The prototypes for these functions are in 'stdlib.h'.

 -- Function: double drand48 (void)

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     This function returns a 'double' value in the range of '0.0' to
     '1.0' (exclusive).  The random bits are determined by the global
     state of the random number generator in the C library.

     Since the 'double' type according to IEEE 754 has a 52-bit mantissa
     this means 4 bits are not initialized by the random number
     generator.  These are (of course) chosen to be the least
     significant bits and they are initialized to '0'.

 -- Function: double erand48 (unsigned short int XSUBI[3])

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     This function returns a 'double' value in the range of '0.0' to
     '1.0' (exclusive), similarly to 'drand48'.  The argument is an
     array describing the state of the random number generator.

     This function can be called subsequently since it updates the array
     to guarantee random numbers.  The array should have been
     initialized before initial use to obtain reproducible results.

 -- Function: long int lrand48 (void)

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     The 'lrand48' function returns an integer value in the range of '0'
     to '2^31' (exclusive).  Even if the size of the 'long int' type can
     take more than 32 bits, no higher numbers are returned.  The random
     bits are determined by the global state of the random number
     generator in the C library.

 -- Function: long int nrand48 (unsigned short int XSUBI[3])

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     This function is similar to the 'lrand48' function in that it
     returns a number in the range of '0' to '2^31' (exclusive) but the
     state of the random number generator used to produce the random
     bits is determined by the array provided as the parameter to the
     function.

     The numbers in the array are updated afterwards so that subsequent
     calls to this function yield different results (as is expected of a
     random number generator).  The array should have been initialized
     before the first call to obtain reproducible results.

 -- Function: long int mrand48 (void)

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     The 'mrand48' function is similar to 'lrand48'.  The only
     difference is that the numbers returned are in the range '-2^31' to
     '2^31' (exclusive).

 -- Function: long int jrand48 (unsigned short int XSUBI[3])

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     The 'jrand48' function is similar to 'nrand48'.  The only
     difference is that the numbers returned are in the range '-2^31' to
     '2^31' (exclusive).  For the 'xsubi' parameter the same
     requirements are necessary.

   The internal state of the random number generator can be initialized
in several ways.  The methods differ in the completeness of the
information provided.

 -- Function: void srand48 (long int SEEDVAL)

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     The 'srand48' function sets the most significant 32 bits of the
     internal state of the random number generator to the least
     significant 32 bits of the SEEDVAL parameter.  The lower 16 bits
     are initialized to the value '0x330E'.  Even if the 'long int' type
     contains more than 32 bits only the lower 32 bits are used.

     Owing to this limitation, initialization of the state of this
     function is not very useful.  But it makes it easy to use a
     construct like 'srand48 (time (0))'.

     A side-effect of this function is that the values 'a' and 'c' from
     the internal state, which are used in the congruential formula, are
     reset to the default values given above.  This is of importance
     once the user has called the 'lcong48' function (see below).

 -- Function: unsigned short int * seed48 (unsigned short int
          SEED16V[3])

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     The 'seed48' function initializes all 48 bits of the state of the
     internal random number generator from the contents of the parameter
     SEED16V.  Here the lower 16 bits of the first element of SEED16V
     initialize the least significant 16 bits of the internal state, the
     lower 16 bits of 'SEED16V[1]' initialize the mid-order 16 bits of
     the state and the 16 lower bits of 'SEED16V[2]' initialize the most
     significant 16 bits of the state.

     Unlike 'srand48' this function lets the user initialize all 48 bits
     of the state.

     The value returned by 'seed48' is a pointer to an array containing
     the values of the internal state before the change.  This might be
     useful to restart the random number generator at a certain state.
     Otherwise the value can simply be ignored.

     As for 'srand48', the values 'a' and 'c' from the congruential
     formula are reset to the default values.

   There is one more function to initialize the random number generator
which enables you to specify even more information by allowing you to
change the parameters in the congruential formula.

 -- Function: void lcong48 (unsigned short int PARAM[7])

     Preliminary: | MT-Unsafe race:drand48 | AS-Unsafe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     The 'lcong48' function allows the user to change the complete state
     of the random number generator.  Unlike 'srand48' and 'seed48',
     this function also changes the constants in the congruential
     formula.

     From the seven elements in the array PARAM the least significant 16
     bits of the entries 'PARAM[0]' to 'PARAM[2]' determine the initial
     state, the least significant 16 bits of 'PARAM[3]' to 'PARAM[5]'
     determine the 48 bit constant 'a' and 'PARAM[6]' determines the
     16-bit value 'c'.

   All the above functions have in common that they use the global
parameters for the congruential formula.  In multi-threaded programs it
might sometimes be useful to have different parameters in different
threads.  For this reason all the above functions have a counterpart
which works on a description of the random number generator in the
user-supplied buffer instead of the global state.

   Please note that it is no problem if several threads use the global
state if all threads use the functions which take a pointer to an array
containing the state.  The random numbers are computed following the
same loop but if the state in the array is different all threads will
obtain an individual random number generator.

   The user-supplied buffer must be of type 'struct drand48_data'.  This
type should be regarded as opaque and not manipulated directly.

 -- Function: int drand48_r (struct drand48_data *BUFFER, double
          *RESULT)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     This function is equivalent to the 'drand48' function with the
     difference that it does not modify the global random number
     generator parameters but instead the parameters in the buffer
     supplied through the pointer BUFFER.  The random number is returned
     in the variable pointed to by RESULT.

     The return value of the function indicates whether the call
     succeeded.  If the value is less than '0' an error occurred and
     ERRNO is set to indicate the problem.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int erand48_r (unsigned short int XSUBI[3], struct
          drand48_data *BUFFER, double *RESULT)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'erand48_r' function works like 'erand48', but in addition it
     takes an argument BUFFER which describes the random number
     generator.  The state of the random number generator is taken from
     the 'xsubi' array, the parameters for the congruential formula from
     the global random number generator data.  The random number is
     returned in the variable pointed to by RESULT.

     The return value is non-negative if the call succeeded.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int lrand48_r (struct drand48_data *BUFFER, long int
          *RESULT)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     This function is similar to 'lrand48', but in addition it takes a
     pointer to a buffer describing the state of the random number
     generator just like 'drand48'.

     If the return value of the function is non-negative the variable
     pointed to by RESULT contains the result.  Otherwise an error
     occurred.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int nrand48_r (unsigned short int XSUBI[3], struct
          drand48_data *BUFFER, long int *RESULT)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'nrand48_r' function works like 'nrand48' in that it produces a
     random number in the range '0' to '2^31'.  But instead of using the
     global parameters for the congruential formula it uses the
     information from the buffer pointed to by BUFFER.  The state is
     described by the values in XSUBI.

     If the return value is non-negative the variable pointed to by
     RESULT contains the result.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int mrand48_r (struct drand48_data *BUFFER, long int
          *RESULT)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     This function is similar to 'mrand48' but like the other reentrant
     functions it uses the random number generator described by the
     value in the buffer pointed to by BUFFER.

     If the return value is non-negative the variable pointed to by
     RESULT contains the result.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int jrand48_r (unsigned short int XSUBI[3], struct
          drand48_data *BUFFER, long int *RESULT)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'jrand48_r' function is similar to 'jrand48'.  Like the other
     reentrant functions of this function family it uses the
     congruential formula parameters from the buffer pointed to by
     BUFFER.

     If the return value is non-negative the variable pointed to by
     RESULT contains the result.

     This function is a GNU extension and should not be used in portable
     programs.

   Before any of the above functions are used the buffer of type 'struct
drand48_data' should be initialized.  The easiest way to do this is to
fill the whole buffer with null bytes, e.g.  by

     memset (buffer, '\0', sizeof (struct drand48_data));

Using any of the reentrant functions of this family now will
automatically initialize the random number generator to the default
values for the state and the parameters of the congruential formula.

   The other possibility is to use any of the functions which explicitly
initialize the buffer.  Though it might be obvious how to initialize the
buffer from looking at the parameter to the function, it is highly
recommended to use these functions since the result might not always be
what you expect.

 -- Function: int srand48_r (long int SEEDVAL, struct drand48_data
          *BUFFER)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The description of the random number generator represented by the
     information in BUFFER is initialized similarly to what the function
     'srand48' does.  The state is initialized from the parameter
     SEEDVAL and the parameters for the congruential formula are
     initialized to their default values.

     If the return value is non-negative the function call succeeded.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int seed48_r (unsigned short int SEED16V[3], struct
          drand48_data *BUFFER)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     This function is similar to 'srand48_r' but like 'seed48' it
     initializes all 48 bits of the state from the parameter SEED16V.

     If the return value is non-negative the function call succeeded.
     It does not return a pointer to the previous state of the random
     number generator like the 'seed48' function does.  If the user
     wants to preserve the state for a later re-run s/he can copy the
     whole buffer pointed to by BUFFER.

     This function is a GNU extension and should not be used in portable
     programs.

 -- Function: int lcong48_r (unsigned short int PARAM[7], struct
          drand48_data *BUFFER)

     Preliminary: | MT-Safe race:buffer | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     This function initializes all aspects of the random number
     generator described in BUFFER with the data in PARAM.  Here it is
     especially true that the function does more than just copying the
     contents of PARAM and BUFFER.  More work is required and therefore
     it is important to use this function rather than initializing the
     random number generator directly.

     If the return value is non-negative the function call succeeded.

     This function is a GNU extension and should not be used in portable
     programs.

==============================================================================
File: libc.info,  Node: |FP_Function_Optimizations|,  Prev: Pseudo-Random Numbers,  Up: |Mathematics|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *FP_Function_Optimizations*

19.9 Is Fast Code or Small Code preferred?
------------------------------------------

If an application uses many floating point functions it is often the
case that the cost of the function calls themselves is not negligible.
Modern processors can often execute the operations themselves very fast,
but the function call disrupts the instruction pipeline.

   For this reason the GNU C Library provides optimizations for many of
the frequently-used math functions.  When GNU CC is used and the user
activates the optimizer, several new inline functions and macros are
defined.  These new functions and macros have the same names as the
library functions and so are used instead of the latter.  In the case of
inline functions the compiler will decide whether it is reasonable to
use them, and this decision is usually correct.

   This means that no calls to the library functions may be necessary,
and can increase the speed of generated code significantly.  The
drawback is that code size will increase, and the increase is not always
negligible.

   There are two kinds of inline functions: those that give the same
result as the library functions and others that might not set 'errno'
and might have a reduced precision and/or argument range in comparison
with the library functions.  The latter inline functions are only
available if the flag '-ffast-math' is given to GNU CC.

   In cases where the inline functions and macros are not wanted the
symbol '__NO_MATH_INLINES' should be defined before any system header is
included.  This will ensure that only library functions are used.  Of
course, it can be determined for each file in the project whether giving
this option is preferable or not.

   Not all hardware implements the entire IEEE 754 standard, and even if
it does there may be a substantial performance penalty for using some of
its features.  For example, enabling traps on some processors forces the
FPU to run un-pipelined, which can more than double calculation time.

==============================================================================
File: libc.info,  Node: |Arithmetic|,  Next: |Date_and_Time|,  Prev: |Mathematics|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Arithmetic*

20 Arithmetic Functions
=======================

This chapter contains information about functions for doing basic
arithmetic operations, such as splitting a float into its integer and
fractional parts or retrieving the imaginary part of a complex value.
These functions are declared in the header files 'math.h' and
'complex.h'.

MENU

* |Integers|::                    Basic integer types and concepts
* |Integer_Division|::            Integer division with guaranteed rounding.
* |Floating_Point_Numbers|::      Basic concepts.  IEEE 754.
* |Floating_Point_Classes|::      The five kinds of floating-point number.
* |Floating_Point_Errors|::       When something goes wrong in a calculation.
* |Rounding|::                    Controlling how results are rounded.
* |Control_Functions|::           Saving and restoring the FPU's state.
* |Arithmetic_Functions|::        Fundamental operations provided by the library.
* |Complex_Numbers|::             The types.  Writing complex constants.
* |Operations_on_Complex|::       Projection, conjugation, decomposition.
* |Parsing_of_Numbers|::          Converting strings to numbers.
* |Printing_of_Floats|::          Converting floating-point numbers to strings.
* |System_V_Number_Conversion|::  An archaic way to convert numbers to strings.

==============================================================================
File: libc.info,  Node: |Integers|,  Next: |Integer_Division|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Integers*

20.1 Integers
-------------

The C language defines several integer data types: integer, short
integer, long integer, and character, all in both signed and unsigned
varieties.  The GNU C compiler extends the language to contain long long
integers as well.

   The C integer types were intended to allow code to be portable among
machines with different inherent data sizes (word sizes), so each type
may have different ranges on different machines.  The problem with this
is that a program often needs to be written for a particular range of
integers, and sometimes must be written for a particular size of
storage, regardless of what machine the program runs on.

   To address this problem, the GNU C Library contains C type
definitions you can use to declare integers that meet your exact needs.
Because the GNU C Library header files are customized to a specific
machine, your program source code doesn't have to be.

   These 'typedef's are in 'stdint.h'.

   If you require that an integer be represented in exactly N bits, use
one of the following types, with the obvious mapping to bit size and
signedness:

   * int8_t
   * int16_t
   * int32_t
   * int64_t
   * uint8_t
   * uint16_t
   * uint32_t
   * uint64_t

   If your C compiler and target machine do not allow integers of a
certain size, the corresponding above type does not exist.

   If you don't need a specific storage size, but want the smallest data
structure with _at least_ N bits, use one of these:

   * int_least8_t
   * int_least16_t
   * int_least32_t
   * int_least64_t
   * uint_least8_t
   * uint_least16_t
   * uint_least32_t
   * uint_least64_t

   If you don't need a specific storage size, but want the data
structure that allows the fastest access while having at least N bits
(and among data structures with the same access speed, the smallest
one), use one of these:

   * int_fast8_t
   * int_fast16_t
   * int_fast32_t
   * int_fast64_t
   * uint_fast8_t
   * uint_fast16_t
   * uint_fast32_t
   * uint_fast64_t

   If you want an integer with the widest range possible on the platform
on which it is being used, use one of the following.  If you use these,
you should write code that takes into account the variable size and
range of the integer.

   * intmax_t
   * uintmax_t

   The GNU C Library also provides macros that tell you the maximum and
minimum possible values for each integer data type.  The macro names
follow these examples: 'INT32_MAX', 'UINT8_MAX', 'INT_FAST32_MIN',
'INT_LEAST64_MIN', 'UINTMAX_MAX', 'INTMAX_MAX', 'INTMAX_MIN'.  Note that
there are no macros for unsigned integer minima.  These are always zero.
Similiarly, there are macros such as 'INTMAX_WIDTH' for the width of
these types.  Those macros for integer type widths come from TS
18661-1:2014.

   There are similar macros for use with C's built in integer types
which should come with your C compiler.  These are described in *note
Data Type Measurements::.

   Don't forget you can use the C 'sizeof' function with any of these
data types to get the number of bytes of storage each uses.

==============================================================================
File: libc.info,  Node: |Integer_Division|,  Next: |Floating_Point_Numbers|,  Prev: |Integers|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Integer_Division*

20.2 Integer Division
---------------------

This section describes functions for performing integer division.  These
functions are redundant when GNU CC is used, because in GNU C the '/'
operator always rounds towards zero.  But in other C implementations,
'/' may round differently with negative arguments.  'div' and 'ldiv' are
useful because they specify how to round the quotient: towards zero.
The remainder has the same sign as the numerator.

   These functions are specified to return a result R such that the
value 'R.quot*DENOMINATOR + R.rem' equals NUMERATOR.

   To use these facilities, you should include the header file
'stdlib.h' in your program.

 -- Data Type: div_t

     This is a structure type used to hold the result returned by the
     'div' function.  It has the following members:

     'int quot'
          The quotient from the division.

     'int rem'
          The remainder from the division.

 -- Function: div_t div (int NUMERATOR, int DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function 'div' computes the quotient and remainder from the
     division of NUMERATOR by DENOMINATOR, returning the result in a
     structure of type 'div_t'.

     If the result cannot be represented (as in a division by zero), the
     behavior is undefined.

     Here is an example, albeit not a very useful one.

          div_t result;
          result = div (20, -6);

     Now 'result.quot' is '-3' and 'result.rem' is '2'.

 -- Data Type: ldiv_t

     This is a structure type used to hold the result returned by the
     'ldiv' function.  It has the following members:

     'long int quot'
          The quotient from the division.

     'long int rem'
          The remainder from the division.

     (This is identical to 'div_t' except that the components are of
     type 'long int' rather than 'int'.)

 -- Function: ldiv_t ldiv (long int NUMERATOR, long int DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'ldiv' function is similar to 'div', except that the arguments
     are of type 'long int' and the result is returned as a structure of
     type 'ldiv_t'.

 -- Data Type: lldiv_t

     This is a structure type used to hold the result returned by the
     'lldiv' function.  It has the following members:

     'long long int quot'
          The quotient from the division.

     'long long int rem'
          The remainder from the division.

     (This is identical to 'div_t' except that the components are of
     type 'long long int' rather than 'int'.)

 -- Function: lldiv_t lldiv (long long int NUMERATOR, long long int
          DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'lldiv' function is like the 'div' function, but the arguments
     are of type 'long long int' and the result is returned as a
     structure of type 'lldiv_t'.

     The 'lldiv' function was added in ISO C99.

 -- Data Type: imaxdiv_t

     This is a structure type used to hold the result returned by the
     'imaxdiv' function.  It has the following members:

     'intmax_t quot'
          The quotient from the division.

     'intmax_t rem'
          The remainder from the division.

     (This is identical to 'div_t' except that the components are of
     type 'intmax_t' rather than 'int'.)

     See *note Integers:: for a description of the 'intmax_t' type.

 -- Function: imaxdiv_t imaxdiv (intmax_t NUMERATOR, intmax_t
          DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'imaxdiv' function is like the 'div' function, but the
     arguments are of type 'intmax_t' and the result is returned as a
     structure of type 'imaxdiv_t'.

     See *note Integers:: for a description of the 'intmax_t' type.

     The 'imaxdiv' function was added in ISO C99.

==============================================================================
File: libc.info,  Node: |Floating_Point_Numbers|,  Next: |Floating_Point_Classes|,  Prev: |Integer_Division|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Floating_Point_Numbers*

20.3 Floating Point Numbers
---------------------------

Most computer hardware has support for two different kinds of numbers:
integers (...-3, -2, -1, 0, 1, 2, 3...) and floating-point numbers.
Floating-point numbers have three parts: the "mantissa", the "exponent",
and the "sign bit".  The real number represented by a floating-point
value is given by (s ? -1 : 1) * 2^e * M where s is the sign bit, e the
exponent, and M the mantissa.  *Note Floating Point Concepts::, for
details.  (It is possible to have a different "base" for the exponent,
but all modern hardware uses 2.)

   Floating-point numbers can represent a finite subset of the real
numbers.  While this subset is large enough for most purposes, it is
important to remember that the only reals that can be represented
exactly are rational numbers that have a terminating binary expansion
shorter than the width of the mantissa.  Even simple fractions such as
1/5 can only be approximated by floating point.

   Mathematical operations and functions frequently need to produce
values that are not representable.  Often these values can be
approximated closely enough for practical purposes, but sometimes they
can't.  Historically there was no way to tell when the results of a
calculation were inaccurate.  Modern computers implement the IEEE 754
standard for numerical computations, which defines a framework for
indicating to the program when the results of calculation are not
trustworthy.  This framework consists of a set of "exceptions" that
indicate why a result could not be represented, and the special values
"infinity" and "not a number" (NaN).

==============================================================================
File: libc.info,  Node: |Floating_Point_Classes|,  Next: |Floating_Point_Errors|,  Prev: |Floating_Point_Numbers|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Floating_Point_Classes*

20.4 Floating-Point Number Classification Functions
---------------------------------------------------

ISO C99 defines macros that let you determine what sort of
floating-point number a variable holds.

 -- Macro: int fpclassify (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is a generic macro which works on all floating-point types and
     which returns a value of type 'int'.  The possible values are:

     'FP_NAN'

          The floating-point number X is "Not a Number" (*note Infinity
          and NaN::)
     'FP_INFINITE'

          The value of X is either plus or minus infinity (*note
          Infinity and NaN::)
     'FP_ZERO'

          The value of X is zero.  In floating-point formats like
          IEEE 754, where zero can be signed, this value is also
          returned if X is negative zero.
     'FP_SUBNORMAL'

          Numbers whose absolute value is too small to be represented in
          the normal format are represented in an alternate,
          "denormalized" format (*note Floating Point Concepts::).  This
          format is less precise but can represent values closer to
          zero.  'fpclassify' returns this value for values of X in this
          alternate format.
     'FP_NORMAL'

          This value is returned for all other values of X.  It
          indicates that there is nothing special about the number.

   'fpclassify' is most useful if more than one property of a number
must be tested.  There are more specific macros which only test one
property at a time.  Generally these macros execute faster than
'fpclassify', since there is special hardware support for them.  You
should therefore use the specific macros whenever possible.

 -- Macro: int iscanonical (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     In some floating-point formats, some values have canonical
     (preferred) and noncanonical encodings (for IEEE interchange binary
     formats, all encodings are canonical).  This macro returns a
     nonzero value if X has a canonical encoding.  It is from TS
     18661-1:2014.

     Note that some formats have multiple encodings of a value which are
     all equally canonical; 'iscanonical' returns a nonzero value for
     all such encodings.  Also, formats may have encodings that do not
     correspond to any valid value of the type.  In ISO C terms these
     are "trap representations"; in the GNU C Library, 'iscanonical'
     returns zero for such encodings.

 -- Macro: int isfinite (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if X is finite: not plus or
     minus infinity, and not NaN. It is equivalent to

          (fpclassify (x) != FP_NAN && fpclassify (x) != FP_INFINITE)

     'isfinite' is implemented as a macro which accepts any
     floating-point type.

 -- Macro: int isnormal (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if X is finite and normalized.
     It is equivalent to

          (fpclassify (x) == FP_NORMAL)

 -- Macro: int isnan (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if X is NaN. It is equivalent to

          (fpclassify (x) == FP_NAN)

 -- Macro: int issignaling (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if X is a signaling NaN (sNaN).
     It is from TS 18661-1:2014.

 -- Macro: int issubnormal (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if X is subnormal.  It is from
     TS 18661-1:2014.

 -- Macro: int iszero (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if X is zero.  It is from TS
     18661-1:2014.

   Another set of floating-point classification functions was provided
by BSD. The GNU C Library also supports these functions; however, we
recommend that you use the ISO C99 macros in new code.  Those are
standard and will be available more widely.  Also, since they are
macros, you do not have to worry about the type of their argument.

 -- Function: int isinf (double X)
 -- Function: int isinff (float X)
 -- Function: int isinfl (long double X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns '-1' if X represents negative infinity, '1'
     if X represents positive infinity, and '0' otherwise.

 -- Function: int isnan (double X)
 -- Function: int isnanf (float X)
 -- Function: int isnanl (long double X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns a nonzero value if X is a "not a number"
     value, and zero otherwise.

     NB: The 'isnan' macro defined by ISO C99 overrides the BSD
     function.  This is normally not a problem, because the two routines
     behave identically.  However, if you really need to get the BSD
     function for some reason, you can write

          (isnan) (x)

 -- Function: int finite (double X)
 -- Function: int finitef (float X)
 -- Function: int finitel (long double X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns a nonzero value if X is neither infinite nor
     a "not a number" value, and zero otherwise.

   *Portability Note:* The functions listed in this section are BSD
extensions.

==============================================================================
File: libc.info,  Node: |Floating_Point_Errors|,  Next: |Rounding|,  Prev: |Floating_Point_Classes|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Floating_Point_Errors*

20.5 Errors in Floating-Point Calculations
------------------------------------------

MENU

* |FP_Exceptions|::               IEEE 754 math exceptions and how to detect them.
* |Infinity_and_NaN|::            Special values returned by calculations.
* |Status_bit_operations|::       Checking for exceptions after the fact.
* |Math_Error_Reporting|::        How the math functions report errors.

==============================================================================
File: libc.info,  Node: |FP_Exceptions|,  Next: |Infinity_and_NaN|,  Up: |Floating_Point_Errors|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *FP_Exceptions*

20.5.1 FP Exceptions
--------------------

The IEEE 754 standard defines five "exceptions" that can occur during a
calculation.  Each corresponds to a particular sort of error, such as
overflow.

   When exceptions occur (when exceptions are "raised", in the language
of the standard), one of two things can happen.  By default the
exception is simply noted in the floating-point "status word", and the
program continues as if nothing had happened.  The operation produces a
default value, which depends on the exception (see the table below).
Your program can check the status word to find out which exceptions
happened.

   Alternatively, you can enable "traps" for exceptions.  In that case,
when an exception is raised, your program will receive the 'SIGFPE'
signal.  The default action for this signal is to terminate the program.
*Note Signal Handling::, for how you can change the effect of the
signal.

The exceptions defined in IEEE 754 are:

'Invalid Operation'
     This exception is raised if the given operands are invalid for the
     operation to be performed.  Examples are (see IEEE 754, section 7):
       1. Addition or subtraction: oo - oo.  (But oo + oo = oo).
       2. Multiplication: 0 * oo.
       3. Division: 0/0 or oo/oo.
       4. Remainder: x REM y, where y is zero or x is infinite.
       5. Square root if the operand is less than zero.  More generally,
          any mathematical function evaluated outside its domain
          produces this exception.
       6. Conversion of a floating-point number to an integer or decimal
          string, when the number cannot be represented in the target
          format (due to overflow, infinity, or NaN).
       7. Conversion of an unrecognizable input string.
       8. Comparison via predicates involving < or >, when one or other
          of the operands is NaN. You can prevent this exception by
          using the unordered comparison functions instead; see *note FP
          Comparison Functions::.

     If the exception does not trap, the result of the operation is NaN.

'Division by Zero'
     This exception is raised when a finite nonzero number is divided by
     zero.  If no trap occurs the result is either +oo or -oo, depending
     on the signs of the operands.

'Overflow'
     This exception is raised whenever the result cannot be represented
     as a finite value in the precision format of the destination.  If
     no trap occurs the result depends on the sign of the intermediate
     result and the current rounding mode (IEEE 754, section 7.3):
       1. Round to nearest carries all overflows to oo with the sign of
          the intermediate result.
       2. Round toward 0 carries all overflows to the largest
          representable finite number with the sign of the intermediate
          result.
       3. Round toward -oo carries positive overflows to the largest
          representable finite number and negative overflows to -oo.

       4. Round toward oo carries negative overflows to the most
          negative representable finite number and positive overflows to
          oo.

     Whenever the overflow exception is raised, the inexact exception is
     also raised.

'Underflow'
     The underflow exception is raised when an intermediate result is
     too small to be calculated accurately, or if the operation's result
     rounded to the destination precision is too small to be normalized.

     When no trap is installed for the underflow exception, underflow is
     signaled (via the underflow flag) only when both tininess and loss
     of accuracy have been detected.  If no trap handler is installed
     the operation continues with an imprecise small value, or zero if
     the destination precision cannot hold the small exact result.

'Inexact'
     This exception is signalled if a rounded result is not exact (such
     as when calculating the square root of two) or a result overflows
     without an overflow trap.

==============================================================================
File: libc.info,  Node: |Infinity_and_NaN|,  Next: |Status_bit_operations|,  Prev: |FP_Exceptions|,  Up: |Floating_Point_Errors|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Infinity_and_NaN*

20.5.2 Infinity and NaN
-----------------------

IEEE 754 floating point numbers can represent positive or negative
infinity, and "NaN" (not a number).  These three values arise from
calculations whose result is undefined or cannot be represented
accurately.  You can also deliberately set a floating-point variable to
any of them, which is sometimes useful.  Some examples of calculations
that produce infinity or NaN:

     1/0 = oo
     log (0) = -oo
     sqrt (-1) = NaN

   When a calculation produces any of these values, an exception also
occurs; see *note FP Exceptions::.

   The basic operations and math functions all accept infinity and NaN
and produce sensible output.  Infinities propagate through calculations
as one would expect: for example, 2 + oo = oo, 4/oo = 0, atan (oo) =
pi/2.  NaN, on the other hand, infects any calculation that involves it.
Unless the calculation would produce the same result no matter what real
value replaced NaN, the result is NaN.

   In comparison operations, positive infinity is larger than all values
except itself and NaN, and negative infinity is smaller than all values
except itself and NaN. NaN is "unordered": it is not equal to, greater
than, or less than anything, _including itself_.  'x == x' is false if
the value of 'x' is NaN. You can use this to test whether a value is NaN
or not, but the recommended way to test for NaN is with the 'isnan'
function (*note Floating Point Classes::).  In addition, '<', '>', '<=',
and '>=' will raise an exception when applied to NaNs.

   'math.h' defines macros that allow you to explicitly set a variable
to infinity or NaN.

 -- Macro: float INFINITY

     An expression representing positive infinity.  It is equal to the
     value produced by mathematical operations like '1.0 / 0.0'.
     '-INFINITY' represents negative infinity.

     You can test whether a floating-point value is infinite by
     comparing it to this macro.  However, this is not recommended; you
     should use the 'isfinite' macro instead.  *Note Floating Point
     Classes::.

     This macro was introduced in the ISO C99 standard.

 -- Macro: float NAN

     An expression representing a value which is "not a number".  This
     macro is a GNU extension, available only on machines that support
     the "not a number" value--that is to say, on all machines that
     support IEEE floating point.

     You can use '#ifdef NAN' to test whether the machine supports NaN.
     (Of course, you must arrange for GNU extensions to be visible, such
     as by defining '_GNU_SOURCE', and then you must include 'math.h'.)

 -- Macro: float SNANF
 -- Macro: double SNAN
 -- Macro: long double SNANL
 -- Macro: _FloatN SNANFN
 -- Macro: _FloatNx SNANFNx

     These macros, defined by TS 18661-1:2014 and TS 18661-3:2015, are
     constant expressions for signaling NaNs.

 -- Macro: int FE_SNANS_ALWAYS_SIGNAL

     This macro, defined by TS 18661-1:2014, is defined to '1' in
     'fenv.h' to indicate that functions and operations with signaling
     NaN inputs and floating-point results always raise the invalid
     exception and return a quiet NaN, even in cases (such as 'fmax',
     'hypot' and 'pow') where a quiet NaN input can produce a non-NaN
     result.  Because some compiler optimizations may not handle
     signaling NaNs correctly, this macro is only defined if compiler
     support for signaling NaNs is enabled.  That support can be enabled
     with the GCC option '-fsignaling-nans'.

   IEEE 754 also allows for another unusual value: negative zero.  This
value is produced when you divide a positive number by negative
infinity, or when a negative result is smaller than the limits of
representation.

==============================================================================
File: libc.info,  Node: |Status_bit_operations|,  Next: |Math_Error_Reporting|,  Prev: |Infinity_and_NaN|,  Up: |Floating_Point_Errors|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Status_bit_operations*

20.5.3 Examining the FPU status word
------------------------------------

ISO C99 defines functions to query and manipulate the floating-point
status word.  You can use these functions to check for untrapped
exceptions when it's convenient, rather than worrying about them in the
middle of a calculation.

   These constants represent the various IEEE 754 exceptions.  Not all
FPUs report all the different exceptions.  Each constant is defined if
and only if the FPU you are compiling for supports that exception, so
you can test for FPU support with '#ifdef'.  They are defined in
'fenv.h'.

'FE_INEXACT'

     The inexact exception.
'FE_DIVBYZERO'

     The divide by zero exception.
'FE_UNDERFLOW'

     The underflow exception.
'FE_OVERFLOW'

     The overflow exception.
'FE_INVALID'

     The invalid exception.

   The macro 'FE_ALL_EXCEPT' is the bitwise OR of all exception macros
which are supported by the FP implementation.

   These functions allow you to clear exception flags, test for
exceptions, and save and restore the set of exceptions flagged.

 -- Function: int feclearexcept (int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe !posix | AC-Safe !posix | *Note
     POSIX Safety Concepts::.

     This function clears all of the supported exception flags indicated
     by EXCEPTS.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int feraiseexcept (int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function raises the supported exceptions indicated by EXCEPTS.
     If more than one exception bit in EXCEPTS is set the order in which
     the exceptions are raised is undefined except that overflow
     ('FE_OVERFLOW') or underflow ('FE_UNDERFLOW') are raised before
     inexact ('FE_INEXACT').  Whether for overflow or underflow the
     inexact exception is also raised is also implementation dependent.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int fesetexcept (int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function sets the supported exception flags indicated by
     EXCEPTS, like 'feraiseexcept', but without causing enabled traps to
     be taken.  'fesetexcept' is from TS 18661-1:2014.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int fetestexcept (int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Test whether the exception flags indicated by the parameter EXCEPT
     are currently set.  If any of them are, a nonzero value is returned
     which specifies which exceptions are set.  Otherwise the result is
     zero.

   To understand these functions, imagine that the status word is an
integer variable named STATUS.  'feclearexcept' is then equivalent to
'status &= ~excepts' and 'fetestexcept' is equivalent to '(status &
excepts)'.  The actual implementation may be very different, of course.

   Exception flags are only cleared when the program explicitly requests
it, by calling 'feclearexcept'.  If you want to check for exceptions
from a set of calculations, you should clear all the flags first.  Here
is a simple example of the way to use 'fetestexcept':

     {
       double f;
       int raised;
       feclearexcept (FE_ALL_EXCEPT);
       f = compute ();
       raised = fetestexcept (FE_OVERFLOW | FE_INVALID);
       if (raised & FE_OVERFLOW) { /* ... */ }
       if (raised & FE_INVALID) { /* ... */ }
       /* ... */
     }

   You cannot explicitly set bits in the status word.  You can, however,
save the entire status word and restore it later.  This is done with the
following functions:

 -- Function: int fegetexceptflag (fexcept_t *FLAGP, int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function stores in the variable pointed to by FLAGP an
     implementation-defined value representing the current setting of
     the exception flags indicated by EXCEPTS.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int fesetexceptflag (const fexcept_t *FLAGP, int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function restores the flags for the exceptions indicated by
     EXCEPTS to the values stored in the variable pointed to by FLAGP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

   Note that the value stored in 'fexcept_t' bears no resemblance to the
bit mask returned by 'fetestexcept'.  The type may not even be an
integer.  Do not attempt to modify an 'fexcept_t' variable.

 -- Function: int fetestexceptflag (const fexcept_t *FLAGP, int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Test whether the exception flags indicated by the parameter EXCEPTS
     are set in the variable pointed to by FLAGP.  If any of them are, a
     nonzero value is returned which specifies which exceptions are set.
     Otherwise the result is zero.  'fetestexceptflag' is from TS
     18661-1:2014.

==============================================================================
File: libc.info,  Node: |Math_Error_Reporting|,  Prev: |Status_bit_operations|,  Up: |Floating_Point_Errors|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Math_Error_Reporting*

20.5.4 Error Reporting by Mathematical Functions
------------------------------------------------

Many of the math functions are defined only over a subset of the real or
complex numbers.  Even if they are mathematically defined, their result
may be larger or smaller than the range representable by their return
type without loss of accuracy.  These are known as "domain errors",
"overflows", and "underflows", respectively.  Math functions do several
things when one of these errors occurs.  In this manual we will refer to
the complete response as "signalling" a domain error, overflow, or
underflow.

   When a math function suffers a domain error, it raises the invalid
exception and returns NaN. It also sets ERRNO to 'EDOM'; this is for
compatibility with old systems that do not support IEEE 754 exception
handling.  Likewise, when overflow occurs, math functions raise the
overflow exception and, in the default rounding mode, return oo or -oo
as appropriate (in other rounding modes, the largest finite value of the
appropriate sign is returned when appropriate for that rounding mode).
They also set ERRNO to 'ERANGE' if returning oo or -oo; ERRNO may or may
not be set to 'ERANGE' when a finite value is returned on overflow.
When underflow occurs, the underflow exception is raised, and zero
(appropriately signed) or a subnormal value, as appropriate for the
mathematical result of the function and the rounding mode, is returned.
ERRNO may be set to 'ERANGE', but this is not guaranteed; it is intended
that the GNU C Library should set it when the underflow is to an
appropriately signed zero, but not necessarily for other underflows.

   When a math function has an argument that is a signaling NaN, the GNU
C Library does not consider this a domain error, so 'errno' is
unchanged, but the invalid exception is still raised (except for a few
functions that are specified to handle signaling NaNs differently).

   Some of the math functions are defined mathematically to result in a
complex value over parts of their domains.  The most familiar example of
this is taking the square root of a negative number.  The complex math
functions, such as 'csqrt', will return the appropriate complex value in
this case.  The real-valued functions, such as 'sqrt', will signal a
domain error.

   Some older hardware does not support infinities.  On that hardware,
overflows instead return a particular very large number (usually the
largest representable number).  'math.h' defines macros you can use to
test for overflow on both old and new hardware.

 -- Macro: double HUGE_VAL
 -- Macro: float HUGE_VALF
 -- Macro: long double HUGE_VALL
 -- Macro: _FloatN HUGE_VAL_FN
 -- Macro: _FloatNx HUGE_VAL_FNx

     An expression representing a particular very large number.  On
     machines that use IEEE 754 floating point format, 'HUGE_VAL' is
     infinity.  On other machines, it's typically the largest positive
     number that can be represented.

     Mathematical functions return the appropriately typed version of
     'HUGE_VAL' or '-HUGE_VAL' when the result is too large to be
     represented.

==============================================================================
File: libc.info,  Node: |Rounding|,  Next: |Control_Functions|,  Prev: |Floating_Point_Errors|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Rounding*

20.6 Rounding Modes
-------------------

Floating-point calculations are carried out internally with extra
precision, and then rounded to fit into the destination type.  This
ensures that results are as precise as the input data.  IEEE 754 defines
four possible rounding modes:

Round to nearest.
     This is the default mode.  It should be used unless there is a
     specific need for one of the others.  In this mode results are
     rounded to the nearest representable value.  If the result is
     midway between two representable values, the even representable is
     chosen.  "Even" here means the lowest-order bit is zero.  This
     rounding mode prevents statistical bias and guarantees numeric
     stability: round-off errors in a lengthy calculation will remain
     smaller than half of 'FLT_EPSILON'.

Round toward plus Infinity.
     All results are rounded to the smallest representable value which
     is greater than the result.

Round toward minus Infinity.
     All results are rounded to the largest representable value which is
     less than the result.

Round toward zero.
     All results are rounded to the largest representable value whose
     magnitude is less than that of the result.  In other words, if the
     result is negative it is rounded up; if it is positive, it is
     rounded down.

'fenv.h' defines constants which you can use to refer to the various
rounding modes.  Each one will be defined if and only if the FPU
supports the corresponding rounding mode.

'FE_TONEAREST'

     Round to nearest.

'FE_UPWARD'

     Round toward +oo.

'FE_DOWNWARD'

     Round toward -oo.

'FE_TOWARDZERO'

     Round toward zero.

   Underflow is an unusual case.  Normally, IEEE 754 floating point
numbers are always normalized (*note Floating Point Concepts::).
Numbers smaller than 2^r (where r is the minimum exponent,
'FLT_MIN_RADIX-1' for FLOAT) cannot be represented as normalized
numbers.  Rounding all such numbers to zero or 2^r would cause some
algorithms to fail at 0.  Therefore, they are left in denormalized form.
That produces loss of precision, since some bits of the mantissa are
stolen to indicate the decimal point.

   If a result is too small to be represented as a denormalized number,
it is rounded to zero.  However, the sign of the result is preserved; if
the calculation was negative, the result is "negative zero".  Negative
zero can also result from some operations on infinity, such as 4/-oo.

   At any time, one of the above four rounding modes is selected.  You
can find out which one with this function:

 -- Function: int fegetround (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns the currently selected rounding mode, represented by one of
     the values of the defined rounding mode macros.

To change the rounding mode, use this function:

 -- Function: int fesetround (int ROUND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Changes the currently selected rounding mode to ROUND.  If ROUND
     does not correspond to one of the supported rounding modes nothing
     is changed.  'fesetround' returns zero if it changed the rounding
     mode, or a nonzero value if the mode is not supported.

   You should avoid changing the rounding mode if possible.  It can be
an expensive operation; also, some hardware requires you to compile your
program differently for it to work.  The resulting code may run slower.
See your compiler documentation for details.

==============================================================================
File: libc.info,  Node: |Control_Functions|,  Next: |Arithmetic_Functions|,  Prev: |Rounding|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Control_Functions*

20.7 Floating-Point Control Functions
-------------------------------------

IEEE 754 floating-point implementations allow the programmer to decide
whether traps will occur for each of the exceptions, by setting bits in
the "control word".  In C, traps result in the program receiving the
'SIGFPE' signal; see *note Signal Handling::.

   NB: IEEE 754 says that trap handlers are given details of the
exceptional situation, and can set the result value.  C signals do not
provide any mechanism to pass this information back and forth.  Trapping
exceptions in C is therefore not very useful.

   It is sometimes necessary to save the state of the floating-point
unit while you perform some calculation.  The library provides functions
which save and restore the exception flags, the set of exceptions that
generate traps, and the rounding mode.  This information is known as the
"floating-point environment".

   The functions to save and restore the floating-point environment all
use a variable of type 'fenv_t' to store information.  This type is
defined in 'fenv.h'.  Its size and contents are implementation-defined.
You should not attempt to manipulate a variable of this type directly.

   To save the state of the FPU, use one of these functions:

 -- Function: int fegetenv (fenv_t *ENVP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Store the floating-point environment in the variable pointed to by
     ENVP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int feholdexcept (fenv_t *ENVP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Store the current floating-point environment in the object pointed
     to by ENVP.  Then clear all exception flags, and set the FPU to
     trap no exceptions.  Not all FPUs support trapping no exceptions;
     if 'feholdexcept' cannot set this mode, it returns nonzero value.
     If it succeeds, it returns zero.

   The functions which restore the floating-point environment can take
these kinds of arguments:

   * Pointers to 'fenv_t' objects, which were initialized previously by
     a call to 'fegetenv' or 'feholdexcept'.
   * The special macro 'FE_DFL_ENV' which represents the floating-point
     environment as it was available at program start.
   * Implementation defined macros with names starting with 'FE_' and
     having type 'fenv_t *'.

     If possible, the GNU C Library defines a macro 'FE_NOMASK_ENV'
     which represents an environment where every exception raised causes
     a trap to occur.  You can test for this macro using '#ifdef'.  It
     is only defined if '_GNU_SOURCE' is defined.

     Some platforms might define other predefined environments.

To set the floating-point environment, you can use either of these
functions:

 -- Function: int fesetenv (const fenv_t *ENVP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Set the floating-point environment to that described by ENVP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int feupdateenv (const fenv_t *ENVP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Like 'fesetenv', this function sets the floating-point environment
     to that described by ENVP.  However, if any exceptions were flagged
     in the status word before 'feupdateenv' was called, they remain
     flagged after the call.  In other words, after 'feupdateenv' is
     called, the status word is the bitwise OR of the previous status
     word and the one saved in ENVP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

TS 18661-1:2014 defines additional functions to save and restore
floating-point control modes (such as the rounding mode and whether
traps are enabled) while leaving other status (such as raised flags)
unchanged.

   The special macro 'FE_DFL_MODE' may be passed to 'fesetmode'.  It
represents the floating-point control modes at program start.

 -- Function: int fegetmode (femode_t *MODEP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Store the floating-point control modes in the variable pointed to
     by MODEP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

 -- Function: int fesetmode (const femode_t *MODEP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Set the floating-point control modes to those described by MODEP.

     The function returns zero in case the operation was successful, a
     non-zero value otherwise.

To control for individual exceptions if raising them causes a trap to
occur, you can use the following two functions.

   *Portability Note:* These functions are all GNU extensions.

 -- Function: int feenableexcept (int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function enables traps for each of the exceptions as indicated
     by the parameter EXCEPTS.  The individual exceptions are described
     in *note Status bit operations::.  Only the specified exceptions
     are enabled, the status of the other exceptions is not changed.

     The function returns the previous enabled exceptions in case the
     operation was successful, '-1' otherwise.

 -- Function: int fedisableexcept (int EXCEPTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function disables traps for each of the exceptions as
     indicated by the parameter EXCEPTS.  The individual exceptions are
     described in *note Status bit operations::.  Only the specified
     exceptions are disabled, the status of the other exceptions is not
     changed.

     The function returns the previous enabled exceptions in case the
     operation was successful, '-1' otherwise.

 -- Function: int fegetexcept (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function returns a bitmask of all currently enabled exceptions.
     It returns '-1' in case of failure.

==============================================================================
File: libc.info,  Node: |Arithmetic_Functions|,  Next: |Complex_Numbers|,  Prev: |Control_Functions|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Arithmetic_Functions*

20.8 Arithmetic Functions
-------------------------

The C library provides functions to do basic operations on
floating-point numbers.  These include absolute value, maximum and
minimum, normalization, bit twiddling, rounding, and a few others.

MENU

* |Absolute_Value|::              Absolute values of integers and floats.
* |Normalization_Functions|::     Extracting exponents and putting them back.
* |Rounding_Functions|::          Rounding floats to integers.
* |Remainder_Functions|::         Remainders on division, precisely defined.
* |FP_Bit_Twiddling|::            Sign bit adjustment.  Adding epsilon.
* |FP_Comparison_Functions|::     Comparisons without risk of exceptions.
* |Misc_FP_Arithmetic|::          Max, min, positive difference, multiply-add.

==============================================================================
File: libc.info,  Node: |Absolute_Value|,  Next: |Normalization_Functions|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Absolute_Value*

20.8.1 Absolute Value
---------------------

These functions are provided for obtaining the "absolute value" (or
"magnitude") of a number.  The absolute value of a real number X is X if
X is positive, -X if X is negative.  For a complex number Z, whose real
part is X and whose imaginary part is Y, the absolute value is
'sqrt (X*X + Y*Y)'.

   Prototypes for 'abs', 'labs' and 'llabs' are in 'stdlib.h'; 'imaxabs'
is declared in 'inttypes.h'; the 'fabs' functions are declared in
'math.h'; the 'cabs' functions are declared in 'complex.h'.

 -- Function: int abs (int NUMBER)
 -- Function: long int labs (long int NUMBER)
 -- Function: long long int llabs (long long int NUMBER)
 -- Function: intmax_t imaxabs (intmax_t NUMBER)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the absolute value of NUMBER.

     Most computers use a two's complement integer representation, in
     which the absolute value of 'INT_MIN' (the smallest possible 'int')
     cannot be represented; thus, 'abs (INT_MIN)' is not defined.

     'llabs' and 'imaxdiv' are new to ISO C99.

     See *note Integers:: for a description of the 'intmax_t' type.

 -- Function: double fabs (double NUMBER)
 -- Function: float fabsf (float NUMBER)
 -- Function: long double fabsl (long double NUMBER)
 -- Function: _FloatN fabsfN (_FloatN NUMBER)
 -- Function: _FloatNx fabsfNx (_FloatNx NUMBER)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns the absolute value of the floating-point
     number NUMBER.

 -- Function: double cabs (complex double Z)
 -- Function: float cabsf (complex float Z)
 -- Function: long double cabsl (complex long double Z)
 -- Function: _FloatN cabsfN (complex _FloatN Z)
 -- Function: _FloatNx cabsfNx (complex _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the absolute value of the complex number Z
     (*note Complex Numbers::).  The absolute value of a complex number
     is:

          sqrt (creal (Z) * creal (Z) + cimag (Z) * cimag (Z))

     This function should always be used instead of the direct formula
     because it takes special care to avoid losing precision.  It may
     also take advantage of hardware support for this operation.  See
     'hypot' in *note Exponents and Logarithms::.

==============================================================================
File: libc.info,  Node: |Normalization_Functions|,  Next: |Rounding_Functions|,  Prev: |Absolute_Value|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Normalization_Functions*

20.8.2 Normalization Functions
------------------------------

The functions described in this section are primarily provided as a way
to efficiently perform certain low-level manipulations on floating point
numbers that are represented internally using a binary radix; see *note
Floating Point Concepts::.  These functions are required to have
equivalent behavior even if the representation does not use a radix of
2, but of course they are unlikely to be particularly efficient in those
cases.

   All these functions are declared in 'math.h'.

 -- Function: double frexp (double VALUE, int *EXPONENT)
 -- Function: float frexpf (float VALUE, int *EXPONENT)
 -- Function: long double frexpl (long double VALUE, int *EXPONENT)
 -- Function: _FloatN frexpfN (_FloatN VALUE, int *EXPONENT)
 -- Function: _FloatNx frexpfNx (_FloatNx VALUE, int *EXPONENT)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are used to split the number VALUE into a
     normalized fraction and an exponent.

     If the argument VALUE is not zero, the return value is VALUE times
     a power of two, and its magnitude is always in the range 1/2
     (inclusive) to 1 (exclusive).  The corresponding exponent is stored
     in '*EXPONENT'; the return value multiplied by 2 raised to this
     exponent equals the original number VALUE.

     For example, 'frexp (12.8, &exponent)' returns '0.8' and stores '4'
     in 'exponent'.

     If VALUE is zero, then the return value is zero and zero is stored
     in '*EXPONENT'.

 -- Function: double ldexp (double VALUE, int EXPONENT)
 -- Function: float ldexpf (float VALUE, int EXPONENT)
 -- Function: long double ldexpl (long double VALUE, int EXPONENT)
 -- Function: _FloatN ldexpfN (_FloatN VALUE, int EXPONENT)
 -- Function: _FloatNx ldexpfNx (_FloatNx VALUE, int EXPONENT)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the result of multiplying the floating-point
     number VALUE by 2 raised to the power EXPONENT.  (It can be used to
     reassemble floating-point numbers that were taken apart by
     'frexp'.)

     For example, 'ldexp (0.8, 4)' returns '12.8'.

   The following functions, which come from BSD, provide facilities
equivalent to those of 'ldexp' and 'frexp'.  See also the ISO C function
'logb' which originally also appeared in BSD. The '_FloatN' and
'_FloatN' variants of the following functions come from TS 18661-3:2015.

 -- Function: double scalb (double VALUE, double EXPONENT)
 -- Function: float scalbf (float VALUE, float EXPONENT)
 -- Function: long double scalbl (long double VALUE, long double
          EXPONENT)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'scalb' function is the BSD name for 'ldexp'.

 -- Function: double scalbn (double X, int N)
 -- Function: float scalbnf (float X, int N)
 -- Function: long double scalbnl (long double X, int N)
 -- Function: _FloatN scalbnfN (_FloatN X, int N)
 -- Function: _FloatNx scalbnfNx (_FloatNx X, int N)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'scalbn' is identical to 'scalb', except that the exponent N is an
     'int' instead of a floating-point number.

 -- Function: double scalbln (double X, long int N)
 -- Function: float scalblnf (float X, long int N)
 -- Function: long double scalblnl (long double X, long int N)
 -- Function: _FloatN scalblnfN (_FloatN X, long int N)
 -- Function: _FloatNx scalblnfNx (_FloatNx X, long int N)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'scalbln' is identical to 'scalb', except that the exponent N is a
     'long int' instead of a floating-point number.

 -- Function: double significand (double X)
 -- Function: float significandf (float X)
 -- Function: long double significandl (long double X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'significand' returns the mantissa of X scaled to the range [1, 2).
     It is equivalent to 'scalb (X, (double) -ilogb (X))'.

     This function exists mainly for use in certain standardized tests
     of IEEE 754 conformance.

==============================================================================
File: libc.info,  Node: |Rounding_Functions|,  Next: |Remainder_Functions|,  Prev: |Normalization_Functions|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Rounding_Functions*

20.8.3 Rounding Functions
-------------------------

The functions listed here perform operations such as rounding and
truncation of floating-point values.  Some of these functions convert
floating point numbers to integer values.  They are all declared in
'math.h'.

   You can also convert floating-point numbers to integers simply by
casting them to 'int'.  This discards the fractional part, effectively
rounding towards zero.  However, this only works if the result can
actually be represented as an 'int'--for very large numbers, this is
impossible.  The functions listed here return the result as a 'double'
instead to get around this problem.

   The 'fromfp' functions use the following macros, from TS
18661-1:2014, to specify the direction of rounding.  These correspond to
the rounding directions defined in IEEE 754-2008.

'FP_INT_UPWARD'

     Round toward +oo.

'FP_INT_DOWNWARD'

     Round toward -oo.

'FP_INT_TOWARDZERO'

     Round toward zero.

'FP_INT_TONEARESTFROMZERO'

     Round to nearest, ties round away from zero.

'FP_INT_TONEAREST'

     Round to nearest, ties round to even.

 -- Function: double ceil (double X)
 -- Function: float ceilf (float X)
 -- Function: long double ceill (long double X)
 -- Function: _FloatN ceilfN (_FloatN X)
 -- Function: _FloatNx ceilfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions round X upwards to the nearest integer, returning
     that value as a 'double'.  Thus, 'ceil (1.5)' is '2.0'.

 -- Function: double floor (double X)
 -- Function: float floorf (float X)
 -- Function: long double floorl (long double X)
 -- Function: _FloatN floorfN (_FloatN X)
 -- Function: _FloatNx floorfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions round X downwards to the nearest integer, returning
     that value as a 'double'.  Thus, 'floor (1.5)' is '1.0' and 'floor
     (-1.5)' is '-2.0'.

 -- Function: double trunc (double X)
 -- Function: float truncf (float X)
 -- Function: long double truncl (long double X)
 -- Function: _FloatN truncfN (_FloatN X)
 -- Function: _FloatNx truncfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'trunc' functions round X towards zero to the nearest integer
     (returned in floating-point format).  Thus, 'trunc (1.5)' is '1.0'
     and 'trunc (-1.5)' is '-1.0'.

 -- Function: double rint (double X)
 -- Function: float rintf (float X)
 -- Function: long double rintl (long double X)
 -- Function: _FloatN rintfN (_FloatN X)
 -- Function: _FloatNx rintfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions round X to an integer value according to the
     current rounding mode.  *Note Floating Point Parameters::, for
     information about the various rounding modes.  The default rounding
     mode is to round to the nearest integer; some machines support
     other modes, but round-to-nearest is always used unless you
     explicitly select another.

     If X was not initially an integer, these functions raise the
     inexact exception.

 -- Function: double nearbyint (double X)
 -- Function: float nearbyintf (float X)
 -- Function: long double nearbyintl (long double X)
 -- Function: _FloatN nearbyintfN (_FloatN X)
 -- Function: _FloatNx nearbyintfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the same value as the 'rint' functions, but
     do not raise the inexact exception if X is not an integer.

 -- Function: double round (double X)
 -- Function: float roundf (float X)
 -- Function: long double roundl (long double X)
 -- Function: _FloatN roundfN (_FloatN X)
 -- Function: _FloatNx roundfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are similar to 'rint', but they round halfway cases
     away from zero instead of to the nearest integer (or other current
     rounding mode).

 -- Function: double roundeven (double X)
 -- Function: float roundevenf (float X)
 -- Function: long double roundevenl (long double X)
 -- Function: _FloatN roundevenfN (_FloatN X)
 -- Function: _FloatNx roundevenfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, are
     similar to 'round', but they round halfway cases to even instead of
     away from zero.

 -- Function: long int lrint (double X)
 -- Function: long int lrintf (float X)
 -- Function: long int lrintl (long double X)
 -- Function: long int lrintfN (_FloatN X)
 -- Function: long int lrintfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are just like 'rint', but they return a 'long int'
     instead of a floating-point number.

 -- Function: long long int llrint (double X)
 -- Function: long long int llrintf (float X)
 -- Function: long long int llrintl (long double X)
 -- Function: long long int llrintfN (_FloatN X)
 -- Function: long long int llrintfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are just like 'rint', but they return a 'long long
     int' instead of a floating-point number.

 -- Function: long int lround (double X)
 -- Function: long int lroundf (float X)
 -- Function: long int lroundl (long double X)
 -- Function: long int lroundfN (_FloatN X)
 -- Function: long int lroundfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are just like 'round', but they return a 'long int'
     instead of a floating-point number.

 -- Function: long long int llround (double X)
 -- Function: long long int llroundf (float X)
 -- Function: long long int llroundl (long double X)
 -- Function: long long int llroundfN (_FloatN X)
 -- Function: long long int llroundfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are just like 'round', but they return a 'long long
     int' instead of a floating-point number.

 -- Function: intmax_t fromfp (double X, int ROUND, unsigned int WIDTH)
 -- Function: intmax_t fromfpf (float X, int ROUND, unsigned int WIDTH)
 -- Function: intmax_t fromfpl (long double X, int ROUND, unsigned int
          WIDTH)
 -- Function: intmax_t fromfpfN (_FloatN X, int ROUND, unsigned int
          WIDTH)
 -- Function: intmax_t fromfpfNx (_FloatNx X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfp (double X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpf (float X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpl (long double X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpfN (_FloatN X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpfNx (_FloatNx X, int ROUND, unsigned int
          WIDTH)
 -- Function: intmax_t fromfpx (double X, int ROUND, unsigned int WIDTH)
 -- Function: intmax_t fromfpxf (float X, int ROUND, unsigned int WIDTH)
 -- Function: intmax_t fromfpxl (long double X, int ROUND, unsigned int
          WIDTH)
 -- Function: intmax_t fromfpxfN (_FloatN X, int ROUND, unsigned int
          WIDTH)
 -- Function: intmax_t fromfpxfNx (_FloatNx X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpx (double X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpxf (float X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpxl (long double X, int ROUND, unsigned
          int WIDTH)
 -- Function: uintmax_t ufromfpxfN (_FloatN X, int ROUND, unsigned int
          WIDTH)
 -- Function: uintmax_t ufromfpxfNx (_FloatNx X, int ROUND, unsigned int
          WIDTH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, convert
     a floating-point number to an integer according to the rounding
     direction ROUND (one of the 'FP_INT_*' macros).  If the integer is
     outside the range of a signed or unsigned (depending on the return
     type of the function) type of width WIDTH bits (or outside the
     range of the return type, if WIDTH is larger), or if X is infinite
     or NaN, or if WIDTH is zero, a domain error occurs and an
     unspecified value is returned.  The functions with an 'x' in their
     names raise the inexact exception when a domain error does not
     occur and the argument is not an integer; the other functions do
     not raise the inexact exception.

 -- Function: double modf (double VALUE, double *INTEGER-PART)
 -- Function: float modff (float VALUE, float *INTEGER-PART)
 -- Function: long double modfl (long double VALUE, long double
          *INTEGER-PART)
 -- Function: _FloatN modffN (_FloatN VALUE, _FloatN *INTEGER-PART)
 -- Function: _FloatNx modffNx (_FloatNx VALUE, _FloatNx *INTEGER-PART)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions break the argument VALUE into an integer part and a
     fractional part (between '-1' and '1', exclusive).  Their sum
     equals VALUE.  Each of the parts has the same sign as VALUE, and
     the integer part is always rounded toward zero.

     'modf' stores the integer part in '*INTEGER-PART', and returns the
     fractional part.  For example, 'modf (2.5, &intpart)' returns '0.5'
     and stores '2.0' into 'intpart'.

==============================================================================
File: libc.info,  Node: |Remainder_Functions|,  Next: |FP_Bit_Twiddling|,  Prev: |Rounding_Functions|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Remainder_Functions*

20.8.4 Remainder Functions
--------------------------

The functions in this section compute the remainder on division of two
floating-point numbers.  Each is a little different; pick the one that
suits your problem.

 -- Function: double fmod (double NUMERATOR, double DENOMINATOR)
 -- Function: float fmodf (float NUMERATOR, float DENOMINATOR)
 -- Function: long double fmodl (long double NUMERATOR, long double
          DENOMINATOR)
 -- Function: _FloatN fmodfN (_FloatN NUMERATOR, _FloatN DENOMINATOR)
 -- Function: _FloatNx fmodfNx (_FloatNx NUMERATOR, _FloatNx
          DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions compute the remainder from the division of
     NUMERATOR by DENOMINATOR.  Specifically, the return value is
     'NUMERATOR - N * DENOMINATOR', where N is the quotient of NUMERATOR
     divided by DENOMINATOR, rounded towards zero to an integer.  Thus,
     'fmod (6.5, 2.3)' returns '1.9', which is '6.5' minus '4.6'.

     The result has the same sign as the NUMERATOR and has magnitude
     less than the magnitude of the DENOMINATOR.

     If DENOMINATOR is zero, 'fmod' signals a domain error.

 -- Function: double remainder (double NUMERATOR, double DENOMINATOR)
 -- Function: float remainderf (float NUMERATOR, float DENOMINATOR)
 -- Function: long double remainderl (long double NUMERATOR, long double
          DENOMINATOR)
 -- Function: _FloatN remainderfN (_FloatN NUMERATOR, _FloatN
          DENOMINATOR)
 -- Function: _FloatNx remainderfNx (_FloatNx NUMERATOR, _FloatNx
          DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are like 'fmod' except that they round the internal
     quotient N to the nearest integer instead of towards zero to an
     integer.  For example, 'remainder (6.5, 2.3)' returns '-0.4', which
     is '6.5' minus '6.9'.

     The absolute value of the result is less than or equal to half the
     absolute value of the DENOMINATOR.  The difference between 'fmod
     (NUMERATOR, DENOMINATOR)' and 'remainder (NUMERATOR, DENOMINATOR)'
     is always either DENOMINATOR, minus DENOMINATOR, or zero.

     If DENOMINATOR is zero, 'remainder' signals a domain error.

 -- Function: double drem (double NUMERATOR, double DENOMINATOR)
 -- Function: float dremf (float NUMERATOR, float DENOMINATOR)
 -- Function: long double dreml (long double NUMERATOR, long double
          DENOMINATOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is another name for 'remainder'.

==============================================================================
File: libc.info,  Node: |FP_Bit_Twiddling|,  Next: |FP_Comparison_Functions|,  Prev: |Remainder_Functions|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *FP_Bit_Twiddling*

20.8.5 Setting and modifying single bits of FP values
-----------------------------------------------------

There are some operations that are too complicated or expensive to
perform by hand on floating-point numbers.  ISO C99 defines functions to
do these operations, which mostly involve changing single bits.

 -- Function: double copysign (double X, double Y)
 -- Function: float copysignf (float X, float Y)
 -- Function: long double copysignl (long double X, long double Y)
 -- Function: _FloatN copysignfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx copysignfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return X but with the sign of Y.  They work even if
     X or Y are NaN or zero.  Both of these can carry a sign (although
     not all implementations support it) and this is one of the few
     operations that can tell the difference.

     'copysign' never raises an exception.

     This function is defined in IEC 559 (and the appendix with
     recommended functions in IEEE 754/IEEE 854).

 -- Function: int signbit (_float-type_ X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'signbit' is a generic macro which can work on all floating-point
     types.  It returns a nonzero value if the value of X has its sign
     bit set.

     This is not the same as 'x < 0.0', because IEEE 754 floating point
     allows zero to be signed.  The comparison '-0.0 < 0.0' is false,
     but 'signbit (-0.0)' will return a nonzero value.

 -- Function: double nextafter (double X, double Y)
 -- Function: float nextafterf (float X, float Y)
 -- Function: long double nextafterl (long double X, long double Y)
 -- Function: _FloatN nextafterfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx nextafterfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'nextafter' function returns the next representable neighbor of
     X in the direction towards Y.  The size of the step between X and
     the result depends on the type of the result.  If X = Y the
     function simply returns Y.  If either value is 'NaN', 'NaN' is
     returned.  Otherwise a value corresponding to the value of the
     least significant bit in the mantissa is added or subtracted,
     depending on the direction.  'nextafter' will signal overflow or
     underflow if the result goes outside of the range of normalized
     numbers.

     This function is defined in IEC 559 (and the appendix with
     recommended functions in IEEE 754/IEEE 854).

 -- Function: double nexttoward (double X, long double Y)
 -- Function: float nexttowardf (float X, long double Y)
 -- Function: long double nexttowardl (long double X, long double Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions are identical to the corresponding versions of
     'nextafter' except that their second argument is a 'long double'.

 -- Function: double nextup (double X)
 -- Function: float nextupf (float X)
 -- Function: long double nextupl (long double X)
 -- Function: _FloatN nextupfN (_FloatN X)
 -- Function: _FloatNx nextupfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'nextup' function returns the next representable neighbor of X
     in the direction of positive infinity.  If X is the smallest
     negative subnormal number in the type of X the function returns
     '-0'.  If X = '0' the function returns the smallest positive
     subnormal number in the type of X.  If X is NaN, NaN is returned.
     If X is +oo, +oo is returned.  'nextup' is from TS 18661-1:2014 and
     TS 18661-3:2015.  'nextup' never raises an exception except for
     signaling NaNs.

 -- Function: double nextdown (double X)
 -- Function: float nextdownf (float X)
 -- Function: long double nextdownl (long double X)
 -- Function: _FloatN nextdownfN (_FloatN X)
 -- Function: _FloatNx nextdownfNx (_FloatNx X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'nextdown' function returns the next representable neighbor of
     X in the direction of negative infinity.  If X is the smallest
     positive subnormal number in the type of X the function returns
     '+0'.  If X = '0' the function returns the smallest negative
     subnormal number in the type of X.  If X is NaN, NaN is returned.
     If X is -oo, -oo is returned.  'nextdown' is from TS 18661-1:2014
     and TS 18661-3:2015.  'nextdown' never raises an exception except
     for signaling NaNs.

 -- Function: double nan (const char *TAGP)
 -- Function: float nanf (const char *TAGP)
 -- Function: long double nanl (const char *TAGP)
 -- Function: _FloatN nanfN (const char *TAGP)
 -- Function: _FloatNx nanfNx (const char *TAGP)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'nan' function returns a representation of NaN, provided that
     NaN is supported by the target platform.  'nan ("N-CHAR-SEQUENCE")'
     is equivalent to 'strtod ("NAN(N-CHAR-SEQUENCE)")'.

     The argument TAGP is used in an unspecified manner.  On IEEE 754
     systems, there are many representations of NaN, and TAGP selects
     one.  On other systems it may do nothing.

 -- Function: int canonicalize (double *CX, const double *X)
 -- Function: int canonicalizef (float *CX, const float *X)
 -- Function: int canonicalizel (long double *CX, const long double *X)
 -- Function: int canonicalizefN (_FloatN *CX, const _FloatN *X)
 -- Function: int canonicalizefNx (_FloatNx *CX, const _FloatNx *X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     In some floating-point formats, some values have canonical
     (preferred) and noncanonical encodings (for IEEE interchange binary
     formats, all encodings are canonical).  These functions, defined by
     TS 18661-1:2014 and TS 18661-3:2015, attempt to produce a canonical
     version of the floating-point value pointed to by X; if that value
     is a signaling NaN, they raise the invalid exception and produce a
     quiet NaN. If a canonical value is produced, it is stored in the
     object pointed to by CX, and these functions return zero.
     Otherwise (if a canonical value could not be produced because the
     object pointed to by X is not a valid representation of any
     floating-point value), the object pointed to by CX is unchanged and
     a nonzero value is returned.

     Note that some formats have multiple encodings of a value which are
     all equally canonical; when such an encoding is used as an input to
     this function, any such encoding of the same value (or of the
     corresponding quiet NaN, if that value is a signaling NaN) may be
     produced as output.

 -- Function: double getpayload (const double *X)
 -- Function: float getpayloadf (const float *X)
 -- Function: long double getpayloadl (const long double *X)
 -- Function: _FloatN getpayloadfN (const _FloatN *X)
 -- Function: _FloatNx getpayloadfNx (const _FloatNx *X)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     IEEE 754 defines the "payload" of a NaN to be an integer value
     encoded in the representation of the NaN. Payloads are typically
     propagated from NaN inputs to the result of a floating-point
     operation.  These functions, defined by TS 18661-1:2014 and TS
     18661-3:2015, return the payload of the NaN pointed to by X
     (returned as a positive integer, or positive zero, represented as a
     floating-point number); if X is not a NaN, they return an
     unspecified value.  They raise no floating-point exceptions even
     for signaling NaNs.

 -- Function: int setpayload (double *X, double PAYLOAD)
 -- Function: int setpayloadf (float *X, float PAYLOAD)
 -- Function: int setpayloadl (long double *X, long double PAYLOAD)
 -- Function: int setpayloadfN (_FloatN *X, _FloatN PAYLOAD)
 -- Function: int setpayloadfNx (_FloatNx *X, _FloatNx PAYLOAD)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, defined by TS 18661-1:2014 and TS 18661-3:2015,
     set the object pointed to by X to a quiet NaN with payload PAYLOAD
     and a zero sign bit and return zero.  If PAYLOAD is not a
     positive-signed integer that is a valid payload for a quiet NaN of
     the given type, the object pointed to by X is set to positive zero
     and a nonzero value is returned.  They raise no floating-point
     exceptions.

 -- Function: int setpayloadsig (double *X, double PAYLOAD)
 -- Function: int setpayloadsigf (float *X, float PAYLOAD)
 -- Function: int setpayloadsigl (long double *X, long double PAYLOAD)
 -- Function: int setpayloadsigfN (_FloatN *X, _FloatN PAYLOAD)
 -- Function: int setpayloadsigfNx (_FloatNx *X, _FloatNx PAYLOAD)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, defined by TS 18661-1:2014 and TS 18661-3:2015,
     set the object pointed to by X to a signaling NaN with payload
     PAYLOAD and a zero sign bit and return zero.  If PAYLOAD is not a
     positive-signed integer that is a valid payload for a signaling NaN
     of the given type, the object pointed to by X is set to positive
     zero and a nonzero value is returned.  They raise no floating-point
     exceptions.

==============================================================================
File: libc.info,  Node: |FP_Comparison_Functions|,  Next: |Misc_FP_Arithmetic|,  Prev: |FP_Bit_Twiddling|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *FP_Comparison_Functions*

20.8.6 Floating-Point Comparison Functions
------------------------------------------

The standard C comparison operators provoke exceptions when one or other
of the operands is NaN. For example,

     int v = a < 1.0;

will raise an exception if A is NaN. (This does _not_ happen with '=='
and '!='; those merely return false and true, respectively, when NaN is
examined.)  Frequently this exception is undesirable.  ISO C99 therefore
defines comparison functions that do not raise exceptions when NaN is
examined.  All of the functions are implemented as macros which allow
their arguments to be of any floating-point type.  The macros are
guaranteed to evaluate their arguments only once.  TS 18661-1:2014 adds
such a macro for an equality comparison that _does_ raise an exception
for a NaN argument; it also adds functions that provide a total ordering
on all floating-point values, including NaNs, without raising any
exceptions even for signaling NaNs.

 -- Macro: int isgreater (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether the argument X is greater than Y.  It
     is equivalent to '(X) > (Y)', but no exception is raised if X or Y
     are NaN.

 -- Macro: int isgreaterequal (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether the argument X is greater than or
     equal to Y.  It is equivalent to '(X) >= (Y)', but no exception is
     raised if X or Y are NaN.

 -- Macro: int isless (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether the argument X is less than Y.  It is
     equivalent to '(X) < (Y)', but no exception is raised if X or Y are
     NaN.

 -- Macro: int islessequal (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether the argument X is less than or equal
     to Y.  It is equivalent to '(X) <= (Y)', but no exception is raised
     if X or Y are NaN.

 -- Macro: int islessgreater (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether the argument X is less or greater
     than Y.  It is equivalent to '(X) < (Y) || (X) > (Y)' (although it
     only evaluates X and Y once), but no exception is raised if X or Y
     are NaN.

     This macro is not equivalent to 'X != Y', because that expression
     is true if X or Y are NaN.

 -- Macro: int isunordered (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether its arguments are unordered.  In
     other words, it is true if X or Y are NaN, and false otherwise.

 -- Macro: int iseqsig (_real-floating_ X, _real-floating_ Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro determines whether its arguments are equal.  It is
     equivalent to '(X) == (Y)', but it raises the invalid exception and
     sets 'errno' to 'EDOM' if either argument is a NaN.

 -- Function: int totalorder (double X, double Y)
 -- Function: int totalorderf (float X, float Y)
 -- Function: int totalorderl (long double X, long double Y)
 -- Function: int totalorderfN (_FloatN X, _FloatN Y)
 -- Function: int totalorderfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions determine whether the total order relationship,
     defined in IEEE 754-2008, is true for X and Y, returning nonzero if
     it is true and zero if it is false.  No exceptions are raised even
     for signaling NaNs.  The relationship is true if they are the same
     floating-point value (including sign for zero and NaNs, and payload
     for NaNs), or if X comes before Y in the following order: negative
     quiet NaNs, in order of decreasing payload; negative signaling
     NaNs, in order of decreasing payload; negative infinity; finite
     numbers, in ascending order, with negative zero before positive
     zero; positive infinity; positive signaling NaNs, in order of
     increasing payload; positive quiet NaNs, in order of increasing
     payload.

 -- Function: int totalordermag (double X, double Y)
 -- Function: int totalordermagf (float X, float Y)
 -- Function: int totalordermagl (long double X, long double Y)
 -- Function: int totalordermagfN (_FloatN X, _FloatN Y)
 -- Function: int totalordermagfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions determine whether the total order relationship,
     defined in IEEE 754-2008, is true for the absolute values of X and
     Y, returning nonzero if it is true and zero if it is false.  No
     exceptions are raised even for signaling NaNs.

   Not all machines provide hardware support for these operations.  On
machines that don't, the macros can be very slow.  Therefore, you should
not use these functions when NaN is not a concern.

   NB: There are no macros 'isequal' or 'isunequal'.  They are
unnecessary, because the '==' and '!=' operators do _not_ throw an
exception if one or both of the operands are NaN.

==============================================================================
File: libc.info,  Node: |Misc_FP_Arithmetic|,  Prev: |FP_Comparison_Functions|,  Up: |Arithmetic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Misc_FP_Arithmetic*

20.8.7 Miscellaneous FP arithmetic functions
--------------------------------------------

The functions in this section perform miscellaneous but common
operations that are awkward to express with C operators.  On some
processors these functions can use special machine instructions to
perform these operations faster than the equivalent C code.

 -- Function: double fmin (double X, double Y)
 -- Function: float fminf (float X, float Y)
 -- Function: long double fminl (long double X, long double Y)
 -- Function: _FloatN fminfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx fminfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'fmin' function returns the lesser of the two values X and Y.
     It is similar to the expression
          ((x) < (y) ? (x) : (y))
     except that X and Y are only evaluated once.

     If an argument is NaN, the other argument is returned.  If both
     arguments are NaN, NaN is returned.

 -- Function: double fmax (double X, double Y)
 -- Function: float fmaxf (float X, float Y)
 -- Function: long double fmaxl (long double X, long double Y)
 -- Function: _FloatN fmaxfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx fmaxfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'fmax' function returns the greater of the two values X and Y.

     If an argument is NaN, the other argument is returned.  If both
     arguments are NaN, NaN is returned.

 -- Function: double fminmag (double X, double Y)
 -- Function: float fminmagf (float X, float Y)
 -- Function: long double fminmagl (long double X, long double Y)
 -- Function: _FloatN fminmagfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx fminmagfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, return
     whichever of the two values X and Y has the smaller absolute value.
     If both have the same absolute value, or either is NaN, they behave
     the same as the 'fmin' functions.

 -- Function: double fmaxmag (double X, double Y)
 -- Function: float fmaxmagf (float X, float Y)
 -- Function: long double fmaxmagl (long double X, long double Y)
 -- Function: _FloatN fmaxmagfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx fmaxmagfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014, return whichever of the two
     values X and Y has the greater absolute value.  If both have the
     same absolute value, or either is NaN, they behave the same as the
     'fmax' functions.

 -- Function: double fdim (double X, double Y)
 -- Function: float fdimf (float X, float Y)
 -- Function: long double fdiml (long double X, long double Y)
 -- Function: _FloatN fdimfN (_FloatN X, _FloatN Y)
 -- Function: _FloatNx fdimfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'fdim' function returns the positive difference between X and
     Y.  The positive difference is X - Y if X is greater than Y, and 0
     otherwise.

     If X, Y, or both are NaN, NaN is returned.

 -- Function: double fma (double X, double Y, double Z)
 -- Function: float fmaf (float X, float Y, float Z)
 -- Function: long double fmal (long double X, long double Y, long
          double Z)
 -- Function: _FloatN fmafN (_FloatN X, _FloatN Y, _FloatN Z)
 -- Function: _FloatNx fmafNx (_FloatNx X, _FloatNx Y, _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'fma' function performs floating-point multiply-add.  This is
     the operation (X * Y) + Z, but the intermediate result is not
     rounded to the destination type.  This can sometimes improve the
     precision of a calculation.

     This function was introduced because some processors have a special
     instruction to perform multiply-add.  The C compiler cannot use it
     directly, because the expression 'x*y + z' is defined to round the
     intermediate result.  'fma' lets you choose when you want to round
     only once.

     On processors which do not implement multiply-add in hardware,
     'fma' can be very slow since it must avoid intermediate rounding.
     'math.h' defines the symbols 'FP_FAST_FMA', 'FP_FAST_FMAF', and
     'FP_FAST_FMAL' when the corresponding version of 'fma' is no slower
     than the expression 'x*y + z'.  In the GNU C Library, this always
     means the operation is implemented in hardware.

 -- Function: float fadd (double X, double Y)
 -- Function: float faddl (long double X, long double Y)
 -- Function: double daddl (long double X, long double Y)
 -- Function: _FloatM fMaddfN (_FloatN X, _FloatN Y)
 -- Function: _FloatM fMaddfNx (_FloatNx X, _FloatNx Y)
 -- Function: _FloatMx fMxaddfN (_FloatN X, _FloatN Y)
 -- Function: _FloatMx fMxaddfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, return X
     + Y, rounded once to the return type of the function without any
     intermediate rounding to the type of the arguments.

 -- Function: float fsub (double X, double Y)
 -- Function: float fsubl (long double X, long double Y)
 -- Function: double dsubl (long double X, long double Y)
 -- Function: _FloatM fMsubfN (_FloatN X, _FloatN Y)
 -- Function: _FloatM fMsubfNx (_FloatNx X, _FloatNx Y)
 -- Function: _FloatMx fMxsubfN (_FloatN X, _FloatN Y)
 -- Function: _FloatMx fMxsubfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, return X
     - Y, rounded once to the return type of the function without any
     intermediate rounding to the type of the arguments.

 -- Function: float fmul (double X, double Y)
 -- Function: float fmull (long double X, long double Y)
 -- Function: double dmull (long double X, long double Y)
 -- Function: _FloatM fMmulfN (_FloatN X, _FloatN Y)
 -- Function: _FloatM fMmulfNx (_FloatNx X, _FloatNx Y)
 -- Function: _FloatMx fMxmulfN (_FloatN X, _FloatN Y)
 -- Function: _FloatMx fMxmulfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, return X
     * Y, rounded once to the return type of the function without any
     intermediate rounding to the type of the arguments.

 -- Function: float fdiv (double X, double Y)
 -- Function: float fdivl (long double X, long double Y)
 -- Function: double ddivl (long double X, long double Y)
 -- Function: _FloatM fMdivfN (_FloatN X, _FloatN Y)
 -- Function: _FloatM fMdivfNx (_FloatNx X, _FloatNx Y)
 -- Function: _FloatMx fMxdivfN (_FloatN X, _FloatN Y)
 -- Function: _FloatMx fMxdivfNx (_FloatNx X, _FloatNx Y)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions, from TS 18661-1:2014 and TS 18661-3:2015, return X
     / Y, rounded once to the return type of the function without any
     intermediate rounding to the type of the arguments.

==============================================================================
File: libc.info,  Node: |Complex_Numbers|,  Next: |Operations_on_Complex|,  Prev: |Arithmetic_Functions|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Complex_Numbers*

20.9 Complex Numbers
--------------------

ISO C99 introduces support for complex numbers in C. This is done with a
new type qualifier, 'complex'.  It is a keyword if and only if
'complex.h' has been included.  There are three complex types,
corresponding to the three real types: 'float complex', 'double
complex', and 'long double complex'.

   Likewise, on machines that have support for '_FloatN' or '_FloatNx'
enabled, the complex types '_FloatN complex' and '_FloatNx complex' are
also available if 'complex.h' has been included; *note Mathematics::.

   To construct complex numbers you need a way to indicate the imaginary
part of a number.  There is no standard notation for an imaginary
floating point constant.  Instead, 'complex.h' defines two macros that
can be used to create complex numbers.

 -- Macro: const float complex _Complex_I

     This macro is a representation of the complex number "0+1i".
     Multiplying a real floating-point value by '_Complex_I' gives a
     complex number whose value is purely imaginary.  You can use this
     to construct complex constants:

          3.0 + 4.0i = 3.0 + 4.0 * _Complex_I

     Note that '_Complex_I * _Complex_I' has the value '-1', but the
     type of that value is 'complex'.

'_Complex_I' is a bit of a mouthful.  'complex.h' also defines a shorter
name for the same constant.

 -- Macro: const float complex I

     This macro has exactly the same value as '_Complex_I'.  Most of the
     time it is preferable.  However, it causes problems if you want to
     use the identifier 'I' for something else.  You can safely write

          #include <complex.h>
          #undef I

     if you need 'I' for your own purposes.  (In that case we recommend
     you also define some other short name for '_Complex_I', such as
     'J'.)

==============================================================================
File: libc.info,  Node: |Operations_on_Complex|,  Next: |Parsing_of_Numbers|,  Prev: |Complex_Numbers|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Operations_on_Complex*

20.10 Projections, Conjugates, and Decomposing of Complex Numbers
-----------------------------------------------------------------

ISO C99 also defines functions that perform basic operations on complex
numbers, such as decomposition and conjugation.  The prototypes for all
these functions are in 'complex.h'.  All functions are available in
three variants, one for each of the three complex types.

 -- Function: double creal (complex double Z)
 -- Function: float crealf (complex float Z)
 -- Function: long double creall (complex long double Z)
 -- Function: _FloatN crealfN (complex _FloatN Z)
 -- Function: _FloatNx crealfNx (complex _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the real part of the complex number Z.

 -- Function: double cimag (complex double Z)
 -- Function: float cimagf (complex float Z)
 -- Function: long double cimagl (complex long double Z)
 -- Function: _FloatN cimagfN (complex _FloatN Z)
 -- Function: _FloatNx cimagfNx (complex _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the imaginary part of the complex number Z.

 -- Function: complex double conj (complex double Z)
 -- Function: complex float conjf (complex float Z)
 -- Function: complex long double conjl (complex long double Z)
 -- Function: complex _FloatN conjfN (complex _FloatN Z)
 -- Function: complex _FloatNx conjfNx (complex _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the conjugate value of the complex number Z.
     The conjugate of a complex number has the same real part and a
     negated imaginary part.  In other words, 'conj(a + bi) = a + -bi'.

 -- Function: double carg (complex double Z)
 -- Function: float cargf (complex float Z)
 -- Function: long double cargl (complex long double Z)
 -- Function: _FloatN cargfN (complex _FloatN Z)
 -- Function: _FloatNx cargfNx (complex _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the argument of the complex number Z.  The
     argument of a complex number is the angle in the complex plane
     between the positive real axis and a line passing through zero and
     the number.  This angle is measured in the usual fashion and ranges
     from -pi to pi.

     'carg' has a branch cut along the negative real axis.

 -- Function: complex double cproj (complex double Z)
 -- Function: complex float cprojf (complex float Z)
 -- Function: complex long double cprojl (complex long double Z)
 -- Function: complex _FloatN cprojfN (complex _FloatN Z)
 -- Function: complex _FloatNx cprojfNx (complex _FloatNx Z)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     These functions return the projection of the complex value Z onto
     the Riemann sphere.  Values with an infinite imaginary part are
     projected to positive infinity on the real axis, even if the real
     part is NaN. If the real part is infinite, the result is equivalent
     to

          INFINITY + I * copysign (0.0, cimag (z))

==============================================================================
File: libc.info,  Node: |Parsing_of_Numbers|,  Next: |Printing_of_Floats|,  Prev: |Operations_on_Complex|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Parsing_of_Numbers*

20.11 Parsing of Numbers
------------------------

This section describes functions for "reading" integer and
floating-point numbers from a string.  It may be more convenient in some
cases to use 'sscanf' or one of the related functions; see *note
Formatted Input::.  But often you can make a program more robust by
finding the tokens in the string by hand, then converting the numbers
one by one.

MENU

* |Parsing_of_Integers|::         Functions for conversion of integer values.
* |Parsing_of_Floats|::           Functions for conversion of floating-point
				 values.

==============================================================================
File: libc.info,  Node: |Parsing_of_Integers|,  Next: |Parsing_of_Floats|,  Up: |Parsing_of_Numbers|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Parsing_of_Integers*

20.11.1 Parsing of Integers
---------------------------

The 'str' functions are declared in 'stdlib.h' and those beginning with
'wcs' are declared in 'wchar.h'.  One might wonder about the use of
'restrict' in the prototypes of the functions in this section.  It is
seemingly useless but the ISO C standard uses it (for the functions
defined there) so we have to do it as well.

 -- Function: long int strtol (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtol' ("string-to-long") function converts the initial part
     of STRING to a signed integer, which is returned as a value of type
     'long int'.

     This function attempts to decompose STRING as follows:

        * A (possibly empty) sequence of whitespace characters.  Which
          characters are whitespace is determined by the 'isspace'
          function (*note Classification of Characters::).  These are
          discarded.

        * An optional plus or minus sign ('+' or '-').

        * A nonempty sequence of digits in the radix specified by BASE.

          If BASE is zero, decimal radix is assumed unless the series of
          digits begins with '0' (specifying octal radix), or '0x' or
          '0X' (specifying hexadecimal radix); in other words, the same
          syntax used for integer constants in C.

          Otherwise BASE must have a value between '2' and '36'.  If
          BASE is '16', the digits may optionally be preceded by '0x' or
          '0X'.  If base has no legal value the value returned is '0l'
          and the global variable 'errno' is set to 'EINVAL'.

        * Any remaining characters in the string.  If TAILPTR is not a
          null pointer, 'strtol' stores a pointer to this tail in
          '*TAILPTR'.

     If the string is empty, contains only whitespace, or does not
     contain an initial substring that has the expected syntax for an
     integer in the specified BASE, no conversion is performed.  In this
     case, 'strtol' returns a value of zero and the value stored in
     '*TAILPTR' is the value of STRING.

     In a locale other than the standard '"C"' locale, this function may
     recognize additional implementation-dependent syntax.

     If the string has valid syntax for an integer but the value is not
     representable because of overflow, 'strtol' returns either
     'LONG_MAX' or 'LONG_MIN' (*note Range of Type::), as appropriate
     for the sign of the value.  It also sets 'errno' to 'ERANGE' to
     indicate there was overflow.

     You should not check for errors by examining the return value of
     'strtol', because the string might be a valid representation of
     '0l', 'LONG_MAX', or 'LONG_MIN'.  Instead, check whether TAILPTR
     points to what you expect after the number (e.g.  ''\0'' if the
     string should end after the number).  You also need to clear ERRNO
     before the call and check it afterward, in case there was overflow.

     There is an example at the end of this section.

 -- Function: long int wcstol (const wchar_t *restrict STRING, wchar_t
          **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstol' function is equivalent to the 'strtol' function in
     nearly all aspects but handles wide character strings.

     The 'wcstol' function was introduced in Amendment 1 of ISO C90.

 -- Function: unsigned long int strtoul (const char *restrict STRING,
          char **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtoul' ("string-to-unsigned-long") function is like 'strtol'
     except it converts to an 'unsigned long int' value.  The syntax is
     the same as described above for 'strtol'.  The value returned on
     overflow is 'ULONG_MAX' (*note Range of Type::).

     If STRING depicts a negative number, 'strtoul' acts the same as
     STRTOL but casts the result to an unsigned integer.  That means for
     example that 'strtoul' on '"-1"' returns 'ULONG_MAX' and an input
     more negative than 'LONG_MIN' returns ('ULONG_MAX' + 1) / 2.

     'strtoul' sets ERRNO to 'EINVAL' if BASE is out of range, or
     'ERANGE' on overflow.

 -- Function: unsigned long int wcstoul (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstoul' function is equivalent to the 'strtoul' function in
     nearly all aspects but handles wide character strings.

     The 'wcstoul' function was introduced in Amendment 1 of ISO C90.

 -- Function: long long int strtoll (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtoll' function is like 'strtol' except that it returns a
     'long long int' value, and accepts numbers with a correspondingly
     larger range.

     If the string has valid syntax for an integer but the value is not
     representable because of overflow, 'strtoll' returns either
     'LLONG_MAX' or 'LLONG_MIN' (*note Range of Type::), as appropriate
     for the sign of the value.  It also sets 'errno' to 'ERANGE' to
     indicate there was overflow.

     The 'strtoll' function was introduced in ISO C99.

 -- Function: long long int wcstoll (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstoll' function is equivalent to the 'strtoll' function in
     nearly all aspects but handles wide character strings.

     The 'wcstoll' function was introduced in Amendment 1 of ISO C90.

 -- Function: long long int strtoq (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     'strtoq' ("string-to-quad-word") is the BSD name for 'strtoll'.

 -- Function: long long int wcstoq (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstoq' function is equivalent to the 'strtoq' function in
     nearly all aspects but handles wide character strings.

     The 'wcstoq' function is a GNU extension.

 -- Function: unsigned long long int strtoull (const char *restrict
          STRING, char **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtoull' function is related to 'strtoll' the same way
     'strtoul' is related to 'strtol'.

     The 'strtoull' function was introduced in ISO C99.

 -- Function: unsigned long long int wcstoull (const wchar_t *restrict
          STRING, wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstoull' function is equivalent to the 'strtoull' function in
     nearly all aspects but handles wide character strings.

     The 'wcstoull' function was introduced in Amendment 1 of ISO C90.

 -- Function: unsigned long long int strtouq (const char *restrict
          STRING, char **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     'strtouq' is the BSD name for 'strtoull'.

 -- Function: unsigned long long int wcstouq (const wchar_t *restrict
          STRING, wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstouq' function is equivalent to the 'strtouq' function in
     nearly all aspects but handles wide character strings.

     The 'wcstouq' function is a GNU extension.

 -- Function: intmax_t strtoimax (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtoimax' function is like 'strtol' except that it returns a
     'intmax_t' value, and accepts numbers of a corresponding range.

     If the string has valid syntax for an integer but the value is not
     representable because of overflow, 'strtoimax' returns either
     'INTMAX_MAX' or 'INTMAX_MIN' (*note Integers::), as appropriate for
     the sign of the value.  It also sets 'errno' to 'ERANGE' to
     indicate there was overflow.

     See *note Integers:: for a description of the 'intmax_t' type.  The
     'strtoimax' function was introduced in ISO C99.

 -- Function: intmax_t wcstoimax (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstoimax' function is equivalent to the 'strtoimax' function
     in nearly all aspects but handles wide character strings.

     The 'wcstoimax' function was introduced in ISO C99.

 -- Function: uintmax_t strtoumax (const char *restrict STRING, char
          **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtoumax' function is related to 'strtoimax' the same way
     that 'strtoul' is related to 'strtol'.

     See *note Integers:: for a description of the 'intmax_t' type.  The
     'strtoumax' function was introduced in ISO C99.

 -- Function: uintmax_t wcstoumax (const wchar_t *restrict STRING,
          wchar_t **restrict TAILPTR, int BASE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstoumax' function is equivalent to the 'strtoumax' function
     in nearly all aspects but handles wide character strings.

     The 'wcstoumax' function was introduced in ISO C99.

 -- Function: long int atol (const char *STRING)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is similar to the 'strtol' function with a BASE
     argument of '10', except that it need not detect overflow errors.
     The 'atol' function is provided mostly for compatibility with
     existing code; using 'strtol' is more robust.

 -- Function: int atoi (const char *STRING)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is like 'atol', except that it returns an 'int'.  The
     'atoi' function is also considered obsolete; use 'strtol' instead.

 -- Function: long long int atoll (const char *STRING)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is similar to 'atol', except it returns a 'long long
     int'.

     The 'atoll' function was introduced in ISO C99.  It too is obsolete
     (despite having just been added); use 'strtoll' instead.

   All the functions mentioned in this section so far do not handle
alternative representations of characters as described in the locale
data.  Some locales specify thousands separator and the way they have to
be used which can help to make large numbers more readable.  To read
such numbers one has to use the 'scanf' functions with the ''' flag.

   Here is a function which parses a string as a sequence of integers
and returns the sum of them:

     int
     sum_ints_from_string (char *string)
     {
       int sum = 0;

       while (1) {
         char *tail;
         int next;

         /* Skip whitespace by hand, to detect the end.  */
         while (isspace (*string)) string++;
         if (*string == 0)
           break;

         /* There is more nonwhitespace,  */
         /* so it ought to be another number.  */
         errno = 0;
         /* Parse it.  */
         next = strtol (string, &tail, 0);
         /* Add it in, if not overflow.  */
         if (errno)
           printf ("Overflow\n");
         else
           sum += next;
         /* Advance past it.  */
         string = tail;
       }

       return sum;
     }

==============================================================================
File: libc.info,  Node: |Parsing_of_Floats|,  Prev: |Parsing_of_Integers|,  Up: |Parsing_of_Numbers|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Parsing_of_Floats*

20.11.2 Parsing of Floats
-------------------------

The 'str' functions are declared in 'stdlib.h' and those beginning with
'wcs' are declared in 'wchar.h'.  One might wonder about the use of
'restrict' in the prototypes of the functions in this section.  It is
seemingly useless but the ISO C standard uses it (for the functions
defined there) so we have to do it as well.

 -- Function: double strtod (const char *restrict STRING, char
          **restrict TAILPTR)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'strtod' ("string-to-double") function converts the initial
     part of STRING to a floating-point number, which is returned as a
     value of type 'double'.

     This function attempts to decompose STRING as follows:

        * A (possibly empty) sequence of whitespace characters.  Which
          characters are whitespace is determined by the 'isspace'
          function (*note Classification of Characters::).  These are
          discarded.

        * An optional plus or minus sign ('+' or '-').

        * A floating point number in decimal or hexadecimal format.  The
          decimal format is:

             - A nonempty sequence of digits optionally containing a
               decimal-point character--normally '.', but it depends on
               the locale (*note General Numeric::).

             - An optional exponent part, consisting of a character 'e'
               or 'E', an optional sign, and a sequence of digits.

          The hexadecimal format is as follows:

             - A 0x or 0X followed by a nonempty sequence of hexadecimal
               digits optionally containing a decimal-point
               character--normally '.', but it depends on the locale
               (*note General Numeric::).

             - An optional binary-exponent part, consisting of a
               character 'p' or 'P', an optional sign, and a sequence of
               digits.

        * Any remaining characters in the string.  If TAILPTR is not a
          null pointer, a pointer to this tail of the string is stored
          in '*TAILPTR'.

     If the string is empty, contains only whitespace, or does not
     contain an initial substring that has the expected syntax for a
     floating-point number, no conversion is performed.  In this case,
     'strtod' returns a value of zero and the value returned in
     '*TAILPTR' is the value of STRING.

     In a locale other than the standard '"C"' or '"POSIX"' locales,
     this function may recognize additional locale-dependent syntax.

     If the string has valid syntax for a floating-point number but the
     value is outside the range of a 'double', 'strtod' will signal
     overflow or underflow as described in *note Math Error Reporting::.

     'strtod' recognizes four special input strings.  The strings
     '"inf"' and '"infinity"' are converted to oo, or to the largest
     representable value if the floating-point format doesn't support
     infinities.  You can prepend a '"+"' or '"-"' to specify the sign.
     Case is ignored when scanning these strings.

     The strings '"nan"' and '"nan(CHARS...)"' are converted to NaN.
     Again, case is ignored.  If CHARS... are provided, they are used in
     some unspecified fashion to select a particular representation of
     NaN (there can be several).

     Since zero is a valid result as well as the value returned on
     error, you should check for errors in the same way as for 'strtol',
     by examining ERRNO and TAILPTR.

 -- Function: float strtof (const char *STRING, char **TAILPTR)
 -- Function: long double strtold (const char *STRING, char **TAILPTR)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     These functions are analogous to 'strtod', but return 'float' and
     'long double' values respectively.  They report errors in the same
     way as 'strtod'.  'strtof' can be substantially faster than
     'strtod', but has less precision; conversely, 'strtold' can be much
     slower but has more precision (on systems where 'long double' is a
     separate type).

     These functions have been GNU extensions and are new to ISO C99.

 -- Function: _FloatN strtofN (const char *STRING, char **TAILPTR)
 -- Function: _FloatNx strtofNx (const char *STRING, char **TAILPTR)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     These functions are like 'strtod', except for the return type.

     They were introduced in ISO/IEC TS 18661-3 and are available on
     machines that support the related types; *note Mathematics::.

 -- Function: double wcstod (const wchar_t *restrict STRING, wchar_t
          **restrict TAILPTR)
 -- Function: float wcstof (const wchar_t *STRING, wchar_t **TAILPTR)
 -- Function: long double wcstold (const wchar_t *STRING, wchar_t
          **TAILPTR)
 -- Function: _FloatN wcstofN (const wchar_t *STRING, wchar_t **TAILPTR)
 -- Function: _FloatNx wcstofNx (const wchar_t *STRING, wchar_t
          **TAILPTR)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The 'wcstod', 'wcstof', 'wcstol', 'wcstofN', and 'wcstofNx'
     functions are equivalent in nearly all aspects to the 'strtod',
     'strtof', 'strtold', 'strtofN', and 'strtofNx' functions, but they
     handle wide character strings.

     The 'wcstod' function was introduced in Amendment 1 of ISO C90.
     The 'wcstof' and 'wcstold' functions were introduced in ISO C99.

     The 'wcstofN' and 'wcstofNx' functions are not in any standard, but
     are added to provide completeness for the non-deprecated interface
     of wide character string to floating-point conversion functions.
     They are only available on machines that support the related types;
     *note Mathematics::.

 -- Function: double atof (const char *STRING)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is similar to the 'strtod' function, except that it
     need not detect overflow and underflow errors.  The 'atof' function
     is provided mostly for compatibility with existing code; using
     'strtod' is more robust.

   The GNU C Library also provides '_l' versions of these functions,
which take an additional argument, the locale to use in conversion.

   See also *note Parsing of Integers::.

==============================================================================
File: libc.info,  Node: |Printing_of_Floats|,  Next: |System_V_Number_Conversion|,  Prev: |Parsing_of_Numbers|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Printing_of_Floats*

20.12 Printing of Floats
------------------------

The 'strfrom' functions are declared in 'stdlib.h'.

 -- Function: int strfromd (char *restrict STRING, size_t SIZE, const
          char *restrict FORMAT, double VALUE)
 -- Function: int strfromf (char *restrict STRING, size_t SIZE, const
          char *restrict FORMAT, float VALUE)
 -- Function: int strfroml (char *restrict STRING, size_t SIZE, const
          char *restrict FORMAT, long double VALUE)

     Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem |
     *Note POSIX Safety Concepts::.

     The functions 'strfromd' ("string-from-double"), 'strfromf'
     ("string-from-float"), and 'strfroml' ("string-from-long-double")
     convert the floating-point number VALUE to a string of characters
     and stores them into the area pointed to by STRING.  The conversion
     writes at most SIZE characters and respects the format specified by
     FORMAT.

     The format string must start with the character '%'.  An optional
     precision follows, which starts with a period, '.', and may be
     followed by a decimal integer, representing the precision.  If a
     decimal integer is not specified after the period, the precision is
     taken to be zero.  The character '*' is not allowed.  Finally, the
     format string ends with one of the following conversion specifiers:
     'a', 'A', 'e', 'E', 'f', 'F', 'g' or 'G' (*note Table of Output
     Conversions::).  Invalid format strings result in undefined
     behavior.

     These functions return the number of characters that would have
     been written to STRING had SIZE been sufficiently large, not
     counting the terminating null character.  Thus, the null-terminated
     output has been completely written if and only if the returned
     value is less than SIZE.

     These functions were introduced by ISO/IEC TS 18661-1.

 -- Function: int strfromfN (char *restrict STRING, size_t SIZE, const
          char *restrict FORMAT, _FloatN VALUE)
 -- Function: int strfromfNx (char *restrict STRING, size_t SIZE, const
          char *restrict FORMAT, _FloatNx VALUE)

     Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem |
     *Note POSIX Safety Concepts::.

     These functions are like 'strfromd', except for the type of
     'value'.

     They were introduced in ISO/IEC TS 18661-3 and are available on
     machines that support the related types; *note Mathematics::.

==============================================================================
File: libc.info,  Node: |System_V_Number_Conversion|,  Prev: |Printing_of_Floats|,  Up: |Arithmetic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *System_V_Number_Conversion*

20.13 Old-fashioned System V number-to-string functions
-------------------------------------------------------

The old System V C library provided three functions to convert numbers
to strings, with unusual and hard-to-use semantics.  The GNU C Library
also provides these functions and some natural extensions.

   These functions are only available in the GNU C Library and on
systems descended from AT&T Unix.  Therefore, unless these functions do
precisely what you need, it is better to use 'sprintf', which is
standard.

   All these functions are defined in 'stdlib.h'.

 -- Function: char * ecvt (double VALUE, int NDIGIT, int *DECPT, int
          *NEG)

     Preliminary: | MT-Unsafe race:ecvt | AS-Unsafe | AC-Safe | *Note
     POSIX Safety Concepts::.

     The function 'ecvt' converts the floating-point number VALUE to a
     string with at most NDIGIT decimal digits.  The returned string
     contains no decimal point or sign.  The first digit of the string
     is non-zero (unless VALUE is actually zero) and the last digit is
     rounded to nearest.  '*DECPT' is set to the index in the string of
     the first digit after the decimal point.  '*NEG' is set to a
     nonzero value if VALUE is negative, zero otherwise.

     If NDIGIT decimal digits would exceed the precision of a 'double'
     it is reduced to a system-specific value.

     The returned string is statically allocated and overwritten by each
     call to 'ecvt'.

     If VALUE is zero, it is implementation defined whether '*DECPT' is
     '0' or '1'.

     For example: 'ecvt (12.3, 5, &d, &n)' returns '"12300"' and sets D
     to '2' and N to '0'.

 -- Function: char * fcvt (double VALUE, int NDIGIT, int *DECPT, int
          *NEG)

     Preliminary: | MT-Unsafe race:fcvt | AS-Unsafe heap | AC-Unsafe mem
     | *Note POSIX Safety Concepts::.

     The function 'fcvt' is like 'ecvt', but NDIGIT specifies the number
     of digits after the decimal point.  If NDIGIT is less than zero,
     VALUE is rounded to the NDIGIT+1'th place to the left of the
     decimal point.  For example, if NDIGIT is '-1', VALUE will be
     rounded to the nearest 10.  If NDIGIT is negative and larger than
     the number of digits to the left of the decimal point in VALUE,
     VALUE will be rounded to one significant digit.

     If NDIGIT decimal digits would exceed the precision of a 'double'
     it is reduced to a system-specific value.

     The returned string is statically allocated and overwritten by each
     call to 'fcvt'.

 -- Function: char * gcvt (double VALUE, int NDIGIT, char *BUF)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'gcvt' is functionally equivalent to 'sprintf(buf, "%*g", ndigit,
     value'.  It is provided only for compatibility's sake.  It returns
     BUF.

     If NDIGIT decimal digits would exceed the precision of a 'double'
     it is reduced to a system-specific value.

   As extensions, the GNU C Library provides versions of these three
functions that take 'long double' arguments.

 -- Function: char * qecvt (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG)

     Preliminary: | MT-Unsafe race:qecvt | AS-Unsafe | AC-Safe | *Note
     POSIX Safety Concepts::.

     This function is equivalent to 'ecvt' except that it takes a 'long
     double' for the first parameter and that NDIGIT is restricted by
     the precision of a 'long double'.

 -- Function: char * qfcvt (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG)

     Preliminary: | MT-Unsafe race:qfcvt | AS-Unsafe heap | AC-Unsafe
     mem | *Note POSIX Safety Concepts::.

     This function is equivalent to 'fcvt' except that it takes a 'long
     double' for the first parameter and that NDIGIT is restricted by
     the precision of a 'long double'.

 -- Function: char * qgcvt (long double VALUE, int NDIGIT, char *BUF)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is equivalent to 'gcvt' except that it takes a 'long
     double' for the first parameter and that NDIGIT is restricted by
     the precision of a 'long double'.

   The 'ecvt' and 'fcvt' functions, and their 'long double' equivalents,
all return a string located in a static buffer which is overwritten by
the next call to the function.  The GNU C Library provides another set
of extended functions which write the converted string into a
user-supplied buffer.  These have the conventional '_r' suffix.

   'gcvt_r' is not necessary, because 'gcvt' already uses a
user-supplied buffer.

 -- Function: int ecvt_r (double VALUE, int NDIGIT, int *DECPT, int
          *NEG, char *BUF, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'ecvt_r' function is the same as 'ecvt', except that it places
     its result into the user-specified buffer pointed to by BUF, with
     length LEN.  The return value is '-1' in case of an error and zero
     otherwise.

     This function is a GNU extension.

 -- Function: int fcvt_r (double VALUE, int NDIGIT, int *DECPT, int
          *NEG, char *BUF, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'fcvt_r' function is the same as 'fcvt', except that it places
     its result into the user-specified buffer pointed to by BUF, with
     length LEN.  The return value is '-1' in case of an error and zero
     otherwise.

     This function is a GNU extension.

 -- Function: int qecvt_r (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG, char *BUF, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'qecvt_r' function is the same as 'qecvt', except that it
     places its result into the user-specified buffer pointed to by BUF,
     with length LEN.  The return value is '-1' in case of an error and
     zero otherwise.

     This function is a GNU extension.

 -- Function: int qfcvt_r (long double VALUE, int NDIGIT, int *DECPT,
          int *NEG, char *BUF, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'qfcvt_r' function is the same as 'qfcvt', except that it
     places its result into the user-specified buffer pointed to by BUF,
     with length LEN.  The return value is '-1' in case of an error and
     zero otherwise.

     This function is a GNU extension.

==============================================================================
File: libc.info,  Node: |Date_and_Time|,  Next: |Resource_Usage_And_Limitation|,  Prev: |Arithmetic|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Date_and_Time*

21 Date and Time
================

This chapter describes functions for manipulating dates and times,
including functions for determining what time it is and conversion
between different time representations.

MENU

* |Time_Basics|::                 Concepts and definitions.
* |Elapsed_Time|::                Data types to represent elapsed times
* |Processor_And_CPU_Time|::      Time a program has spent executing.
* |Calendar_Time|::               Manipulation of "real" dates and times.
* |Setting_an_Alarm|::            Sending a signal after a specified time.
* |Sleeping|::                    Waiting for a period of time.

==============================================================================
File: libc.info,  Node: |Time_Basics|,  Next: |Elapsed_Time|,  Up: |Date_and_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Time_Basics*

21.1 Time Basics
----------------

Discussing time in a technical manual can be difficult because the word
"time" in English refers to lots of different things.  In this manual,
we use a rigorous terminology to avoid confusion, and the only thing we
use the simple word "time" for is to talk about the abstract concept.

   A "calendar time" is a point in the time continuum, for example
November 4, 1990, at 18:02.5 UTC. Sometimes this is called "absolute
time".

   We don't speak of a "date", because that is inherent in a calendar
time.

   An "interval" is a contiguous part of the time continuum between two
calendar times, for example the hour between 9:00 and 10:00 on July 4,
1980.

   An "elapsed time" is the length of an interval, for example, 35
minutes.  People sometimes sloppily use the word "interval" to refer to
the elapsed time of some interval.

   An "amount of time" is a sum of elapsed times, which need not be of
any specific intervals.  For example, the amount of time it takes to
read a book might be 9 hours, independently of when and in how many
sittings it is read.

   A "period" is the elapsed time of an interval between two events,
especially when they are part of a sequence of regularly repeating
events.

   "CPU time" is like calendar time, except that it is based on the
subset of the time continuum when a particular process is actively using
a CPU. CPU time is, therefore, relative to a process.

   "Processor time" is an amount of time that a CPU is in use.  In fact,
it's a basic system resource, since there's a limit to how much can
exist in any given interval (that limit is the elapsed time of the
interval times the number of CPUs in the processor).  People often call
this CPU time, but we reserve the latter term in this manual for the
definition above.

==============================================================================
File: libc.info,  Node: |Elapsed_Time|,  Next: |Processor_And_CPU_Time|,  Prev: |Time_Basics|,  Up: |Date_and_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Elapsed_Time*

21.2 Elapsed Time
-----------------

One way to represent an elapsed time is with a simple arithmetic data
type, as with the following function to compute the elapsed time between
two calendar times.  This function is declared in 'time.h'.

 -- Function: double difftime (time_t TIME1, time_t TIME0)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'difftime' function returns the number of seconds of elapsed
     time between calendar time TIME1 and calendar time TIME0, as a
     value of type 'double'.  The difference ignores leap seconds unless
     leap second support is enabled.

     In the GNU C Library, you can simply subtract 'time_t' values.  But
     on other systems, the 'time_t' data type might use some other
     encoding where subtraction doesn't work directly.

   The GNU C Library provides two data types specifically for
representing an elapsed time.  They are used by various GNU C Library
functions, and you can use them for your own purposes too.  They're
exactly the same except that one has a resolution in microseconds, and
the other, newer one, is in nanoseconds.

 -- Data Type: struct timeval

     The 'struct timeval' structure represents an elapsed time.  It is
     declared in 'sys/time.h' and has the following members:

     'time_t tv_sec'
          This represents the number of whole seconds of elapsed time.

     'long int tv_usec'
          This is the rest of the elapsed time (a fraction of a second),
          represented as the number of microseconds.  It is always less
          than one million.

 -- Data Type: struct timespec

     The 'struct timespec' structure represents an elapsed time.  It is
     declared in 'time.h' and has the following members:

     'time_t tv_sec'
          This represents the number of whole seconds of elapsed time.

     'long int tv_nsec'
          This is the rest of the elapsed time (a fraction of a second),
          represented as the number of nanoseconds.  It is always less
          than one billion.

   It is often necessary to subtract two values of type 'struct timeval'
or 'struct timespec'.  Here is the best way to do this.  It works even
on some peculiar operating systems where the 'tv_sec' member has an
unsigned type.


     /* Subtract the 'struct timeval' values X and Y,
        storing the result in RESULT.
        Return 1 if the difference is negative, otherwise 0. */

     int
     timeval_subtract (struct timeval *result, struct timeval *x, struct timeval *y)
     {
       /* Perform the carry for the later subtraction by updating Y. */
       if (x->tv_usec < y->tv_usec) {
         int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
         y->tv_usec -= 1000000 * nsec;
         y->tv_sec += nsec;
       }
       if (x->tv_usec - y->tv_usec > 1000000) {
         int nsec = (x->tv_usec - y->tv_usec) / 1000000;
         y->tv_usec += 1000000 * nsec;
         y->tv_sec -= nsec;
       }

       /* Compute the time remaining to wait.
          'tv_usec' is certainly positive. */
       result->tv_sec = x->tv_sec - y->tv_sec;
       result->tv_usec = x->tv_usec - y->tv_usec;

       /* Return 1 if result is negative. */
       return x->tv_sec < y->tv_sec;
     }

   Common functions that use 'struct timeval' are 'gettimeofday' and
'settimeofday'.

   There are no GNU C Library functions specifically oriented toward
dealing with elapsed times, but the calendar time, processor time, and
alarm and sleeping functions have a lot to do with them.

==============================================================================
File: libc.info,  Node: |Processor_And_CPU_Time|,  Next: |Calendar_Time|,  Prev: |Elapsed_Time|,  Up: |Date_and_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Processor_And_CPU_Time*

21.3 Processor And CPU Time
---------------------------

If you're trying to optimize your program or measure its efficiency,
it's very useful to know how much processor time it uses.  For that,
calendar time and elapsed times are useless because a process may spend
time waiting for I/O or for other processes to use the CPU. However, you
can get the information with the functions in this section.

   CPU time (*note Time Basics::) is represented by the data type
'clock_t', which is a number of "clock ticks".  It gives the total
amount of time a process has actively used a CPU since some arbitrary
event.  On GNU systems, that event is the creation of the process.
While arbitrary in general, the event is always the same event for any
particular process, so you can always measure how much time on the CPU a
particular computation takes by examining the process' CPU time before
and after the computation.

   On GNU/Linux and GNU/Hurd systems, 'clock_t' is equivalent to 'long
int' and 'CLOCKS_PER_SEC' is an integer value.  But in other systems,
both 'clock_t' and the macro 'CLOCKS_PER_SEC' can be either integer or
floating-point types.  Casting CPU time values to 'double', as in the
example above, makes sure that operations such as arithmetic and
printing work properly and consistently no matter what the underlying
representation is.

   Note that the clock can wrap around.  On a 32bit system with
'CLOCKS_PER_SEC' set to one million this function will return the same
value approximately every 72 minutes.

   For additional functions to examine a process' use of processor time,
and to control it, see *note Resource Usage And Limitation::.

MENU

* |CPU_Time|::                    The 'clock' function.
* |Processor_Time|::              The 'times' function.

==============================================================================
File: libc.info,  Node: |CPU_Time|,  Next: |Processor_Time|,  Up: |Processor_And_CPU_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *CPU_Time*

21.3.1 CPU Time Inquiry
-----------------------

To get a process' CPU time, you can use the 'clock' function.  This
facility is declared in the header file 'time.h'.

   In typical usage, you call the 'clock' function at the beginning and
end of the interval you want to time, subtract the values, and then
divide by 'CLOCKS_PER_SEC' (the number of clock ticks per second) to get
processor time, like this:

     #include <time.h>

     clock_t start, end;
     double cpu_time_used;

     start = clock();
     ... /* Do the work. */
     end = clock();
     cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

   Do not use a single CPU time as an amount of time; it doesn't work
that way.  Either do a subtraction as shown above or query processor
time directly.  *Note Processor Time::.

   Different computers and operating systems vary wildly in how they
keep track of CPU time.  It's common for the internal processor clock to
have a resolution somewhere between a hundredth and millionth of a
second.

 -- Macro: int CLOCKS_PER_SEC

     The value of this macro is the number of clock ticks per second
     measured by the 'clock' function.  POSIX requires that this value
     be one million independent of the actual resolution.

 -- Data Type: clock_t

     This is the type of the value returned by the 'clock' function.
     Values of type 'clock_t' are numbers of clock ticks.

 -- Function: clock_t clock (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns the calling process' current CPU time.  If
     the CPU time is not available or cannot be represented, 'clock'
     returns the value '(clock_t)(-1)'.

==============================================================================
File: libc.info,  Node: |Processor_Time|,  Prev: |CPU_Time|,  Up: |Processor_And_CPU_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Processor_Time*

21.3.2 Processor Time Inquiry
-----------------------------

The 'times' function returns information about a process' consumption of
processor time in a 'struct tms' object, in addition to the process' CPU
time.  *Note Time Basics::.  You should include the header file
'sys/times.h' to use this facility.

 -- Data Type: struct tms

     The 'tms' structure is used to return information about process
     times.  It contains at least the following members:

     'clock_t tms_utime'
          This is the total processor time the calling process has used
          in executing the instructions of its program.

     'clock_t tms_stime'
          This is the processor time the system has used on behalf of
          the calling process.

     'clock_t tms_cutime'
          This is the sum of the 'tms_utime' values and the 'tms_cutime'
          values of all terminated child processes of the calling
          process, whose status has been reported to the parent process
          by 'wait' or 'waitpid'; see *note Process Completion::.  In
          other words, it represents the total processor time used in
          executing the instructions of all the terminated child
          processes of the calling process, excluding child processes
          which have not yet been reported by 'wait' or 'waitpid'.

     'clock_t tms_cstime'
          This is similar to 'tms_cutime', but represents the total
          processor time the system has used on behalf of all the
          terminated child processes of the calling process.

     All of the times are given in numbers of clock ticks.  Unlike CPU
     time, these are the actual amounts of time; not relative to any
     event.  *Note Creating a Process::.

 -- Macro: int CLK_TCK

     This is an obsolete name for the number of clock ticks per second.
     Use 'sysconf (_SC_CLK_TCK)' instead.

 -- Function: clock_t times (struct tms *BUFFER)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'times' function stores the processor time information for the
     calling process in BUFFER.

     The return value is the number of clock ticks since an arbitrary
     point in the past, e.g.  since system start-up.  'times' returns
     '(clock_t)(-1)' to indicate failure.

   *Portability Note:* The 'clock' function described in *note CPU
Time:: is specified by the ISO C standard.  The 'times' function is a
feature of POSIX.1.  On GNU systems, the CPU time is defined to be
equivalent to the sum of the 'tms_utime' and 'tms_stime' fields returned
by 'times'.

==============================================================================
File: libc.info,  Node: |Calendar_Time|,  Next: |Setting_an_Alarm|,  Prev: |Processor_And_CPU_Time|,  Up: |Date_and_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Calendar_Time*

21.4 Calendar Time
------------------

This section describes facilities for keeping track of calendar time.
*Note Time Basics::.

   The GNU C Library represents calendar time three ways:

   * "Simple time" (the 'time_t' data type) is a compact representation,
     typically giving the number of seconds of elapsed time since some
     implementation-specific base time.

   * There is also a "high-resolution time" representation.  Like simple
     time, this represents a calendar time as an elapsed time since a
     base time, but instead of measuring in whole seconds, it uses a
     'struct timeval' data type, which includes fractions of a second.
     Use this time representation instead of simple time when you need
     greater precision.

   * "Local time" or "broken-down time" (the 'struct tm' data type)
     represents a calendar time as a set of components specifying the
     year, month, and so on in the Gregorian calendar, for a specific
     time zone.  This calendar time representation is usually used only
     to communicate with people.

MENU

* |Simple_Calendar_Time|::        Facilities for manipulating calendar time.
* |High_Resolution_Calendar|::    A time representation with greater precision.
* |Broken_down_Time|::            Facilities for manipulating local time.
* |High_Accuracy_Clock|::         Maintaining a high accuracy system clock.
* |Formatting_Calendar_Time|::    Converting times to strings.
* |Parsing_Date_and_Time|::       Convert textual time and date information back
                                 into broken-down time values.
* |TZ_Variable|::                 How users specify the time zone.
* |Time_Zone_Functions|::         Functions to examine or specify the time zone.
* |Time_Functions_Example|::      An example program showing use of some of
				 the time functions.

==============================================================================
File: libc.info,  Node: |Simple_Calendar_Time|,  Next: |High_Resolution_Calendar|,  Up: |Calendar_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Simple_Calendar_Time*

21.4.1 Simple Calendar Time
---------------------------

This section describes the 'time_t' data type for representing calendar
time as simple time, and the functions which operate on simple time
objects.  These facilities are declared in the header file 'time.h'.

 -- Data Type: time_t

     This is the data type used to represent simple time.  Sometimes, it
     also represents an elapsed time.  When interpreted as a calendar
     time value, it represents the number of seconds elapsed since
     00:00:00 on January 1, 1970, Coordinated Universal Time.  (This
     calendar time is sometimes referred to as the "epoch".)  POSIX
     requires that this count not include leap seconds, but on some
     systems this count includes leap seconds if you set 'TZ' to certain
     values (*note TZ Variable::).

     Note that a simple time has no concept of local time zone.
     Calendar Time T is the same instant in time regardless of where on
     the globe the computer is.

     In the GNU C Library, 'time_t' is equivalent to 'long int'.  In
     other systems, 'time_t' might be either an integer or
     floating-point type.

   The function 'difftime' tells you the elapsed time between two simple
calendar times, which is not always as easy to compute as just
subtracting.  *Note Elapsed Time::.

 -- Function: time_t time (time_t *RESULT)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'time' function returns the current calendar time as a value of
     type 'time_t'.  If the argument RESULT is not a null pointer, the
     calendar time value is also stored in '*RESULT'.  If the current
     calendar time is not available, the value '(time_t)(-1)' is
     returned.

 -- Function: int stime (const time_t *NEWTIME)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'stime' sets the system clock, i.e., it tells the system that the
     current calendar time is NEWTIME, where 'newtime' is interpreted as
     described in the above definition of 'time_t'.

     'settimeofday' is a newer function which sets the system clock to
     better than one second precision.  'settimeofday' is generally a
     better choice than 'stime'.  *Note High-Resolution Calendar::.

     Only the superuser can set the system clock.

     If the function succeeds, the return value is zero.  Otherwise, it
     is '-1' and 'errno' is set accordingly:

     'EPERM'
          The process is not superuser.

==============================================================================
File: libc.info,  Node: |High_Resolution_Calendar|,  Next: |Broken_down_Time|,  Prev: |Simple_Calendar_Time|,  Up: |Calendar_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *High_Resolution_Calendar*

21.4.2 High-Resolution Calendar
-------------------------------

The 'time_t' data type used to represent simple times has a resolution
of only one second.  Some applications need more precision.

   So, the GNU C Library also contains functions which are capable of
representing calendar times to a higher resolution than one second.  The
functions and the associated data types described in this section are
declared in 'sys/time.h'.

 -- Data Type: struct timezone

     The 'struct timezone' structure is used to hold minimal information
     about the local time zone.  It has the following members:

     'int tz_minuteswest'
          This is the number of minutes west of UTC.

     'int tz_dsttime'
          If nonzero, Daylight Saving Time applies during some part of
          the year.

     The 'struct timezone' type is obsolete and should never be used.
     Instead, use the facilities described in *note Time Zone
     Functions::.

 -- Function: int gettimeofday (struct timeval *TP, struct timezone
          *TZP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'gettimeofday' function returns the current calendar time as
     the elapsed time since the epoch in the 'struct timeval' structure
     indicated by TP.  (*note Elapsed Time:: for a description of
     'struct timeval').  Information about the time zone is returned in
     the structure pointed to by TZP.  If the TZP argument is a null
     pointer, time zone information is ignored.

     The return value is '0' on success and '-1' on failure.  The
     following 'errno' error condition is defined for this function:

     'ENOSYS'
          The operating system does not support getting time zone
          information, and TZP is not a null pointer.  GNU systems do
          not support using 'struct timezone' to represent time zone
          information; that is an obsolete feature of 4.3 BSD. Instead,
          use the facilities described in *note Time Zone Functions::.

 -- Function: int settimeofday (const struct timeval *TP, const struct
          timezone *TZP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'settimeofday' function sets the current calendar time in the
     system clock according to the arguments.  As for 'gettimeofday',
     the calendar time is represented as the elapsed time since the
     epoch.  As for 'gettimeofday', time zone information is ignored if
     TZP is a null pointer.

     You must be a privileged user in order to use 'settimeofday'.

     Some kernels automatically set the system clock from some source
     such as a hardware clock when they start up.  Others, including
     Linux, place the system clock in an "invalid" state (in which
     attempts to read the clock fail).  A call of 'stime' removes the
     system clock from an invalid state, and system startup scripts
     typically run a program that calls 'stime'.

     'settimeofday' causes a sudden jump forwards or backwards, which
     can cause a variety of problems in a system.  Use 'adjtime' (below)
     to make a smooth transition from one time to another by temporarily
     speeding up or slowing down the clock.

     With a Linux kernel, 'adjtimex' does the same thing and can also
     make permanent changes to the speed of the system clock so it
     doesn't need to be corrected as often.

     The return value is '0' on success and '-1' on failure.  The
     following 'errno' error conditions are defined for this function:

     'EPERM'
          This process cannot set the clock because it is not
          privileged.

     'ENOSYS'
          The operating system does not support setting time zone
          information, and TZP is not a null pointer.

 -- Function: int adjtime (const struct timeval *DELTA, struct timeval
          *OLDDELTA)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function speeds up or slows down the system clock in order to
     make a gradual adjustment.  This ensures that the calendar time
     reported by the system clock is always monotonically increasing,
     which might not happen if you simply set the clock.

     The DELTA argument specifies a relative adjustment to be made to
     the clock time.  If negative, the system clock is slowed down for a
     while until it has lost this much elapsed time.  If positive, the
     system clock is speeded up for a while.

     If the OLDDELTA argument is not a null pointer, the 'adjtime'
     function returns information about any previous time adjustment
     that has not yet completed.

     This function is typically used to synchronize the clocks of
     computers in a local network.  You must be a privileged user to use
     it.

     With a Linux kernel, you can use the 'adjtimex' function to
     permanently change the clock speed.

     The return value is '0' on success and '-1' on failure.  The
     following 'errno' error condition is defined for this function:

     'EPERM'
          You do not have privilege to set the time.

   *Portability Note:* The 'gettimeofday', 'settimeofday', and 'adjtime'
functions are derived from BSD.

   Symbols for the following function are declared in 'sys/timex.h'.

 -- Function: int adjtimex (struct timex *TIMEX)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'adjtimex' is functionally identical to 'ntp_adjtime'.  *Note High
     Accuracy Clock::.

     This function is present only with a Linux kernel.

==============================================================================
File: libc.info,  Node: |Broken_down_Time|,  Next: |High_Accuracy_Clock|,  Prev: |High_Resolution_Calendar|,  Up: |Calendar_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Broken_down_Time*

21.4.3 Broken-down Time
-----------------------

Calendar time is represented by the usual GNU C Library functions as an
elapsed time since a fixed base calendar time.  This is convenient for
computation, but has no relation to the way people normally think of
calendar time.  By contrast, "broken-down time" is a binary
representation of calendar time separated into year, month, day, and so
on.  Broken-down time values are not useful for calculations, but they
are useful for printing human readable time information.

   A broken-down time value is always relative to a choice of time zone,
and it also indicates which time zone that is.

   The symbols in this section are declared in the header file 'time.h'.

 -- Data Type: struct tm

     This is the data type used to represent a broken-down time.  The
     structure contains at least the following members, which can appear
     in any order.

     'int tm_sec'
          This is the number of full seconds since the top of the minute
          (normally in the range '0' through '59', but the actual upper
          limit is '60', to allow for leap seconds if leap second
          support is available).

     'int tm_min'
          This is the number of full minutes since the top of the hour
          (in the range '0' through '59').

     'int tm_hour'
          This is the number of full hours past midnight (in the range
          '0' through '23').

     'int tm_mday'
          This is the ordinal day of the month (in the range '1' through
          '31').  Watch out for this one!  As the only ordinal number in
          the structure, it is inconsistent with the rest of the
          structure.

     'int tm_mon'
          This is the number of full calendar months since the beginning
          of the year (in the range '0' through '11').  Watch out for
          this one!  People usually use ordinal numbers for
          month-of-year (where January = 1).

     'int tm_year'
          This is the number of full calendar years since 1900.

     'int tm_wday'
          This is the number of full days since Sunday (in the range '0'
          through '6').

     'int tm_yday'
          This is the number of full days since the beginning of the
          year (in the range '0' through '365').

     'int tm_isdst'
          This is a flag that indicates whether Daylight Saving Time is
          (or was, or will be) in effect at the time described.  The
          value is positive if Daylight Saving Time is in effect, zero
          if it is not, and negative if the information is not
          available.

     'long int tm_gmtoff'
          This field describes the time zone that was used to compute
          this broken-down time value, including any adjustment for
          daylight saving; it is the number of seconds that you must add
          to UTC to get local time.  You can also think of this as the
          number of seconds east of UTC. For example, for U.S. Eastern
          Standard Time, the value is '-56060'.  The 'tm_gmtoff' field
          is derived from BSD and is a GNU library extension; it is not
          visible in a strict ISO C environment.

     'const char *tm_zone'
          This field is the name for the time zone that was used to
          compute this broken-down time value.  Like 'tm_gmtoff', this
          field is a BSD and GNU extension, and is not visible in a
          strict ISO C environment.

 -- Function: struct tm * localtime (const time_t *TIME)

     Preliminary: | MT-Unsafe race:tmbuf env locale | AS-Unsafe heap
     lock | AC-Unsafe lock mem fd | *Note POSIX Safety Concepts::.

     The 'localtime' function converts the simple time pointed to by
     TIME to broken-down time representation, expressed relative to the
     user's specified time zone.

     The return value is a pointer to a static broken-down time
     structure, which might be overwritten by subsequent calls to
     'ctime', 'gmtime', or 'localtime'.  (But no other library function
     overwrites the contents of this object.)

     The return value is the null pointer if TIME cannot be represented
     as a broken-down time; typically this is because the year cannot
     fit into an 'int'.

     Calling 'localtime' also sets the current time zone as if 'tzset'
     were called.  *Note Time Zone Functions::.

   Using the 'localtime' function is a big problem in multi-threaded
programs.  The result is returned in a static buffer and this is used in
all threads.  POSIX.1c introduced a variant of this function.

 -- Function: struct tm * localtime_r (const time_t *TIME, struct tm
          *RESULTP)

     Preliminary: | MT-Safe env locale | AS-Unsafe heap lock | AC-Unsafe
     lock mem fd | *Note POSIX Safety Concepts::.

     The 'localtime_r' function works just like the 'localtime'
     function.  It takes a pointer to a variable containing a simple
     time and converts it to the broken-down time format.

     But the result is not placed in a static buffer.  Instead it is
     placed in the object of type 'struct tm' to which the parameter
     RESULTP points.

     If the conversion is successful the function returns a pointer to
     the object the result was written into, i.e., it returns RESULTP.

 -- Function: struct tm * gmtime (const time_t *TIME)

     Preliminary: | MT-Unsafe race:tmbuf env locale | AS-Unsafe heap
     lock | AC-Unsafe lock mem fd | *Note POSIX Safety Concepts::.

     This function is similar to 'localtime', except that the
     broken-down time is expressed as Coordinated Universal Time (UTC)
     (formerly called Greenwich Mean Time (GMT)) rather than relative to
     a local time zone.

   As for the 'localtime' function we have the problem that the result
is placed in a static variable.  POSIX.1c also provides a replacement
for 'gmtime'.

 -- Function: struct tm * gmtime_r (const time_t *TIME, struct tm
          *RESULTP)

     Preliminary: | MT-Safe env locale | AS-Unsafe heap lock | AC-Unsafe
     lock mem fd | *Note POSIX Safety Concepts::.

     This function is similar to 'localtime_r', except that it converts
     just like 'gmtime' the given time as Coordinated Universal Time.

     If the conversion is successful the function returns a pointer to
     the object the result was written into, i.e., it returns RESULTP.

 -- Function: time_t mktime (struct tm *BROKENTIME)

     Preliminary: | MT-Safe env locale | AS-Unsafe heap lock | AC-Unsafe
     lock mem fd | *Note POSIX Safety Concepts::.

     The 'mktime' function converts a broken-down time structure to a
     simple time representation.  It also normalizes the contents of the
     broken-down time structure, and fills in some components based on
     the values of the others.

     The 'mktime' function ignores the specified contents of the
     'tm_wday', 'tm_yday', 'tm_gmtoff', and 'tm_zone' members of the
     broken-down time structure.  It uses the values of the other
     components to determine the calendar time; it's permissible for
     these components to have unnormalized values outside their normal
     ranges.  The last thing that 'mktime' does is adjust the components
     of the BROKENTIME structure, including the members that were
     initially ignored.

     If the specified broken-down time cannot be represented as a simple
     time, 'mktime' returns a value of '(time_t)(-1)' and does not
     modify the contents of BROKENTIME.

     Calling 'mktime' also sets the current time zone as if 'tzset' were
     called; 'mktime' uses this information instead of BROKENTIME's
     initial 'tm_gmtoff' and 'tm_zone' members.  *Note Time Zone
     Functions::.

 -- Function: time_t timelocal (struct tm *BROKENTIME)

     Preliminary: | MT-Safe env locale | AS-Unsafe heap lock | AC-Unsafe
     lock mem fd | *Note POSIX Safety Concepts::.

     'timelocal' is functionally identical to 'mktime', but more
     mnemonically named.  Note that it is the inverse of the 'localtime'
     function.

     *Portability note:* 'mktime' is essentially universally available.
     'timelocal' is rather rare.

 -- Function: time_t timegm (struct tm *BROKENTIME)

     Preliminary: | MT-Safe env locale | AS-Unsafe heap lock | AC-Unsafe
     lock mem fd | *Note POSIX Safety Concepts::.

     'timegm' is functionally identical to 'mktime' except it always
     takes the input values to be Coordinated Universal Time (UTC)
     regardless of any local time zone setting.

     Note that 'timegm' is the inverse of 'gmtime'.

     *Portability note:* 'mktime' is essentially universally available.
     'timegm' is rather rare.  For the most portable conversion from a
     UTC broken-down time to a simple time, set the 'TZ' environment
     variable to UTC, call 'mktime', then set 'TZ' back.

==============================================================================
File: libc.info,  Node: |High_Accuracy_Clock|,  Next: |Formatting_Calendar_Time|,  Prev: |Broken_down_Time|,  Up: |Calendar_Time|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *High_Accuracy_Clock*

21.4.4 High Accuracy Clock
--------------------------

The 'ntp_gettime' and 'ntp_adjtime' functions provide an interface to
monitor and manipulate the system clock to maintain high accuracy time.
For example, you can fine tune the speed of the clock or synchronize it
with another time source.

   A typical use of these functions is by a server implementing the
Network Time Protocol to synchronize the clocks of multiple systems and
high precision clocks.

   These functions are declared in 'sys/timex.h'.

 -- Data Type: struct ntptimeval
     This structure is used for information about the system clock.  It
     contains the following members:
     'struct timeval time'
          This is the current calendar time, expressed as the elapsed
          time since the epoch.  The 'struct timeval' data type is
          described in *note Elapsed Time::.

     'long int maxerror'
          This is the maximum error, measured in microseconds.  Unless
          updated via 'ntp_adjtime' periodically, this value will reach
          some platform-specific maximum value.

     'long int esterror'
          This is the estimated error, measured in microseconds.  This
          value can be set by 'ntp_adjtime' to indicate the estimated
          offset of the system clock from the true calendar time.

 -- Function: int ntp_gettime (struct ntptimeval *TPTR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'ntp_gettime' function sets the structure pointed to by TPTR to
     current values.  The elements of the structure afterwards contain
     the values the timer implementation in the kernel assumes.  They
     might or might not be correct.  If they are not, an 'ntp_adjtime'
     call is necessary.

     The return value is '0' on success and other values on failure.
     The following 'errno' error conditions are defined for this
     function:

     'TIME_ERROR'
          The precision clock model is not properly set up at the
          moment, thus the clock must be considered unsynchronized, and
          the values should be treated with care.

 -- Data Type: struct timex
     This structure is used to control and monitor the system clock.  It
     contains the following members:
     'unsigned int modes'
          This variable controls whether and which values are set.
          Several symbolic constants have to be combined with _binary
          or_ to specify the effective mode.  These constants start with
          'MOD_'.

     'long int offset'
          This value indicates the current offset of the system clock
          from the true calendar time.  The value is given in
          microseconds.  If bit 'MOD_OFFSET' is set in 'modes', the
          offset (and possibly other dependent values) can be set.  The
          offset's absolute value must not exceed 'MAXPHASE'.

     'long int frequency'
          This value indicates the difference in frequency between the
          true calendar time and the system clock.  The value is
          expressed as scaled PPM (parts per million, 0.0001%).  The
          scaling is '1 << SHIFT_USEC'.  The value can be set with bit
          'MOD_FREQUENCY', but the absolute value must not exceed
          'MAXFREQ'.

     'long int maxerror'
          This is the maximum error, measured in microseconds.  A new
          value can be set using bit 'MOD_MAXERROR'.  Unless updated via
          'ntp_adjtime' periodically, this value will increase steadily
          and reach some platform-specific maximum value.

     'long int esterror'
          This is the estimated error, measured in microseconds.  This
          value can be set using bit 'MOD_ESTERROR'.

     'int status'
          This variable reflects the various states of the clock
          machinery.  There are symbolic constants for the significant
          bits, starting with 'STA_'.  Some of these flags can be
          updated using the 'MOD_STATUS' bit.

     'long int constant'
          This value represents the bandwidth or stiffness of the PLL
          (phase locked loop) implemented in the kernel.  The value can
          be changed using bit 'MOD_TIMECONST'.

     'long int precision'
          This value represents the accuracy or the maximum error when
          reading the system clock.  The value is expressed in
          microseconds.

     'long int tolerance'
          This value represents the maximum frequency error of the
          system clock in scaled PPM. This value is used to increase the
          'maxerror' every second.

     'struct timeval time'
          The current calendar time.

     'long int tick'
          The elapsed time between clock ticks in microseconds.  A clock
          tick is a periodic timer interrupt on which the system clock
          is based.

     'long int ppsfreq'
          This is the first of a few optional variables that are present
          only if the system clock can use a PPS (pulse per second)
          signal to discipline the system clock.  The value is expressed
          in scaled PPM and it denotes the difference in frequency
          between the system clock and the PPS signal.

     'long int jitter'
          This value expresses a median filtered average of the PPS
          signal's dispersion in microseconds.

     'int shift'
          This value is a binary exponent for the duration of the PPS
          calibration interval, ranging from 'PPS_SHIFT' to
          'PPS_SHIFTMAX'.

     'long int stabil'
          This value represents the median filtered dispersion of the
          PPS frequency in scaled PPM.

     'long int jitcnt'
          This counter represents the number of pulses where the jitter
          exceeded the allowed maximum 'MAXTIME'.

     'long int calcnt'
          This counter reflects the number of successful calibration
          intervals.

     'long int errcnt'
          This counter represents the number of calibration errors
          (caused by large offsets or jitter).

     'long int stbcnt'
          This counter denotes the number of calibrations where the
          stability exceeded the threshold.

vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
