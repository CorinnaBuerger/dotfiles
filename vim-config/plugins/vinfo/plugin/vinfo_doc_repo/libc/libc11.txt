     While 'fork' makes a complete copy of the calling process's address
     space and allows both the parent and child to execute
     independently, 'vfork' does not make this copy.  Instead, the child
     process created with 'vfork' shares its parent's address space
     until it calls '_exit' or one of the 'exec' functions.  In the
     meantime, the parent process suspends execution.

     You must be very careful not to allow the child process created
     with 'vfork' to modify any global data or even local variables
     shared with the parent.  Furthermore, the child process cannot
     return from (or do a long jump out of) the function that called
     'vfork'!  This would leave the parent process's control information
     very confused.  If in doubt, use 'fork' instead.

     Some operating systems don't really implement 'vfork'.  The GNU C
     Library permits you to use 'vfork' on all systems, but actually
     executes 'fork' if 'vfork' isn't available.  If you follow the
     proper precautions for using 'vfork', your program will still work
     even if the system uses 'fork' instead.

==============================================================================
File: libc.info,  Node: |Executing_a_File|,  Next: |Process_Completion|,  Prev: |Creating_a_Process|,  Up: |Processes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Executing_a_File*

26.5 Executing a File
=====----------------

This section describes the 'exec' family of functions, for executing a
file as a process image.  You can use these functions to make a child
process execute a new program after it has been forked.

   To see the effects of 'exec' from the point of view of the called
program, see *note Program Basics::.

   The functions in this family differ in how you specify the arguments,
but otherwise they all do the same thing.  They are declared in the
header file 'unistd.h'.

 -- Function: int execv (const char *FILENAME, char *const ARGV[])

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'execv' function executes the file named by FILENAME as a new
     process image.

     The ARGV argument is an array of null-terminated strings that is
     used to provide a value for the 'argv' argument to the 'main'
     function of the program to be executed.  The last element of this
     array must be a null pointer.  By convention, the first element of
     this array is the file name of the program sans directory names.
     *Note Program Arguments::, for full details on how programs can
     access these arguments.

     The environment for the new process image is taken from the
     'environ' variable of the current process image; see *note
     Environment Variables::, for information about environments.

 -- Function: int execl (const char *FILENAME, const char *ARG0, ...)

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     This is similar to 'execv', but the ARGV strings are specified
     individually instead of as an array.  A null pointer must be passed
     as the last such argument.

 -- Function: int execve (const char *FILENAME, char *const ARGV[], char
          *const ENV[])

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is similar to 'execv', but permits you to specify the
     environment for the new program explicitly as the ENV argument.
     This should be an array of strings in the same format as for the
     'environ' variable; see *note Environment Access::.

 -- Function: int execle (const char *FILENAME, const char *ARG0, ...,
          char *const ENV[])

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     This is similar to 'execl', but permits you to specify the
     environment for the new program explicitly.  The environment
     argument is passed following the null pointer that marks the last
     ARGV argument, and should be an array of strings in the same format
     as for the 'environ' variable.

 -- Function: int execvp (const char *FILENAME, char *const ARGV[])

     Preliminary: | MT-Safe env | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     The 'execvp' function is similar to 'execv', except that it
     searches the directories listed in the 'PATH' environment variable
     (*note Standard Environment::) to find the full file name of a file
     from FILENAME if FILENAME does not contain a slash.

     This function is useful for executing system utility programs,
     because it looks for them in the places that the user has chosen.
     Shells use it to run the commands that users type.

 -- Function: int execlp (const char *FILENAME, const char *ARG0, ...)

     Preliminary: | MT-Safe env | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     This function is like 'execl', except that it performs the same
     file name searching as the 'execvp' function.

   The size of the argument list and environment list taken together
must not be greater than 'ARG_MAX' bytes.  *Note General Limits::.  On
GNU/Hurd systems, the size (which compares against 'ARG_MAX') includes,
for each string, the number of characters in the string, plus the size
of a 'char *', plus one, rounded up to a multiple of the size of a 'char
*'.  Other systems may have somewhat different rules for counting.

   These functions normally don't return, since execution of a new
program causes the currently executing program to go away completely.  A
value of '-1' is returned in the event of a failure.  In addition to the
usual file name errors (*note File Name Errors::), the following 'errno'
error conditions are defined for these functions:

'E2BIG'
     The combined size of the new program's argument list and
     environment list is larger than 'ARG_MAX' bytes.  GNU/Hurd systems
     have no specific limit on the argument list size, so this error
     code cannot result, but you may get 'ENOMEM' instead if the
     arguments are too big for available memory.

'ENOEXEC'
     The specified file can't be executed because it isn't in the right
     format.

'ENOMEM'
     Executing the specified file requires more storage than is
     available.

   If execution of the new file succeeds, it updates the access time
field of the file as if the file had been read.  *Note File Times::, for
more details about access times of files.

   The point at which the file is closed again is not specified, but is
at some point before the process exits or before another process image
is executed.

   Executing a new process image completely changes the contents of
memory, copying only the argument and environment strings to new
locations.  But many other attributes of the process are unchanged:

   * The process ID and the parent process ID. *Note Process Creation
     Concepts::.

   * Session and process group membership.  *Note Concepts of Job
     Control::.

   * Real user ID and group ID, and supplementary group IDs.  *Note
     Process Persona::.

   * Pending alarms.  *Note Setting an Alarm::.

   * Current working directory and root directory.  *Note Working
     Directory::.  On GNU/Hurd systems, the root directory is not copied
     when executing a setuid program; instead the system default root
     directory is used for the new program.

   * File mode creation mask.  *Note Setting Permissions::.

   * Process signal mask; see *note Process Signal Mask::.

   * Pending signals; see *note Blocking Signals::.

   * Elapsed processor time associated with the process; see *note
     Processor Time::.

   If the set-user-ID and set-group-ID mode bits of the process image
file are set, this affects the effective user ID and effective group ID
(respectively) of the process.  These concepts are discussed in detail
in *note Process Persona::.

   Signals that are set to be ignored in the existing process image are
also set to be ignored in the new process image.  All other signals are
set to the default action in the new process image.  For more
information about signals, see *note Signal Handling::.

   File descriptors open in the existing process image remain open in
the new process image, unless they have the 'FD_CLOEXEC' (close-on-exec)
flag set.  The files that remain open inherit all attributes of the open
file descriptors from the existing process image, including file locks.
File descriptors are discussed in *note Low-Level I/O::.

   Streams, by contrast, cannot survive through 'exec' functions,
because they are located in the memory of the process itself.  The new
process image has no streams except those it creates afresh.  Each of
the streams in the pre-'exec' process image has a descriptor inside it,
and these descriptors do survive through 'exec' (provided that they do
not have 'FD_CLOEXEC' set).  The new process image can reconnect these
to new streams using 'fdopen' (*note Descriptors and Streams::).

==============================================================================
File: libc.info,  Node: |Process_Completion|,  Next: |Process_Completion_Status|,  Prev: |Executing_a_File|,  Up: |Processes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Process_Completion*

26.6 Process Completion
=====------------------

The functions described in this section are used to wait for a child
process to terminate or stop, and determine its status.  These functions
are declared in the header file 'sys/wait.h'.

 -- Function: pid_t waitpid (pid_t PID, int *STATUS-PTR, int OPTIONS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'waitpid' function is used to request status information from a
     child process whose process ID is PID.  Normally, the calling
     process is suspended until the child process makes status
     information available by terminating.

     Other values for the PID argument have special interpretations.  A
     value of '-1' or 'WAIT_ANY' requests status information for any
     child process; a value of '0' or 'WAIT_MYPGRP' requests information
     for any child process in the same process group as the calling
     process; and any other negative value - PGID requests information
     for any child process whose process group ID is PGID.

     If status information for a child process is available immediately,
     this function returns immediately without waiting.  If more than
     one eligible child process has status information available, one of
     them is chosen randomly, and its status is returned immediately.
     To get the status from the other eligible child processes, you need
     to call 'waitpid' again.

     The OPTIONS argument is a bit mask.  Its value should be the
     bitwise OR (that is, the '|' operator) of zero or more of the
     'WNOHANG' and 'WUNTRACED' flags.  You can use the 'WNOHANG' flag to
     indicate that the parent process shouldn't wait; and the
     'WUNTRACED' flag to request status information from stopped
     processes as well as processes that have terminated.

     The status information from the child process is stored in the
     object that STATUS-PTR points to, unless STATUS-PTR is a null
     pointer.

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     'waitpid' is called.  If the thread gets canceled these resources
     stay allocated until the program ends.  To avoid this calls to
     'waitpid' should be protected using cancellation handlers.

     The return value is normally the process ID of the child process
     whose status is reported.  If there are child processes but none of
     them is waiting to be noticed, 'waitpid' will block until one is.
     However, if the 'WNOHANG' option was specified, 'waitpid' will
     return zero instead of blocking.

     If a specific PID to wait for was given to 'waitpid', it will
     ignore all other children (if any).  Therefore if there are
     children waiting to be noticed but the child whose PID was
     specified is not one of them, 'waitpid' will block or return zero
     as described above.

     A value of '-1' is returned in case of error.  The following
     'errno' error conditions are defined for this function:

     'EINTR'
          The function was interrupted by delivery of a signal to the
          calling process.  *Note Interrupted Primitives::.

     'ECHILD'
          There are no child processes to wait for, or the specified PID
          is not a child of the calling process.

     'EINVAL'
          An invalid value was provided for the OPTIONS argument.

   These symbolic constants are defined as values for the PID argument
to the 'waitpid' function.

'WAIT_ANY'

     This constant macro (whose value is '-1') specifies that 'waitpid'
     should return status information about any child process.

'WAIT_MYPGRP'
     This constant (with value '0') specifies that 'waitpid' should
     return status information about any child process in the same
     process group as the calling process.

   These symbolic constants are defined as flags for the OPTIONS
argument to the 'waitpid' function.  You can bitwise-OR the flags
together to obtain a value to use as the argument.

'WNOHANG'

     This flag specifies that 'waitpid' should return immediately
     instead of waiting, if there is no child process ready to be
     noticed.

'WUNTRACED'

     This flag specifies that 'waitpid' should report the status of any
     child processes that have been stopped as well as those that have
     terminated.

 -- Function: pid_t wait (int *STATUS-PTR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is a simplified version of 'waitpid', and is used to wait
     until any one child process terminates.  The call:

          wait (&status)

     is exactly equivalent to:

          waitpid (-1, &status, 0)

     This function is a cancellation point in multi-threaded programs.
     This is a problem if the thread allocates some resources (like
     memory, file descriptors, semaphores or whatever) at the time
     'wait' is called.  If the thread gets canceled these resources stay
     allocated until the program ends.  To avoid this calls to 'wait'
     should be protected using cancellation handlers.

 -- Function: pid_t wait4 (pid_t PID, int *STATUS-PTR, int OPTIONS,
          struct rusage *USAGE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If USAGE is a null pointer, 'wait4' is equivalent to 'waitpid (PID,
     STATUS-PTR, OPTIONS)'.

     If USAGE is not null, 'wait4' stores usage figures for the child
     process in '*RUSAGE' (but only if the child has terminated, not if
     it has stopped).  *Note Resource Usage::.

     This function is a BSD extension.

   Here's an example of how to use 'waitpid' to get the status from all
child processes that have terminated, without ever waiting.  This
function is designed to be a handler for 'SIGCHLD', the signal that
indicates that at least one child process has terminated.

     void
     sigchld_handler (int signum)
     {
       int pid, status, serrno;
       serrno = errno;
       while (1)
         {
           pid = waitpid (WAIT_ANY, &status, WNOHANG);
           if (pid < 0)
             {
               perror ("waitpid");
               break;
             }
           if (pid == 0)
             break;
           notice_termination (pid, status);
         }
       errno = serrno;
     }

==============================================================================
File: libc.info,  Node: |Process_Completion_Status|,  Next: |BSD_Wait_Functions|,  Prev: |Process_Completion|,  Up: |Processes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Process_Completion_Status*

26.7 Process Completion Status
=====-------------------------

If the exit status value (*note Program Termination::) of the child
process is zero, then the status value reported by 'waitpid' or 'wait'
is also zero.  You can test for other kinds of information encoded in
the returned status value using the following macros.  These macros are
defined in the header file 'sys/wait.h'.

 -- Macro: int WIFEXITED (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if the child process terminated
     normally with 'exit' or '_exit'.

 -- Macro: int WEXITSTATUS (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If 'WIFEXITED' is true of STATUS, this macro returns the low-order
     8 bits of the exit status value from the child process.  *Note Exit
     Status::.

 -- Macro: int WIFSIGNALED (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if the child process terminated
     because it received a signal that was not handled.  *Note Signal
     Handling::.

 -- Macro: int WTERMSIG (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If 'WIFSIGNALED' is true of STATUS, this macro returns the signal
     number of the signal that terminated the child process.

 -- Macro: int WCOREDUMP (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if the child process terminated
     and produced a core dump.

 -- Macro: int WIFSTOPPED (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro returns a nonzero value if the child process is stopped.

 -- Macro: int WSTOPSIG (int STATUS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If 'WIFSTOPPED' is true of STATUS, this macro returns the signal
     number of the signal that caused the child process to stop.

==============================================================================
File: libc.info,  Node: |BSD_Wait_Functions|,  Next: |Process_Creation_Example|,  Prev: |Process_Completion_Status|,  Up: |Processes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *BSD_Wait_Functions*

26.8 BSD Process Wait Function
=====-------------------------

The GNU C Library also provides the 'wait3' function for compatibility
with BSD. This function is declared in 'sys/wait.h'.  It is the
predecessor to 'wait4', which is more flexible.  'wait3' is now
obsolete.

 -- Function: pid_t wait3 (int *STATUS-PTR, int OPTIONS, struct rusage
          *USAGE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If USAGE is a null pointer, 'wait3' is equivalent to 'waitpid (-1,
     STATUS-PTR, OPTIONS)'.

     If USAGE is not null, 'wait3' stores usage figures for the child
     process in '*RUSAGE' (but only if the child has terminated, not if
     it has stopped).  *Note Resource Usage::.

==============================================================================
File: libc.info,  Node: |Process_Creation_Example|,  Prev: |BSD_Wait_Functions|,  Up: |Processes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Process_Creation_Example*

26.9 Process Creation Example
=====------------------------

Here is an example program showing how you might write a function
similar to the built-in 'system'.  It executes its COMMAND argument
using the equivalent of 'sh -c COMMAND'.

     #include <stddef.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <sys/types.h>
     #include <sys/wait.h>

     /* Execute the command using this shell program.  */
     #define SHELL "/bin/sh"

     int
     my_system (const char *command)
     {
       int status;
       pid_t pid;

       pid = fork ();
       if (pid == 0)
         {
           /* This is the child process.  Execute the shell command. */
           execl (SHELL, SHELL, "-c", command, NULL);
           _exit (EXIT_FAILURE);
         }
       else if (pid < 0)
         /* The fork failed.  Report failure.  */
         status = -1;
       else
         /* This is the parent process.  Wait for the child to complete.  */
         if (waitpid (pid, &status, 0) != pid)
           status = -1;
       return status;
     }

   There are a couple of things you should pay attention to in this
example.

   Remember that the first 'argv' argument supplied to the program
represents the name of the program being executed.  That is why, in the
call to 'execl', 'SHELL' is supplied once to name the program to execute
and a second time to supply a value for 'argv[0]'.

   The 'execl' call in the child process doesn't return if it is
successful.  If it fails, you must do something to make the child
process terminate.  Just returning a bad status code with 'return' would
leave two processes running the original program.  Instead, the right
behavior is for the child process to report failure to its parent
process.

   Call '_exit' to accomplish this.  The reason for using '_exit'
instead of 'exit' is to avoid flushing fully buffered streams such as
'stdout'.  The buffers of these streams probably contain data that was
copied from the parent process by the 'fork', data that will be output
eventually by the parent process.  Calling 'exit' in the child would
output the data twice.  *Note Termination Internals::.

==============================================================================
File: libc.info,  Node: |Inter_Process_Communication|,  Next: |Job_Control|,  Prev: |Processes|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Inter_Process_Communication*

27 Inter-Process Communication
*****=========================

This chapter describes the GNU C Library inter-process communication
primitives.

MENU

* |Semaphores|::	Support for creating and managing semaphores

==============================================================================
File: libc.info,  Node: |Semaphores|,  Up: |Inter_Process_Communication|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Semaphores*

27.1 Semaphores
=====----------

The GNU C Library implements the semaphore APIs as defined in POSIX and
System V. Semaphores can be used by multiple processes to coordinate
shared resources.  The following is a complete list of the semaphore
functions provided by the GNU C Library.

27.1.1 System V Semaphores
--------------------------

 -- Function: int semctl (int SEMID, int SEMNUM, int CMD);
     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe corrupt/linux | *Note
     POSIX Safety Concepts::.

 -- Function: int semget (key_t KEY, int NSEMS, int SEMFLG);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

 -- Function: int semop (int SEMID, struct sembuf *SOPS, size_t NSOPS);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

 -- Function: int semtimedop (int SEMID, struct sembuf *SOPS, size_t
          NSOPS, const struct timespec *TIMEOUT);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

27.1.2 POSIX Semaphores
-----------------------

 -- Function: int sem_init (sem_t *SEM, int PSHARED, unsigned int
          VALUE);
     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe corrupt | *Note POSIX
     Safety Concepts::.

 -- Function: int sem_destroy (sem_t *SEM);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

 -- Function: sem_t *sem_open (const char *NAME, int OFLAG, ...);
     Preliminary: | MT-Safe | AS-Unsafe init | AC-Unsafe init | *Note
     POSIX Safety Concepts::.

 -- Function: int sem_close (sem_t *SEM);
     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

 -- Function: int sem_unlink (const char *NAME);
     Preliminary: | MT-Safe | AS-Unsafe init | AC-Unsafe corrupt | *Note
     POSIX Safety Concepts::.

 -- Function: int sem_wait (sem_t *SEM);
     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe corrupt | *Note POSIX
     Safety Concepts::.

 -- Function: int sem_timedwait (sem_t *SEM, const struct timespec
          *ABSTIME);
     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe corrupt | *Note POSIX
     Safety Concepts::.

 -- Function: int sem_trywait (sem_t *SEM);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

 -- Function: int sem_post (sem_t *SEM);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

 -- Function: int sem_getvalue (sem_t *SEM, int *SVAL);
     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

==============================================================================
File: libc.info,  Node: |Job_Control|,  Next: |Name_Service_Switch|,  Prev: |Inter_Process_Communication|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Job_Control*

28 Job Control
*****=========

"Job control" refers to the protocol for allowing a user to move between
multiple "process groups" (or "jobs") within a single "login session".
The job control facilities are set up so that appropriate behavior for
most programs happens automatically and they need not do anything
special about job control.  So you can probably ignore the material in
this chapter unless you are writing a shell or login program.

   You need to be familiar with concepts relating to process creation
(*note Process Creation Concepts::) and signal handling (*note Signal
Handling::) in order to understand this material presented in this
chapter.

MENU

* |Concepts_of_Job_Control|::     Jobs can be controlled by a shell.
* |Job_Control_is_Optional|::     Not all POSIX systems support job control.
* |Controlling_Terminal|::        How a process gets its controlling terminal.
* |Access_to_the_Terminal|::      How processes share the controlling terminal.
* |Orphaned_Process_Groups|::     Jobs left after the user logs out.
* |Implementing_a_Shell|::        What a shell must do to implement job control.
* |Functions_for_Job_Control|::   Functions to control process groups.

==============================================================================
File: libc.info,  Node: |Concepts_of_Job_Control|,  Next: |Job_Control_is_Optional|,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Concepts_of_Job_Control*

28.1 Concepts of Job Control
=====-----------------------

The fundamental purpose of an interactive shell is to read commands from
the user's terminal and create processes to execute the programs
specified by those commands.  It can do this using the 'fork' (*note
Creating a Process::) and 'exec' (*note Executing a File::) functions.

   A single command may run just one process--but often one command uses
several processes.  If you use the '|' operator in a shell command, you
explicitly request several programs in their own processes.  But even if
you run just one program, it can use multiple processes internally.  For
example, a single compilation command such as 'cc -c foo.c' typically
uses four processes (though normally only two at any given time).  If
you run 'make', its job is to run other programs in separate processes.

   The processes belonging to a single command are called a "process
group" or "job".  This is so that you can operate on all of them at
once.  For example, typing 'C-c' sends the signal 'SIGINT' to terminate
all the processes in the foreground process group.

   A "session" is a larger group of processes.  Normally all the
processes that stem from a single login belong to the same session.

   Every process belongs to a process group.  When a process is created,
it becomes a member of the same process group and session as its parent
process.  You can put it in another process group using the 'setpgid'
function, provided the process group belongs to the same session.

   The only way to put a process in a different session is to make it
the initial process of a new session, or a "session leader", using the
'setsid' function.  This also puts the session leader into a new process
group, and you can't move it out of that process group again.

   Usually, new sessions are created by the system login program, and
the session leader is the process running the user's login shell.

   A shell that supports job control must arrange to control which job
can use the terminal at any time.  Otherwise there might be multiple
jobs trying to read from the terminal at once, and confusion about which
process should receive the input typed by the user.  To prevent this,
the shell must cooperate with the terminal driver using the protocol
described in this chapter.

   The shell can give unlimited access to the controlling terminal to
only one process group at a time.  This is called the "foreground job"
on that controlling terminal.  Other process groups managed by the shell
that are executing without such access to the terminal are called
"background jobs".

   If a background job needs to read from its controlling terminal, it
is "stopped" by the terminal driver; if the 'TOSTOP' mode is set,
likewise for writing.  The user can stop a foreground job by typing the
SUSP character (*note Special Characters::) and a program can stop any
job by sending it a 'SIGSTOP' signal.  It's the responsibility of the
shell to notice when jobs stop, to notify the user about them, and to
provide mechanisms for allowing the user to interactively continue
stopped jobs and switch jobs between foreground and background.

   *Note Access to the Terminal::, for more information about I/O to the
controlling terminal.

==============================================================================
File: libc.info,  Node: |Job_Control_is_Optional|,  Next: |Controlling_Terminal|,  Prev: |Concepts_of_Job_Control|,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Job_Control_is_Optional*

28.2 Job Control is Optional
=====-----------------------

Not all operating systems support job control.  GNU systems do support
job control, but if you are using the GNU C Library on some other
system, that system may not support job control itself.

   You can use the '_POSIX_JOB_CONTROL' macro to test at compile-time
whether the system supports job control.  *Note System Options::.

   If job control is not supported, then there can be only one process
group per session, which behaves as if it were always in the foreground.
The functions for creating additional process groups simply fail with
the error code 'ENOSYS'.

   The macros naming the various job control signals (*note Job Control
Signals::) are defined even if job control is not supported.  However,
the system never generates these signals, and attempts to send a job
control signal or examine or specify their actions report errors or do
nothing.

==============================================================================
File: libc.info,  Node: |Controlling_Terminal|,  Next: |Access_to_the_Terminal|,  Prev: |Job_Control_is_Optional|,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Controlling_Terminal*

28.3 Controlling Terminal of a Process
=====---------------------------------

One of the attributes of a process is its controlling terminal.  Child
processes created with 'fork' inherit the controlling terminal from
their parent process.  In this way, all the processes in a session
inherit the controlling terminal from the session leader.  A session
leader that has control of a terminal is called the "controlling
process" of that terminal.

   You generally do not need to worry about the exact mechanism used to
allocate a controlling terminal to a session, since it is done for you
by the system when you log in.

   An individual process disconnects from its controlling terminal when
it calls 'setsid' to become the leader of a new session.  *Note Process
Group Functions::.

==============================================================================
File: libc.info,  Node: |Access_to_the_Terminal|,  Next: |Orphaned_Process_Groups|,  Prev: |Controlling_Terminal|,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Access_to_the_Terminal*

28.4 Access to the Controlling Terminal
=====----------------------------------

Processes in the foreground job of a controlling terminal have
unrestricted access to that terminal; background processes do not.  This
section describes in more detail what happens when a process in a
background job tries to access its controlling terminal.

   When a process in a background job tries to read from its controlling
terminal, the process group is usually sent a 'SIGTTIN' signal.  This
normally causes all of the processes in that group to stop (unless they
handle the signal and don't stop themselves).  However, if the reading
process is ignoring or blocking this signal, then 'read' fails with an
'EIO' error instead.

   Similarly, when a process in a background job tries to write to its
controlling terminal, the default behavior is to send a 'SIGTTOU' signal
to the process group.  However, the behavior is modified by the 'TOSTOP'
bit of the local modes flags (*note Local Modes::).  If this bit is not
set (which is the default), then writing to the controlling terminal is
always permitted without sending a signal.  Writing is also permitted if
the 'SIGTTOU' signal is being ignored or blocked by the writing process.

   Most other terminal operations that a program can do are treated as
reading or as writing.  (The description of each operation should say
which.)

   For more information about the primitive 'read' and 'write'
functions, see *note I/O Primitives::.

==============================================================================
File: libc.info,  Node: |Orphaned_Process_Groups|,  Next: |Implementing_a_Shell|,  Prev: |Access_to_the_Terminal|,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Orphaned_Process_Groups*

28.5 Orphaned Process Groups
=====-----------------------

When a controlling process terminates, its terminal becomes free and a
new session can be established on it.  (In fact, another user could log
in on the terminal.)  This could cause a problem if any processes from
the old session are still trying to use that terminal.

   To prevent problems, process groups that continue running even after
the session leader has terminated are marked as "orphaned process
groups".

   When a process group becomes an orphan, its processes are sent a
'SIGHUP' signal.  Ordinarily, this causes the processes to terminate.
However, if a program ignores this signal or establishes a handler for
it (*note Signal Handling::), it can continue running as in the orphan
process group even after its controlling process terminates; but it
still cannot access the terminal any more.

==============================================================================
File: libc.info,  Node: |Implementing_a_Shell|,  Next: |Functions_for_Job_Control|,  Prev: |Orphaned_Process_Groups|,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Implementing_a_Shell*

28.6 Implementing a Job Control Shell
=====--------------------------------

This section describes what a shell must do to implement job control, by
presenting an extensive sample program to illustrate the concepts
involved.

MENU

* |Data_Structures|::             Introduction to the sample shell.
* |Initializing_the_Shell|::      What the shell must do to take
				 responsibility for job control.
* |Launching_Jobs|::              Creating jobs to execute commands.
* |Foreground_and_Background|::   Putting a job in foreground of background.
* |Stopped_and_Terminated_Jobs|::  Reporting job status.
* |Continuing_Stopped_Jobs|::     How to continue a stopped job in
				 the foreground or background.
* |Missing_Pieces|::              Other parts of the shell.

==============================================================================
File: libc.info,  Node: |Data_Structures|,  Next: |Initializing_the_Shell|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Data_Structures*

28.6.1 Data Structures for the Shell
------------------------------------

All of the program examples included in this chapter are part of a
simple shell program.  This section presents data structures and utility
functions which are used throughout the example.

   The sample shell deals mainly with two data structures.  The 'job'
type contains information about a job, which is a set of subprocesses
linked together with pipes.  The 'process' type holds information about
a single subprocess.  Here are the relevant data structure declarations:

     /* A process is a single process.  */
     typedef struct process
     {
       struct process *next;       /* next process in pipeline */
       char **argv;                /* for exec */
       pid_t pid;                  /* process ID */
       char completed;             /* true if process has completed */
       char stopped;               /* true if process has stopped */
       int status;                 /* reported status value */
     } process;

     /* A job is a pipeline of processes.  */
     typedef struct job
     {
       struct job *next;           /* next active job */
       char *command;              /* command line, used for messages */
       process *first_process;     /* list of processes in this job */
       pid_t pgid;                 /* process group ID */
       char notified;              /* true if user told about stopped job */
       struct termios tmodes;      /* saved terminal modes */
       int stdin, stdout, stderr;  /* standard i/o channels */
     } job;

     /* The active jobs are linked into a list.  This is its head.   */
     job *first_job = NULL;

   Here are some utility functions that are used for operating on 'job'
objects.

     /* Find the active job with the indicated PGID.  */
     job *
     find_job (pid_t pgid)
     {
       job *j;

       for (j = first_job; j; j = j->next)
         if (j->pgid == pgid)
           return j;
       return NULL;
     }

     /* Return true if all processes in the job have stopped or completed.  */
     int
     job_is_stopped (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed && !p->stopped)
           return 0;
       return 1;
     }

     /* Return true if all processes in the job have completed.  */
     int
     job_is_completed (job *j)
     {
       process *p;

       for (p = j->first_process; p; p = p->next)
         if (!p->completed)
           return 0;
       return 1;
     }

==============================================================================
File: libc.info,  Node: |Initializing_the_Shell|,  Next: |Launching_Jobs|,  Prev: |Data_Structures|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Initializing_the_Shell*

28.6.2 Initializing the Shell
-----------------------------

When a shell program that normally performs job control is started, it
has to be careful in case it has been invoked from another shell that is
already doing its own job control.

   A subshell that runs interactively has to ensure that it has been
placed in the foreground by its parent shell before it can enable job
control itself.  It does this by getting its initial process group ID
with the 'getpgrp' function, and comparing it to the process group ID of
the current foreground job associated with its controlling terminal
(which can be retrieved using the 'tcgetpgrp' function).

   If the subshell is not running as a foreground job, it must stop
itself by sending a 'SIGTTIN' signal to its own process group.  It may
not arbitrarily put itself into the foreground; it must wait for the
user to tell the parent shell to do this.  If the subshell is continued
again, it should repeat the check and stop itself again if it is still
not in the foreground.

   Once the subshell has been placed into the foreground by its parent
shell, it can enable its own job control.  It does this by calling
'setpgid' to put itself into its own process group, and then calling
'tcsetpgrp' to place this process group into the foreground.

   When a shell enables job control, it should set itself to ignore all
the job control stop signals so that it doesn't accidentally stop
itself.  You can do this by setting the action for all the stop signals
to 'SIG_IGN'.

   A subshell that runs non-interactively cannot and should not support
job control.  It must leave all processes it creates in the same process
group as the shell itself; this allows the non-interactive shell and its
child processes to be treated as a single job by the parent shell.  This
is easy to do--just don't use any of the job control primitives--but you
must remember to make the shell do it.

   Here is the initialization code for the sample shell that shows how
to do all of this.

     /* Keep track of attributes of the shell.  */

     #include <sys/types.h>
     #include <termios.h>
     #include <unistd.h>

     pid_t shell_pgid;
     struct termios shell_tmodes;
     int shell_terminal;
     int shell_is_interactive;


     /* Make sure the shell is running interactively as the foreground job
        before proceeding. */

     void
     init_shell ()
     {

       /* See if we are running interactively.  */
       shell_terminal = STDIN_FILENO;
       shell_is_interactive = isatty (shell_terminal);

       if (shell_is_interactive)
         {
           /* Loop until we are in the foreground.  */
           while (tcgetpgrp (shell_terminal) != (shell_pgid = getpgrp ()))
             kill (- shell_pgid, SIGTTIN);

           /* Ignore interactive and job-control signals.  */
           signal (SIGINT, SIG_IGN);
           signal (SIGQUIT, SIG_IGN);
           signal (SIGTSTP, SIG_IGN);
           signal (SIGTTIN, SIG_IGN);
           signal (SIGTTOU, SIG_IGN);
           signal (SIGCHLD, SIG_IGN);

           /* Put ourselves in our own process group.  */
           shell_pgid = getpid ();
           if (setpgid (shell_pgid, shell_pgid) < 0)
             {
               perror ("Couldn't put the shell in its own process group");
               exit (1);
             }

           /* Grab control of the terminal.  */
           tcsetpgrp (shell_terminal, shell_pgid);

           /* Save default terminal attributes for shell.  */
           tcgetattr (shell_terminal, &shell_tmodes);
         }
     }

==============================================================================
File: libc.info,  Node: |Launching_Jobs|,  Next: |Foreground_and_Background|,  Prev: |Initializing_the_Shell|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Launching_Jobs*

28.6.3 Launching Jobs
---------------------

Once the shell has taken responsibility for performing job control on
its controlling terminal, it can launch jobs in response to commands
typed by the user.

   To create the processes in a process group, you use the same 'fork'
and 'exec' functions described in *note Process Creation Concepts::.
Since there are multiple child processes involved, though, things are a
little more complicated and you must be careful to do things in the
right order.  Otherwise, nasty race conditions can result.

   You have two choices for how to structure the tree of parent-child
relationships among the processes.  You can either make all the
processes in the process group be children of the shell process, or you
can make one process in group be the ancestor of all the other processes
in that group.  The sample shell program presented in this chapter uses
the first approach because it makes bookkeeping somewhat simpler.

   As each process is forked, it should put itself in the new process
group by calling 'setpgid'; see *note Process Group Functions::.  The
first process in the new group becomes its "process group leader", and
its process ID becomes the "process group ID" for the group.

   The shell should also call 'setpgid' to put each of its child
processes into the new process group.  This is because there is a
potential timing problem: each child process must be put in the process
group before it begins executing a new program, and the shell depends on
having all the child processes in the group before it continues
executing.  If both the child processes and the shell call 'setpgid',
this ensures that the right things happen no matter which process gets
to it first.

   If the job is being launched as a foreground job, the new process
group also needs to be put into the foreground on the controlling
terminal using 'tcsetpgrp'.  Again, this should be done by the shell as
well as by each of its child processes, to avoid race conditions.

   The next thing each child process should do is to reset its signal
actions.

   During initialization, the shell process set itself to ignore job
control signals; see *note Initializing the Shell::.  As a result, any
child processes it creates also ignore these signals by inheritance.
This is definitely undesirable, so each child process should explicitly
set the actions for these signals back to 'SIG_DFL' just after it is
forked.

   Since shells follow this convention, applications can assume that
they inherit the correct handling of these signals from the parent
process.  But every application has a responsibility not to mess up the
handling of stop signals.  Applications that disable the normal
interpretation of the SUSP character should provide some other mechanism
for the user to stop the job.  When the user invokes this mechanism, the
program should send a 'SIGTSTP' signal to the process group of the
process, not just to the process itself.  *Note Signaling Another
Process::.

   Finally, each child process should call 'exec' in the normal way.
This is also the point at which redirection of the standard input and
output channels should be handled.  *Note Duplicating Descriptors::, for
an explanation of how to do this.

   Here is the function from the sample shell program that is
responsible for launching a program.  The function is executed by each
child process immediately after it has been forked by the shell, and
never returns.

     void
     launch_process (process *p, pid_t pgid,
                     int infile, int outfile, int errfile,
                     int foreground)
     {
       pid_t pid;

       if (shell_is_interactive)
         {
           /* Put the process into the process group and give the process group
              the terminal, if appropriate.
              This has to be done both by the shell and in the individual
              child processes because of potential race conditions.  */
           pid = getpid ();
           if (pgid == 0) pgid = pid;
           setpgid (pid, pgid);
           if (foreground)
             tcsetpgrp (shell_terminal, pgid);

           /* Set the handling for job control signals back to the default.  */
           signal (SIGINT, SIG_DFL);
           signal (SIGQUIT, SIG_DFL);
           signal (SIGTSTP, SIG_DFL);
           signal (SIGTTIN, SIG_DFL);
           signal (SIGTTOU, SIG_DFL);
           signal (SIGCHLD, SIG_DFL);
         }

       /* Set the standard input/output channels of the new process.  */
       if (infile != STDIN_FILENO)
         {
           dup2 (infile, STDIN_FILENO);
           close (infile);
         }
       if (outfile != STDOUT_FILENO)
         {
           dup2 (outfile, STDOUT_FILENO);
           close (outfile);
         }
       if (errfile != STDERR_FILENO)
         {
           dup2 (errfile, STDERR_FILENO);
           close (errfile);
         }

       /* Exec the new process.  Make sure we exit.  */
       execvp (p->argv[0], p->argv);
       perror ("execvp");
       exit (1);
     }

   If the shell is not running interactively, this function does not do
anything with process groups or signals.  Remember that a shell not
performing job control must keep all of its subprocesses in the same
process group as the shell itself.

   Next, here is the function that actually launches a complete job.
After creating the child processes, this function calls some other
functions to put the newly created job into the foreground or
background; these are discussed in *note Foreground and Background::.

     void
     launch_job (job *j, int foreground)
     {
       process *p;
       pid_t pid;
       int mypipe[2], infile, outfile;

       infile = j->stdin;
       for (p = j->first_process; p; p = p->next)
         {
           /* Set up pipes, if necessary.  */
           if (p->next)
             {
               if (pipe (mypipe) < 0)
                 {
                   perror ("pipe");
                   exit (1);
                 }
               outfile = mypipe[1];
             }
           else
             outfile = j->stdout;

           /* Fork the child processes.  */
           pid = fork ();
           if (pid == 0)
             /* This is the child process.  */
             launch_process (p, j->pgid, infile,
                             outfile, j->stderr, foreground);
           else if (pid < 0)
             {
               /* The fork failed.  */
               perror ("fork");
               exit (1);
             }
           else
             {
               /* This is the parent process.  */
               p->pid = pid;
               if (shell_is_interactive)
                 {
                   if (!j->pgid)
                     j->pgid = pid;
                   setpgid (pid, j->pgid);
                 }
             }

           /* Clean up after pipes.  */
           if (infile != j->stdin)
             close (infile);
           if (outfile != j->stdout)
             close (outfile);
           infile = mypipe[0];
         }

       format_job_info (j, "launched");

       if (!shell_is_interactive)
         wait_for_job (j);
       else if (foreground)
         put_job_in_foreground (j, 0);
       else
         put_job_in_background (j, 0);
     }

==============================================================================
File: libc.info,  Node: |Foreground_and_Background|,  Next: |Stopped_and_Terminated_Jobs|,  Prev: |Launching_Jobs|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Foreground_and_Background*

28.6.4 Foreground and Background
--------------------------------

Now let's consider what actions must be taken by the shell when it
launches a job into the foreground, and how this differs from what must
be done when a background job is launched.

   When a foreground job is launched, the shell must first give it
access to the controlling terminal by calling 'tcsetpgrp'.  Then, the
shell should wait for processes in that process group to terminate or
stop.  This is discussed in more detail in *note Stopped and Terminated
Jobs::.

   When all of the processes in the group have either completed or
stopped, the shell should regain control of the terminal for its own
process group by calling 'tcsetpgrp' again.  Since stop signals caused
by I/O from a background process or a SUSP character typed by the user
are sent to the process group, normally all the processes in the job
stop together.

   The foreground job may have left the terminal in a strange state, so
the shell should restore its own saved terminal modes before continuing.
In case the job is merely stopped, the shell should first save the
current terminal modes so that it can restore them later if the job is
continued.  The functions for dealing with terminal modes are
'tcgetattr' and 'tcsetattr'; these are described in *note Terminal
Modes::.

   Here is the sample shell's function for doing all of this.

     /* Put job J in the foreground.  If CONT is nonzero,
        restore the saved terminal modes and send the process group a
        'SIGCONT' signal to wake it up before we block.  */

     void
     put_job_in_foreground (job *j, int cont)
     {
       /* Put the job into the foreground.  */
       tcsetpgrp (shell_terminal, j->pgid);

       /* Send the job a continue signal, if necessary.  */
       if (cont)
         {
           tcsetattr (shell_terminal, TCSADRAIN, &j->tmodes);
           if (kill (- j->pgid, SIGCONT) < 0)
             perror ("kill (SIGCONT)");
         }

       /* Wait for it to report.  */
       wait_for_job (j);

       /* Put the shell back in the foreground.  */
       tcsetpgrp (shell_terminal, shell_pgid);

       /* Restore the shell's terminal modes.  */
       tcgetattr (shell_terminal, &j->tmodes);
       tcsetattr (shell_terminal, TCSADRAIN, &shell_tmodes);
     }

   If the process group is launched as a background job, the shell
should remain in the foreground itself and continue to read commands
from the terminal.

   In the sample shell, there is not much that needs to be done to put a
job into the background.  Here is the function it uses:

     /* Put a job in the background.  If the cont argument is true, send
        the process group a 'SIGCONT' signal to wake it up.  */

     void
     put_job_in_background (job *j, int cont)
     {
       /* Send the job a continue signal, if necessary.  */
       if (cont)
         if (kill (-j->pgid, SIGCONT) < 0)
           perror ("kill (SIGCONT)");
     }

==============================================================================
File: libc.info,  Node: |Stopped_and_Terminated_Jobs|,  Next: |Continuing_Stopped_Jobs|,  Prev: |Foreground_and_Background|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Stopped_and_Terminated_Jobs*

28.6.5 Stopped and Terminated Jobs
----------------------------------

When a foreground process is launched, the shell must block until all of
the processes in that job have either terminated or stopped.  It can do
this by calling the 'waitpid' function; see *note Process Completion::.
Use the 'WUNTRACED' option so that status is reported for processes that
stop as well as processes that terminate.

   The shell must also check on the status of background jobs so that it
can report terminated and stopped jobs to the user; this can be done by
calling 'waitpid' with the 'WNOHANG' option.  A good place to put a such
a check for terminated and stopped jobs is just before prompting for a
new command.

   The shell can also receive asynchronous notification that there is
status information available for a child process by establishing a
handler for 'SIGCHLD' signals.  *Note Signal Handling::.

   In the sample shell program, the 'SIGCHLD' signal is normally
ignored.  This is to avoid reentrancy problems involving the global data
structures the shell manipulates.  But at specific times when the shell
is not using these data structures--such as when it is waiting for input
on the terminal--it makes sense to enable a handler for 'SIGCHLD'.  The
same function that is used to do the synchronous status checks
('do_job_notification', in this case) can also be called from within
this handler.

   Here are the parts of the sample shell program that deal with
checking the status of jobs and reporting the information to the user.

     /* Store the status of the process PID that was returned by waitpid.
        Return 0 if all went well, nonzero otherwise.  */

     int
     mark_process_status (pid_t pid, int status)
     {
       job *j;
       process *p;

       if (pid > 0)
         {
           /* Update the record for the process.  */
           for (j = first_job; j; j = j->next)
             for (p = j->first_process; p; p = p->next)
               if (p->pid == pid)
                 {
                   p->status = status;
                   if (WIFSTOPPED (status))
                     p->stopped = 1;
                   else
                     {
                       p->completed = 1;
                       if (WIFSIGNALED (status))
                         fprintf (stderr, "%d: Terminated by signal %d.\n",
                                  (int) pid, WTERMSIG (p->status));
                     }
                   return 0;
                  }
           fprintf (stderr, "No child process %d.\n", pid);
           return -1;
         }
       else if (pid == 0 || errno == ECHILD)
         /* No processes ready to report.  */
         return -1;
       else {
         /* Other weird errors.  */
         perror ("waitpid");
         return -1;
       }
     }

     /* Check for processes that have status information available,
        without blocking.  */

     void
     update_status (void)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED|WNOHANG);
       while (!mark_process_status (pid, status));
     }

     /* Check for processes that have status information available,
        blocking until all processes in the given job have reported.  */

     void
     wait_for_job (job *j)
     {
       int status;
       pid_t pid;

       do
         pid = waitpid (WAIT_ANY, &status, WUNTRACED);
       while (!mark_process_status (pid, status)
              && !job_is_stopped (j)
              && !job_is_completed (j));
     }

     /* Format information about job status for the user to look at.  */

     void
     format_job_info (job *j, const char *status)
     {
       fprintf (stderr, "%ld (%s): %s\n", (long)j->pgid, status, j->command);
     }

     /* Notify the user about stopped or terminated jobs.
        Delete terminated jobs from the active job list.  */

     void
     do_job_notification (void)
     {
       job *j, *jlast, *jnext;
       process *p;

       /* Update status information for child processes.  */
       update_status ();

       jlast = NULL;
       for (j = first_job; j; j = jnext)
         {
           jnext = j->next;

           /* If all processes have completed, tell the user the job has
              completed and delete it from the list of active jobs.  */
           if (job_is_completed (j)) {
             format_job_info (j, "completed");
             if (jlast)
               jlast->next = jnext;
             else
               first_job = jnext;
             free_job (j);
           }

           /* Notify the user about stopped jobs,
              marking them so that we won't do this more than once.  */
           else if (job_is_stopped (j) && !j->notified) {
             format_job_info (j, "stopped");
             j->notified = 1;
             jlast = j;
           }

           /* Don't say anything about jobs that are still running.  */
           else
             jlast = j;
         }
     }

==============================================================================
File: libc.info,  Node: |Continuing_Stopped_Jobs|,  Next: |Missing_Pieces|,  Prev: |Stopped_and_Terminated_Jobs|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Continuing_Stopped_Jobs*

28.6.6 Continuing Stopped Jobs
------------------------------

The shell can continue a stopped job by sending a 'SIGCONT' signal to
its process group.  If the job is being continued in the foreground, the
shell should first invoke 'tcsetpgrp' to give the job access to the
terminal, and restore the saved terminal settings.  After continuing a
job in the foreground, the shell should wait for the job to stop or
complete, as if the job had just been launched in the foreground.

   The sample shell program handles both newly created and continued
jobs with the same pair of functions, 'put_job_in_foreground' and
'put_job_in_background'.  The definitions of these functions were given
in *note Foreground and Background::.  When continuing a stopped job, a
nonzero value is passed as the CONT argument to ensure that the
'SIGCONT' signal is sent and the terminal modes reset, as appropriate.

   This leaves only a function for updating the shell's internal
bookkeeping about the job being continued:

     /* Mark a stopped job J as being running again.  */

     void
     mark_job_as_running (job *j)
     {
       Process *p;

       for (p = j->first_process; p; p = p->next)
         p->stopped = 0;
       j->notified = 0;
     }

     /* Continue the job J.  */

     void
     continue_job (job *j, int foreground)
     {
       mark_job_as_running (j);
       if (foreground)
         put_job_in_foreground (j, 1);
       else
         put_job_in_background (j, 1);
     }

==============================================================================
File: libc.info,  Node: |Missing_Pieces|,  Prev: |Continuing_Stopped_Jobs|,  Up: |Implementing_a_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Missing_Pieces*

28.6.7 The Missing Pieces
-------------------------

The code extracts for the sample shell included in this chapter are only
a part of the entire shell program.  In particular, nothing at all has
been said about how 'job' and 'program' data structures are allocated
and initialized.

   Most real shells provide a complex user interface that has support
for a command language; variables; abbreviations, substitutions, and
pattern matching on file names; and the like.  All of this is far too
complicated to explain here!  Instead, we have concentrated on showing
how to implement the core process creation and job control functions
that can be called from such a shell.

   Here is a table summarizing the major entry points we have presented:

'void init_shell (void)'
     Initialize the shell's internal state.  *Note Initializing the
     Shell::.

'void launch_job (job *J, int FOREGROUND)'
     Launch the job J as either a foreground or background job.  *Note
     Launching Jobs::.

'void do_job_notification (void)'
     Check for and report any jobs that have terminated or stopped.  Can
     be called synchronously or within a handler for 'SIGCHLD' signals.
     *Note Stopped and Terminated Jobs::.

'void continue_job (job *J, int FOREGROUND)'
     Continue the job J.  *Note Continuing Stopped Jobs::.

   Of course, a real shell would also want to provide other functions
for managing jobs.  For example, it would be useful to have commands to
list all active jobs or to send a signal (such as 'SIGKILL') to a job.

==============================================================================
File: libc.info,  Node: |Functions_for_Job_Control|,  Prev: Implementing a Shell,  Up: |Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Functions_for_Job_Control*

28.7 Functions for Job Control
=====-------------------------

This section contains detailed descriptions of the functions relating to
job control.

MENU

* |Identifying_the_Terminal|::    Determining the controlling terminal's name.
* |Process_Group_Functions|::     Functions for manipulating process groups.
* |Terminal_Access_Functions|::   Functions for controlling terminal access.

==============================================================================
File: libc.info,  Node: |Identifying_the_Terminal|,  Next: |Process_Group_Functions|,  Up: Functions for Job Control
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Identifying_the_Terminal*

28.7.1 Identifying the Controlling Terminal
-------------------------------------------

You can use the 'ctermid' function to get a file name that you can use
to open the controlling terminal.  In the GNU C Library, it returns the
same string all the time: '"/dev/tty"'.  That is a special "magic" file
name that refers to the controlling terminal of the current process (if
it has one).  To find the name of the specific terminal device, use
'ttyname'; *note Is It a Terminal::.

   The function 'ctermid' is declared in the header file 'stdio.h'.

 -- Function: char * ctermid (char *STRING)

     Preliminary: | MT-Safe !posix/!string | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     The 'ctermid' function returns a string containing the file name of
     the controlling terminal for the current process.  If STRING is not
     a null pointer, it should be an array that can hold at least
     'L_ctermid' characters; the string is returned in this array.
     Otherwise, a pointer to a string in a static area is returned,
     which might get overwritten on subsequent calls to this function.

     An empty string is returned if the file name cannot be determined
     for any reason.  Even if a file name is returned, access to the
     file it represents is not guaranteed.

 -- Macro: int L_ctermid

     The value of this macro is an integer constant expression that
     represents the size of a string large enough to hold the file name
     returned by 'ctermid'.

   See also the 'isatty' and 'ttyname' functions, in *note Is It a
Terminal::.

==============================================================================
File: libc.info,  Node: |Process_Group_Functions|,  Next: |Terminal_Access_Functions|,  Prev: |Identifying_the_Terminal|,  Up: |Functions_for_Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Process_Group_Functions*

28.7.2 Process Group Functions
------------------------------

Here are descriptions of the functions for manipulating process groups.
Your program should include the header files 'sys/types.h' and
'unistd.h' to use these functions.

 -- Function: pid_t setsid (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'setsid' function creates a new session.  The calling process
     becomes the session leader, and is put in a new process group whose
     process group ID is the same as the process ID of that process.
     There are initially no other processes in the new process group,
     and no other process groups in the new session.

     This function also makes the calling process have no controlling
     terminal.

     The 'setsid' function returns the new process group ID of the
     calling process if successful.  A return value of '-1' indicates an
     error.  The following 'errno' error conditions are defined for this
     function:

     'EPERM'
          The calling process is already a process group leader, or
          there is already another process group around that has the
          same process group ID.

 -- Function: pid_t getsid (pid_t PID)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getsid' function returns the process group ID of the session
     leader of the specified process.  If a PID is '0', the process
     group ID of the session leader of the current process is returned.

     In case of error '-1' is returned and 'errno' is set.  The
     following 'errno' error conditions are defined for this function:

     'ESRCH'
          There is no process with the given process ID PID.
     'EPERM'
          The calling process and the process specified by PID are in
          different sessions, and the implementation doesn't allow to
          access the process group ID of the session leader of the
          process with ID PID from the calling process.

 -- Function: pid_t getpgrp (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getpgrp' function returns the process group ID of the calling
     process.

 -- Function: int getpgid (pid_t PID)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getpgid' function returns the process group ID of the process
     PID.  You can supply a value of '0' for the PID argument to get
     information about the calling process.

     In case of error '-1' is returned and 'errno' is set.  The
     following 'errno' error conditions are defined for this function:

     'ESRCH'
          There is no process with the given process ID PID.  The
          calling process and the process specified by PID are in
          different sessions, and the implementation doesn't allow to
          access the process group ID of the process with ID PID from
          the calling process.

 -- Function: int setpgid (pid_t PID, pid_t PGID)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'setpgid' function puts the process PID into the process group
     PGID.  As a special case, either PID or PGID can be zero to
     indicate the process ID of the calling process.

     This function fails on a system that does not support job control.
     *Note Job Control is Optional::, for more information.

     If the operation is successful, 'setpgid' returns zero.  Otherwise
     it returns '-1'.  The following 'errno' error conditions are
     defined for this function:

     'EACCES'
          The child process named by PID has executed an 'exec' function
          since it was forked.

     'EINVAL'
          The value of the PGID is not valid.

     'ENOSYS'
          The system doesn't support job control.

     'EPERM'
          The process indicated by the PID argument is a session leader,
          or is not in the same session as the calling process, or the
          value of the PGID argument doesn't match a process group ID in
          the same session as the calling process.

     'ESRCH'
          The process indicated by the PID argument is not the calling
          process or a child of the calling process.

 -- Function: int setpgrp (pid_t PID, pid_t PGID)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is the BSD Unix name for 'setpgid'.  Both functions do exactly
     the same thing.

==============================================================================
File: libc.info,  Node: |Terminal_Access_Functions|,  Prev: |Process_Group_Functions|,  Up: |Functions_for_Job_Control|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Terminal_Access_Functions*

28.7.3 Functions for Controlling Terminal Access
------------------------------------------------

These are the functions for reading or setting the foreground process
group of a terminal.  You should include the header files 'sys/types.h'
and 'unistd.h' in your application to use these functions.

   Although these functions take a file descriptor argument to specify
the terminal device, the foreground job is associated with the terminal
file itself and not a particular open file descriptor.

 -- Function: pid_t tcgetpgrp (int FILEDES)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns the process group ID of the foreground
     process group associated with the terminal open on descriptor
     FILEDES.

     If there is no foreground process group, the return value is a
     number greater than '1' that does not match the process group ID of
     any existing process group.  This can happen if all of the
     processes in the job that was formerly the foreground job have
     terminated, and no other job has yet been moved into the
     foreground.

     In case of an error, a value of '-1' is returned.  The following
     'errno' error conditions are defined for this function:

     'EBADF'
          The FILEDES argument is not a valid file descriptor.

     'ENOSYS'
          The system doesn't support job control.

     'ENOTTY'
          The terminal file associated with the FILEDES argument isn't
          the controlling terminal of the calling process.

 -- Function: int tcsetpgrp (int FILEDES, pid_t PGID)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is used to set a terminal's foreground process group
     ID. The argument FILEDES is a descriptor which specifies the
     terminal; PGID specifies the process group.  The calling process
     must be a member of the same session as PGID and must have the same
     controlling terminal.

     For terminal access purposes, this function is treated as output.
     If it is called from a background process on its controlling
     terminal, normally all processes in the process group are sent a
     'SIGTTOU' signal.  The exception is if the calling process itself
     is ignoring or blocking 'SIGTTOU' signals, in which case the
     operation is performed and no signal is sent.

     If successful, 'tcsetpgrp' returns '0'.  A return value of '-1'
     indicates an error.  The following 'errno' error conditions are
     defined for this function:

     'EBADF'
          The FILEDES argument is not a valid file descriptor.

     'EINVAL'
          The PGID argument is not valid.

     'ENOSYS'
          The system doesn't support job control.

     'ENOTTY'
          The FILEDES isn't the controlling terminal of the calling
          process.

     'EPERM'
          The PGID isn't a process group in the same session as the
          calling process.

 -- Function: pid_t tcgetsid (int FILDES)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is used to obtain the process group ID of the session
     for which the terminal specified by FILDES is the controlling
     terminal.  If the call is successful the group ID is returned.
     Otherwise the return value is '(pid_t) -1' and the global variable
     ERRNO is set to the following value:
     'EBADF'
          The FILEDES argument is not a valid file descriptor.

     'ENOTTY'
          The calling process does not have a controlling terminal, or
          the file is not the controlling terminal.

==============================================================================
File: libc.info,  Node: |Name_Service_Switch|,  Next: |Users_and_Groups|,  Prev: |Job_Control|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Name_Service_Switch*

29 System Databases and Name Service Switch
*****======================================

Various functions in the C Library need to be configured to work
correctly in the local environment.  Traditionally, this was done by
using files (e.g., '/etc/passwd'), but other nameservices (like the
Network Information Service (NIS) and the Domain Name Service (DNS))
became popular, and were hacked into the C library, usually with a fixed
search order.

   The GNU C Library contains a cleaner solution to this problem.  It is
designed after a method used by Sun Microsystems in the C library of
Solaris 2.  The GNU C Library follows their name and calls this scheme
"Name Service Switch" (NSS).

   Though the interface might be similar to Sun's version there is no
common code.  We never saw any source code of Sun's implementation and
so the internal interface is incompatible.  This also manifests in the
file names we use as we will see later.

MENU

* |NSS_Basics|::                  What is this NSS good for.
* |NSS_Configuration_File|::      Configuring NSS.
* |NSS_Module_Internals|::        How does it work internally.
* |Extending_NSS|::               What to do to add services or databases.

==============================================================================
File: libc.info,  Node: |NSS_Basics|,  Next: |NSS_Configuration_File|,  Prev: |Name_Service_Switch|,  Up: |Name_Service_Switch|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *NSS_Basics*

29.1 NSS Basics
=====----------

The basic idea is to put the implementation of the different services
offered to access the databases in separate modules.  This has some
advantages:

  1. Contributors can add new services without adding them to the GNU C
     Library.
  2. The modules can be updated separately.
  3. The C library image is smaller.

   To fulfill the first goal above, the ABI of the modules will be
described below.  For getting the implementation of a new service right
it is important to understand how the functions in the modules get
called.  They are in no way designed to be used by the programmer
directly.  Instead the programmer should only use the documented and
standardized functions to access the databases.

The databases available in the NSS are

'aliases'
     Mail aliases
'ethers'
     Ethernet numbers,
'group'
     Groups of users, *note Group Database::.
'hosts'
     Host names and numbers, *note Host Names::.
'netgroup'
     Network wide list of host and users, *note Netgroup Database::.
'networks'
     Network names and numbers, *note Networks Database::.
'protocols'
     Network protocols, *note Protocols Database::.
'passwd'
     User identities, *note User Database::.
'rpc'
     Remote procedure call names and numbers.
'services'
     Network services, *note Services Database::.
'shadow'
     User passphrase hashes and related information.

There will be some more added later ('automount', 'bootparams',
'netmasks', and 'publickey').

==============================================================================
File: libc.info,  Node: |NSS_Configuration_File|,  Next: |NSS_Module_Internals|,  Prev: |NSS_Basics|,  Up: |Name_Service_Switch|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *NSS_Configuration_File*

29.2 The NSS Configuration File
=====--------------------------

Somehow the NSS code must be told about the wishes of the user.  For
this reason there is the file '/etc/nsswitch.conf'.  For each database,
this file contains a specification of how the lookup process should
work.  The file could look like this:

     # /etc/nsswitch.conf
     #
     # Name Service Switch configuration file.
     #

     passwd:     db files nis
     shadow:     files
     group:      db files nis

     hosts:      files nisplus nis dns
     networks:   nisplus [NOTFOUND=return] files

     ethers:     nisplus [NOTFOUND=return] db files
     protocols:  nisplus [NOTFOUND=return] db files
     rpc:        nisplus [NOTFOUND=return] db files
     services:   nisplus [NOTFOUND=return] db files

   The first column is the database as you can guess from the table
above.  The rest of the line specifies how the lookup process works.
Please note that you specify the way it works for each database
individually.  This cannot be done with the old way of a monolithic
implementation.

   The configuration specification for each database can contain two
different items:

   * the service specification like 'files', 'db', or 'nis'.
   * the reaction on lookup result like '[NOTFOUND=return]'.

MENU

* |Services_in_the_NSS_configuration|::  Service names in the NSS configuration.
* |Actions_in_the_NSS_configuration|::  React appropriately to the lookup result.
* |Notes_on_NSS_Configuration_File|::  Things to take care about while
                                     configuring NSS.

==============================================================================
File: libc.info,  Node: |Services_in_the_NSS_configuration|,  Next: |Actions_in_the_NSS_configuration|,  Prev: |NSS_Configuration_File|,  Up: |NSS_Configuration_File|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Services_in_the_NSS_configuration*

29.2.1 Services in the NSS configuration File
---------------------------------------------

The above example file mentions five different services: 'files', 'db',
'dns', 'nis', and 'nisplus'.  This does not mean these services are
available on all sites and neither does it mean these are all the
services which will ever be available.

   In fact, these names are simply strings which the NSS code uses to
find the implicitly addressed functions.  The internal interface will be
described later.  Visible to the user are the modules which implement an
individual service.

   Assume the service NAME shall be used for a lookup.  The code for
this service is implemented in a module called 'libnss_NAME'.  On a
system supporting shared libraries this is in fact a shared library with
the name (for example) 'libnss_NAME.so.2'.  The number at the end is the
currently used version of the interface which will not change
frequently.  Normally the user should not have to be cognizant of these
files since they should be placed in a directory where they are found
automatically.  Only the names of all available services are important.

==============================================================================
File: libc.info,  Node: |Actions_in_the_NSS_configuration|,  Next: |Notes_on_NSS_Configuration_File|,  Prev: |Services_in_the_NSS_configuration|,  Up: |NSS_Configuration_File|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Actions_in_the_NSS_configuration*

29.2.2 Actions in the NSS configuration
---------------------------------------

The second item in the specification gives the user much finer control
on the lookup process.  Action items are placed between two service
names and are written within brackets.  The general form is

     '[' ( '!'? STATUS '=' ACTION )+ ']'

where

     STATUS => success | notfound | unavail | tryagain
     ACTION => return | continue

   The case of the keywords is insignificant.  The STATUS values are the
results of a call to a lookup function of a specific service.  They
mean:

'success'
     No error occurred and the wanted entry is returned.  The default
     action for this is 'return'.

'notfound'
     The lookup process works ok but the needed value was not found.
     The default action is 'continue'.

'unavail'
     The service is permanently unavailable.  This can either mean the
     needed file is not available, or, for DNS, the server is not
     available or does not allow queries.  The default action is
     'continue'.

'tryagain'
     The service is temporarily unavailable.  This could mean a file is
     locked or a server currently cannot accept more connections.  The
     default action is 'continue'.

The ACTION values mean:

'return'

     If the status matches, stop the lookup process at this service
     specification.  If an entry is available, provide it to the
     application.  If an error occurred, report it to the application.
     In case of a prior 'merge' action, the data is combined with
     previous lookup results, as explained below.

'continue'

     If the status matches, proceed with the lookup process at the next
     entry, discarding the result of the current lookup (and any merged
     data).  An exception is the 'initgroups' database and the 'success'
     status, where 'continue' acts like 'merge' below.

'merge'

     Proceed with the lookup process, retaining the current lookup
     result.  This action is useful only with the 'success' status.  If
     a subsequent service lookup succeeds and has a matching 'return'
     specification, the results are merged, the lookup process ends, and
     the merged results are returned to the application.  If the
     following service has a matching 'merge' action, the lookup process
     continues, retaining the combined data from this and any previous
     lookups.

     After a 'merge' action, errors from subsequent lookups are ignored,
     and the data gathered so far will be returned.

     The 'merge' only applies to the 'success' status.  It is currently
     implemented for the 'group' database and its group members field,
     'gr_mem'.  If specified for other databases, it causes the lookup
     to fail (if the STATUS matches).

     When processing 'merge' for 'group' membership, the group GID and
     name must be identical for both entries.  If only one or the other
     is a match, the behavior is undefined.

If we have a line like

     ethers: nisplus [NOTFOUND=return] db files

this is equivalent to

     ethers: nisplus [SUCCESS=return NOTFOUND=return UNAVAIL=continue
                      TRYAGAIN=continue]
             db      [SUCCESS=return NOTFOUND=continue UNAVAIL=continue
                      TRYAGAIN=continue]
             files

(except that it would have to be written on one line).  The default
value for the actions are normally what you want, and only need to be
changed in exceptional cases.

   If the optional '!' is placed before the STATUS this means the
following action is used for all statuses but STATUS itself.  I.e., '!'
is negation as in the C language (and others).

   Before we explain the exception which makes this action item
necessary one more remark: obviously it makes no sense to add another
action item after the 'files' service.  Since there is no other service
following the action _always_ is 'return'.

   Now, why is this '[NOTFOUND=return]' action useful?  To understand
this we should know that the 'nisplus' service is often complete; i.e.,
if an entry is not available in the NIS+ tables it is not available
anywhere else.  This is what is expressed by this action item: it is
useless to examine further services since they will not give us a
result.

   The situation would be different if the NIS+ service is not available
because the machine is booting.  In this case the return value of the
lookup function is not 'notfound' but instead 'unavail'.  And as you can
see in the complete form above: in this situation the 'db' and 'files'
services are used.  Neat, isn't it?  The system administrator need not
pay special care for the time the system is not completely ready to work
(while booting or shutdown or network problems).

==============================================================================
File: libc.info,  Node: |Notes_on_NSS_Configuration_File|,  Prev: |Actions_in_the_NSS_configuration|,  Up: |NSS_Configuration_File|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Notes_on_NSS_Configuration_File*

29.2.3 Notes on the NSS Configuration File
------------------------------------------

Finally a few more hints.  The NSS implementation is not completely
helpless if '/etc/nsswitch.conf' does not exist.  For all supported
databases there is a default value so it should normally be possible to
get the system running even if the file is corrupted or missing.

   For the 'hosts' and 'networks' databases the default value is 'dns
[!UNAVAIL=return] files'.  I.e., the system is prepared for the DNS
service not to be available but if it is available the answer it returns
is definitive.

   The 'passwd', 'group', and 'shadow' databases are traditionally
handled in a special way.  The appropriate files in the '/etc' directory
are read but if an entry with a name starting with a '+' character is
found NIS is used.  This kind of lookup remains possible if the GNU C
Library was configured with the '--enable-obsolete-nsl' option and the
special lookup service 'compat' is used.  If the GNU C Library was
configured with the '--enable-obsolete-nsl' option the default value for
the three databases above is 'compat [NOTFOUND=return] files'.  If the
'--enable-obsolete-nsl' option was not used the default value for the
services is 'files'.

   For all other databases the default value is 'files' unless the GNU C
Library was configured with '--enable-obsolete-rpc' option, in which
case it the default value is 'nis [NOTFOUND=return] files'.

   A second point is that the user should try to optimize the lookup
process.  The different service have different response times.  A simple
file look up on a local file could be fast, but if the file is long and
the needed entry is near the end of the file this may take quite some
time.  In this case it might be better to use the 'db' service which
allows fast local access to large data sets.

   Often the situation is that some global information like NIS must be
used.  So it is unavoidable to use service entries like 'nis' etc.  But
one should avoid slow services like this if possible.

==============================================================================
File: libc.info,  Node: |NSS_Module_Internals|,  Next: |Extending_NSS|,  Prev: |NSS_Configuration_File|,  Up: |Name_Service_Switch|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *NSS_Module_Internals*

29.3 NSS Module Internals
=====--------------------

Now it is time to describe what the modules look like.  The functions
contained in a module are identified by their names.  I.e., there is no
jump table or the like.  How this is done is of no interest here; those
interested in this topic should read about Dynamic Linking.

MENU

* |NSS_Module_Names|::            Construction of the interface function of
                                the NSS modules.
* |NSS_Modules_Interface|::       Programming interface in the NSS module
                                functions.

==============================================================================
File: libc.info,  Node: |NSS_Module_Names|,  Next: |NSS_Modules_Interface|,  Prev: |NSS_Module_Internals|,  Up: |NSS_Module_Internals|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *NSS_Module_Names*

29.3.1 The Naming Scheme of the NSS Modules
-------------------------------------------

The name of each function consists of various parts:

     _nss_SERVICE_FUNCTION

   SERVICE of course corresponds to the name of the module this function
is found in.(1)  The FUNCTION part is derived from the interface
function in the C library itself.  If the user calls the function
'gethostbyname' and the service used is 'files' the function

            _nss_files_gethostbyname_r

in the module

            libnss_files.so.2

is used.  You see, what is explained above in not the whole truth.  In
fact the NSS modules only contain reentrant versions of the lookup
functions.  I.e., if the user would call the 'gethostbyname_r' function
this also would end in the above function.  For all user interface
functions the C library maps this call to a call to the reentrant
function.  For reentrant functions this is trivial since the interface
is (nearly) the same.  For the non-reentrant version the library keeps
internal buffers which are used to replace the user supplied buffer.

   I.e., the reentrant functions _can_ have counterparts.  No service
module is forced to have functions for all databases and all kinds to
access them.  If a function is not available it is simply treated as if
the function would return 'unavail' (*note Actions in the NSS
configuration::).

   The file name 'libnss_files.so.2' would be on a Solaris 2 system
'nss_files.so.2'.  This is the difference mentioned above.  Sun's NSS
modules are usable as modules which get indirectly loaded only.

   The NSS modules in the GNU C Library are prepared to be used as
normal libraries themselves.  This is _not_ true at the moment, though.
However, the organization of the name space in the modules does not make
it impossible like it is for Solaris.  Now you can see why the modules
are still libraries.(2)

   ---------- Footnotes ----------

   (1) Now you might ask why this information is duplicated.  The answer
is that we want to make it possible to link directly with these shared
objects.

   (2) There is a second explanation: we were too lazy to change the
Makefiles to allow the generation of shared objects not starting with
'lib' but don't tell this to anybody.

==============================================================================
File: libc.info,  Node: |NSS_Modules_Interface|,  Prev: |NSS_Module_Names|,  Up: |NSS_Module_Internals|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *NSS_Modules_Interface*

29.3.2 The Interface of the Function in NSS Modules
---------------------------------------------------

Now we know about the functions contained in the modules.  It is now
time to describe the types.  When we mentioned the reentrant versions of
the functions above, this means there are some additional arguments
(compared with the standard, non-reentrant versions).  The prototypes
for the non-reentrant and reentrant versions of our function above are:

     struct hostent *gethostbyname (const char *name)

     int gethostbyname_r (const char *name, struct hostent *result_buf,
                          char *buf, size_t buflen, struct hostent **result,
                          int *h_errnop)

The actual prototype of the function in the NSS modules in this case is

     enum nss_status _nss_files_gethostbyname_r (const char *name,
                                                 struct hostent *result_buf,
                                                 char *buf, size_t buflen,
                                                 int *errnop, int *h_errnop)

   I.e., the interface function is in fact the reentrant function with
the change of the return value, the omission of the RESULT parameter,
and the addition of the ERRNOP parameter.  While the user-level function
returns a pointer to the result the reentrant function return an 'enum
nss_status' value:

'NSS_STATUS_TRYAGAIN'
     numeric value '-2'

'NSS_STATUS_UNAVAIL'
     numeric value '-1'

'NSS_STATUS_NOTFOUND'
     numeric value '0'

'NSS_STATUS_SUCCESS'
     numeric value '1'

Now you see where the action items of the '/etc/nsswitch.conf' file are
used.

   If you study the source code you will find there is a fifth value:
'NSS_STATUS_RETURN'.  This is an internal use only value, used by a few
functions in places where none of the above value can be used.  If
necessary the source code should be examined to learn about the details.

   In case the interface function has to return an error it is important
that the correct error code is stored in '*ERRNOP'.  Some return status
values have only one associated error code, others have more.

'NSS_STATUS_TRYAGAIN'  'EAGAIN'       One of the functions used ran
                                      temporarily out of resources or a
                                      service is currently not
                                      available.
                       'ERANGE'       The provided buffer is not large
                                      enough.  The function should be
                                      called again with a larger buffer.
'NSS_STATUS_UNAVAIL'   'ENOENT'       A necessary input file cannot be
                                      found.
'NSS_STATUS_NOTFOUND'  'ENOENT'       The requested entry is not
                                      available.

'NSS_STATUS_NOTFOUND'  'SUCCESS'      There are no entries.  Use this to
                                      avoid returning errors for
                                      inactive services which may be
                                      enabled at a later time.  This is
                                      not the same as the service being
                                      temporarily unavailable.

   These are proposed values.  There can be other error codes and the
described error codes can have different meaning.  *With one exception:*
when returning 'NSS_STATUS_TRYAGAIN' the error code 'ERANGE' _must_ mean
that the user provided buffer is too small.  Everything else is
non-critical.

   In statically linked programs, the main application and NSS modules
do not share the same thread-local variable 'errno', which is the reason
why there is an explicit ERRNOP function argument.

   The above function has something special which is missing for almost
all the other module functions.  There is an argument H_ERRNOP.  This
points to a variable which will be filled with the error code in case
the execution of the function fails for some reason.  (In statically
linked programs, the thread-local variable 'h_errno' is not shared with
the main application.)

   The 'getXXXbyYYY' functions are the most important functions in the
NSS modules.  But there are others which implement the other ways to
access system databases (say for the user database, there are
'setpwent', 'getpwent', and 'endpwent').  These will be described in
more detail later.  Here we give a general way to determine the
signature of the module function:

   * the return value is 'enum nss_status';
   * the name (*note NSS Module Names::);
   * the first arguments are identical to the arguments of the
     non-reentrant function;
   * the next four arguments are:

     'STRUCT_TYPE *result_buf'
          pointer to buffer where the result is stored.  'STRUCT_TYPE'
          is normally a struct which corresponds to the database.
     'char *buffer'
          pointer to a buffer where the function can store additional
          data for the result etc.
     'size_t buflen'
          length of the buffer pointed to by BUFFER.
     'int *errnop'
          the low-level error code to return to the application.  If the
          return value is not 'NSS_STATUS_SUCCESS', '*ERRNOP' needs to
          be set to a non-zero value.  An NSS module should never set
          '*ERRNOP' to zero.  The value 'ERANGE' is special, as
          described above.

   * possibly a last argument H_ERRNOP, for the host name and network
     name lookup functions.  If the return value is not
     'NSS_STATUS_SUCCESS', '*H_ERRNOP' needs to be set to a non-zero
     value.  A generic error code is 'NETDB_INTERNAL', which instructs
     the caller to examine '*ERRNOP' for further details.  (This
     includes the 'ERANGE' special case.)

This table is correct for all functions but the 'set...ent' and
'end...ent' functions.

==============================================================================
File: libc.info,  Node: |Extending_NSS|,  Prev: NSS Module Internals,  Up: |Name_Service_Switch|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Extending_NSS*

29.4 Extending NSS
=====-------------

One of the advantages of NSS mentioned above is that it can be extended
quite easily.  There are two ways in which the extension can happen:
adding another database or adding another service.  The former is
normally done only by the C library developers.  It is here only
important to remember that adding another database is independent from
adding another service because a service need not support all databases
or lookup functions.

   A designer/implementer of a new service is therefore free to choose
the databases s/he is interested in and leave the rest for later (or
completely aside).

MENU

* |Adding_another_Service_to_NSS|::  What is to do to add a new service.
* |NSS_Module_Function_Internals|::  Guidelines for writing new NSS
                                        service functions.

==============================================================================
File: libc.info,  Node: |Adding_another_Service_to_NSS|,  Next: |NSS_Module_Function_Internals|,  Prev: |Extending_NSS|,  Up: |Extending_NSS|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Adding_another_Service_to_NSS*

29.4.1 Adding another Service to NSS
------------------------------------

The sources for a new service need not (and should not) be part of the
GNU C Library itself.  The developer retains complete control over the
sources and its development.  The links between the C library and the
new service module consists solely of the interface functions.

   Each module is designed following a specific interface specification.
For now the version is 2 (the interface in version 1 was not adequate)
and this manifests in the version number of the shared library object of
the NSS modules: they have the extension '.2'.  If the interface changes
again in an incompatible way, this number will be increased.  Modules
using the old interface will still be usable.

   Developers of a new service will have to make sure that their module
is created using the correct interface number.  This means the file
itself must have the correct name and on ELF systems the "soname"
(Shared Object Name) must also have this number.  Building a module from
a bunch of object files on an ELF system using GNU CC could be done like
this:

     gcc -shared -o libnss_NAME.so.2 -Wl,-soname,libnss_NAME.so.2 OBJECTS

*note Options for Linking: (gcc)Link Options, to learn more about this
command line.

   To use the new module the library must be able to find it.  This can
be achieved by using options for the dynamic linker so that it will
search the directory where the binary is placed.  For an ELF system this
could be done by adding the wanted directory to the value of
'LD_LIBRARY_PATH'.

   But this is not always possible since some programs (those which run
under IDs which do not belong to the user) ignore this variable.
Therefore the stable version of the module should be placed into a
directory which is searched by the dynamic linker.  Normally this should
be the directory '$prefix/lib', where '$prefix' corresponds to the value
given to configure using the '--prefix' option.  But be careful: this
should only be done if it is clear the module does not cause any harm.
System administrators should be careful.

==============================================================================
File: libc.info,  Node: |NSS_Module_Function_Internals|,  Prev: |Adding_another_Service_to_NSS|,  Up: |Extending_NSS|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *NSS_Module_Function_Internals*

29.4.2 Internals of the NSS Module Functions
--------------------------------------------

Until now we only provided the syntactic interface for the functions in
the NSS module.  In fact there is not much more we can say since the
implementation obviously is different for each function.  But a few
general rules must be followed by all functions.

   In fact there are four kinds of different functions which may appear
in the interface.  All derive from the traditional ones for system
databases.  DB in the following table is normally an abbreviation for
the database (e.g., it is 'pw' for the user database).

'enum nss_status _nss_DATABASE_setDBent (void)'
     This function prepares the service for following operations.  For a
     simple file based lookup this means files could be opened, for
     other services this function simply is a noop.

     One special case for this function is that it takes an additional
     argument for some DATABASEs (i.e., the interface is 'int setDBent
     (int)').  *note Host Names::, which describes the 'sethostent'
     function.

     The return value should be NSS_STATUS_SUCCESS or according to the
     table above in case of an error (*note NSS Modules Interface::).

'enum nss_status _nss_DATABASE_endDBent (void)'
     This function simply closes all files which are still open or
     removes buffer caches.  If there are no files or buffers to remove
     this is again a simple noop.

     There normally is no return value other than NSS_STATUS_SUCCESS.

'enum nss_status _nss_DATABASE_getDBent_r (STRUCTURE *result, char *buffer, size_t buflen, int *errnop)'
     Since this function will be called several times in a row to
     retrieve one entry after the other it must keep some kind of state.
     But this also means the functions are not really reentrant.  They
     are reentrant only in that simultaneous calls to this function will
     not try to write the retrieved data in the same place (as it would
     be the case for the non-reentrant functions); instead, it writes to
     the structure pointed to by the RESULT parameter.  But the calls
     share a common state and in the case of a file access this means
     they return neighboring entries in the file.

     The buffer of length BUFLEN pointed to by BUFFER can be used for
     storing some additional data for the result.  It is _not_
     guaranteed that the same buffer will be passed for the next call of
     this function.  Therefore one must not misuse this buffer to save
     some state information from one call to another.

     Before the function returns with a failure code, the implementation
     should store the value of the local ERRNO variable in the variable
     pointed to be ERRNOP.  This is important to guarantee the module
     working in statically linked programs.  The stored value must not
     be zero.

     As explained above this function could also have an additional last
     argument.  This depends on the database used; it happens only for
     'host' and 'networks'.

     The function shall return 'NSS_STATUS_SUCCESS' as long as there are
     more entries.  When the last entry was read it should return
     'NSS_STATUS_NOTFOUND'.  When the buffer given as an argument is too
     small for the data to be returned 'NSS_STATUS_TRYAGAIN' should be
     returned.  When the service was not formerly initialized by a call
     to '_nss_DATABASE_setDBent' all return values allowed for this
     function can also be returned here.

'enum nss_status _nss_DATABASE_getDBbyXX_r (PARAMS, STRUCTURE *result, char *buffer, size_t buflen, int *errnop)'
     This function shall return the entry from the database which is
     addressed by the PARAMS.  The type and number of these arguments
     vary.  It must be individually determined by looking to the
     user-level interface functions.  All arguments given to the
     non-reentrant version are here described by PARAMS.

     The result must be stored in the structure pointed to by RESULT.
     If there are additional data to return (say strings, where the
     RESULT structure only contains pointers) the function must use the
     BUFFER of length BUFLEN.  There must not be any references to
     non-constant global data.

     The implementation of this function should honor the STAYOPEN flag
     set by the 'setDBent' function whenever this makes sense.

     Before the function returns, the implementation should store the
     value of the local ERRNO variable in the variable pointed to by
     ERRNOP.  This is important to guarantee the module works in
     statically linked programs.

     Again, this function takes an additional last argument for the
     'host' and 'networks' database.

     The return value should as always follow the rules given above
     (*note NSS Modules Interface::).

==============================================================================
File: libc.info,  Node: |Users_and_Groups|,  Next: |System_Management|,  Prev: |Name_Service_Switch|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Users_and_Groups*

30 Users and Groups
*****==============

Every user who can log in on the system is identified by a unique number
called the "user ID". Each process has an effective user ID which says
which user's access permissions it has.

   Users are classified into "groups" for access control purposes.  Each
process has one or more "group ID values" which say which groups the
process can use for access to files.

   The effective user and group IDs of a process collectively form its
"persona".  This determines which files the process can access.
Normally, a process inherits its persona from the parent process, but
under special circumstances a process can change its persona and thus
change its access permissions.

   Each file in the system also has a user ID and a group ID. Access
control works by comparing the user and group IDs of the file with those
of the running process.

   The system keeps a database of all the registered users, and another
database of all the defined groups.  There are library functions you can
use to examine these databases.

MENU

* |User_and_Group_IDs|::          Each user has a unique numeric ID;
				 likewise for groups.
* |Process_Persona|::             The user IDs and group IDs of a process.
* |Why_Change_Persona|::          Why a program might need to change
				 its user and/or group IDs.
* |How_Change_Persona|::          Changing the user and group IDs.
* |Reading_Persona|::             How to examine the user and group IDs.

* |Setting_User_ID|::             Functions for setting the user ID.
* |Setting_Groups|::              Functions for setting the group IDs.

* |Enable/Disable_Setuid|::       Turning setuid access on and off.
* |Setuid_Program_Example|::      The pertinent parts of one sample program.
* |Tips_for_Setuid|::             How to avoid granting unlimited access.

* |Who_Logged_In|::               Getting the name of the user who logged in,
				 or of the real user ID of the current process.

* |User_Accounting_Database|::    Keeping information about users and various
                                 actions in databases.

* |User_Database|::               Functions and data structures for
                        	 accessing the user database.
* |Group_Database|::              Functions and data structures for
                        	 accessing the group database.
* |Database_Example|::            Example program showing the use of database
				 inquiry functions.
* |Netgroup_Database|::           Functions for accessing the netgroup database.

==============================================================================
File: libc.info,  Node: |User_and_Group_IDs|,  Next: |Process_Persona|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *User_and_Group_IDs*

30.1 User and Group IDs
=====------------------

Each user account on a computer system is identified by a "user name"
(or "login name") and "user ID". Normally, each user name has a unique
user ID, but it is possible for several login names to have the same
user ID. The user names and corresponding user IDs are stored in a data
base which you can access as described in *note User Database::.

   Users are classified in "groups".  Each user name belongs to one
"default group" and may also belong to any number of "supplementary
groups".  Users who are members of the same group can share resources
(such as files) that are not accessible to users who are not a member of
that group.  Each group has a "group name" and "group ID". *Note Group
Database::, for how to find information about a group ID or group name.

==============================================================================
File: libc.info,  Node: |Process_Persona|,  Next: |Why_Change_Persona|,  Prev: |User_and_Group_IDs|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Process_Persona*

30.2 The Persona of a Process
=====------------------------

At any time, each process has an "effective user ID", a "effective group
ID", and a set of "supplementary group IDs".  These IDs determine the
privileges of the process.  They are collectively called the "persona"
of the process, because they determine "who it is" for purposes of
access control.

   Your login shell starts out with a persona which consists of your
user ID, your default group ID, and your supplementary group IDs (if you
are in more than one group).  In normal circumstances, all your other
processes inherit these values.

   A process also has a "real user ID" which identifies the user who
created the process, and a "real group ID" which identifies that user's
default group.  These values do not play a role in access control, so we
do not consider them part of the persona.  But they are also important.

   Both the real and effective user ID can be changed during the
lifetime of a process.  *Note Why Change Persona::.

   For details on how a process's effective user ID and group IDs affect
its permission to access files, see *note Access Permission::.

   The effective user ID of a process also controls permissions for
sending signals using the 'kill' function.  *Note Signaling Another
Process::.

   Finally, there are many operations which can only be performed by a
process whose effective user ID is zero.  A process with this user ID is
a "privileged process".  Commonly the user name 'root' is associated
with user ID 0, but there may be other user names with this ID.

==============================================================================
File: libc.info,  Node: |Why_Change_Persona|,  Next: |How_Change_Persona|,  Prev: |Process_Persona|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Why_Change_Persona*

30.3 Why Change the Persona of a Process?
=====------------------------------------

The most obvious situation where it is necessary for a process to change
its user and/or group IDs is the 'login' program.  When 'login' starts
running, its user ID is 'root'.  Its job is to start a shell whose user
and group IDs are those of the user who is logging in.  (To accomplish
this fully, 'login' must set the real user and group IDs as well as its
persona.  But this is a special case.)

   The more common case of changing persona is when an ordinary user
program needs access to a resource that wouldn't ordinarily be
accessible to the user actually running it.

   For example, you may have a file that is controlled by your program
but that shouldn't be read or modified directly by other users, either
because it implements some kind of locking protocol, or because you want
to preserve the integrity or privacy of the information it contains.
This kind of restricted access can be implemented by having the program
change its effective user or group ID to match that of the resource.

   Thus, imagine a game program that saves scores in a file.  The game
program itself needs to be able to update this file no matter who is
running it, but if users can write the file without going through the
game, they can give themselves any scores they like.  Some people
consider this undesirable, or even reprehensible.  It can be prevented
by creating a new user ID and login name (say, 'games') to own the
scores file, and make the file writable only by this user.  Then, when
the game program wants to update this file, it can change its effective
user ID to be that for 'games'.  In effect, the program must adopt the
persona of 'games' so it can write to the scores file.

==============================================================================
File: libc.info,  Node: |How_Change_Persona|,  Next: |Reading_Persona|,  Prev: |Why_Change_Persona|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *How_Change_Persona*

30.4 How an Application Can Change Persona
=====-------------------------------------

The ability to change the persona of a process can be a source of
unintentional privacy violations, or even intentional abuse.  Because of
the potential for problems, changing persona is restricted to special
circumstances.

   You can't arbitrarily set your user ID or group ID to anything you
want; only privileged processes can do that.  Instead, the normal way
for a program to change its persona is that it has been set up in
advance to change to a particular user or group.  This is the function
of the setuid and setgid bits of a file's access mode.  *Note Permission
Bits::.

   When the setuid bit of an executable file is on, executing that file
gives the process a third user ID: the "file user ID". This ID is set to
the owner ID of the file.  The system then changes the effective user ID
to the file user ID. The real user ID remains as it was.  Likewise, if
the setgid bit is on, the process is given a "file group ID" equal to
the group ID of the file, and its effective group ID is changed to the
file group ID.

   If a process has a file ID (user or group), then it can at any time
change its effective ID to its real ID and back to its file ID. Programs
use this feature to relinquish their special privileges except when they
actually need them.  This makes it less likely that they can be tricked
into doing something inappropriate with their privileges.

   *Portability Note:* Older systems do not have file IDs.  To determine
if a system has this feature, you can test the compiler define
'_POSIX_SAVED_IDS'.  (In the POSIX standard, file IDs are known as saved
IDs.)

   *Note File Attributes::, for a more general discussion of file modes
and accessibility.

==============================================================================
File: libc.info,  Node: |Reading_Persona|,  Next: |Setting_User_ID|,  Prev: |How_Change_Persona|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Reading_Persona*

30.5 Reading the Persona of a Process
=====--------------------------------

Here are detailed descriptions of the functions for reading the user and
group IDs of a process, both real and effective.  To use these
facilities, you must include the header files 'sys/types.h' and
'unistd.h'.

 -- Data Type: uid_t

     This is an integer data type used to represent user IDs.  In the
     GNU C Library, this is an alias for 'unsigned int'.

 -- Data Type: gid_t

     This is an integer data type used to represent group IDs.  In the
     GNU C Library, this is an alias for 'unsigned int'.

 -- Function: uid_t getuid (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getuid' function returns the real user ID of the process.

 -- Function: gid_t getgid (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getgid' function returns the real group ID of the process.

 -- Function: uid_t geteuid (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'geteuid' function returns the effective user ID of the
     process.

 -- Function: gid_t getegid (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getegid' function returns the effective group ID of the
     process.

 -- Function: int getgroups (int COUNT, gid_t *GROUPS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'getgroups' function is used to inquire about the supplementary
     group IDs of the process.  Up to COUNT of these group IDs are
     stored in the array GROUPS; the return value from the function is
     the number of group IDs actually stored.  If COUNT is smaller than
     the total number of supplementary group IDs, then 'getgroups'
     returns a value of '-1' and 'errno' is set to 'EINVAL'.

     If COUNT is zero, then 'getgroups' just returns the total number of
     supplementary group IDs.  On systems that do not support
     supplementary groups, this will always be zero.

     Here's how to use 'getgroups' to read all the supplementary group
     IDs:

          gid_t *
          read_all_groups (void)
          {
            int ngroups = getgroups (0, NULL);
            gid_t *groups
              = (gid_t *) xmalloc (ngroups * sizeof (gid_t));
            int val = getgroups (ngroups, groups);
            if (val < 0)
              {
                free (groups);
                return NULL;
              }
            return groups;
          }

==============================================================================
File: libc.info,  Node: |Setting_User_ID|,  Next: |Setting_Groups|,  Prev: |Reading_Persona|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Setting_User_ID*

30.6 Setting the User ID
=====-------------------

This section describes the functions for altering the user ID (real
and/or effective) of a process.  To use these facilities, you must
include the header files 'sys/types.h' and 'unistd.h'.

 -- Function: int seteuid (uid_t NEWEUID)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function sets the effective user ID of a process to NEWEUID,
     provided that the process is allowed to change its effective user
     ID. A privileged process (effective user ID zero) can change its
     effective user ID to any legal value.  An unprivileged process with
     a file user ID can change its effective user ID to its real user ID
     or to its file user ID. Otherwise, a process may not change its
     effective user ID at all.

     The 'seteuid' function returns a value of '0' to indicate
     successful completion, and a value of '-1' to indicate an error.
     The following 'errno' error conditions are defined for this
     function:

     'EINVAL'
          The value of the NEWEUID argument is invalid.

     'EPERM'
          The process may not change to the specified ID.

     Older systems (those without the '_POSIX_SAVED_IDS' feature) do not
     have this function.

 -- Function: int setuid (uid_t NEWUID)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     If the calling process is privileged, this function sets both the
     real and effective user IDs of the process to NEWUID.  It also
     deletes the file user ID of the process, if any.  NEWUID may be any
     legal value.  (Once this has been done, there is no way to recover
     the old effective user ID.)

     If the process is not privileged, and the system supports the
     '_POSIX_SAVED_IDS' feature, then this function behaves like
     'seteuid'.

     The return values and error conditions are the same as for
     'seteuid'.

 -- Function: int setreuid (uid_t RUID, uid_t EUID)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function sets the real user ID of the process to RUID and the
     effective user ID to EUID.  If RUID is '-1', it means not to change
     the real user ID; likewise if EUID is '-1', it means not to change
     the effective user ID.

     The 'setreuid' function exists for compatibility with 4.3 BSD Unix,
     which does not support file IDs.  You can use this function to swap
     the effective and real user IDs of the process.  (Privileged
     processes are not limited to this particular usage.)  If file IDs
     are supported, you should use that feature instead of this
     function.  *Note Enable/Disable Setuid::.

     The return value is '0' on success and '-1' on failure.  The
     following 'errno' error conditions are defined for this function:

     'EPERM'
          The process does not have the appropriate privileges; you do
          not have permission to change to the specified ID.

==============================================================================
File: libc.info,  Node: |Setting_Groups|,  Next: |Enable/Disable_Setuid|,  Prev: |Setting_User_ID|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Setting_Groups*

30.7 Setting the Group IDs
=====---------------------

This section describes the functions for altering the group IDs (real
and effective) of a process.  To use these facilities, you must include
the header files 'sys/types.h' and 'unistd.h'.

 -- Function: int setegid (gid_t NEWGID)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function sets the effective group ID of the process to NEWGID,
     provided that the process is allowed to change its group ID. Just
     as with 'seteuid', if the process is privileged it may change its
     effective group ID to any value; if it isn't, but it has a file
     group ID, then it may change to its real group ID or file group ID;
     otherwise it may not change its effective group ID.

     Note that a process is only privileged if its effective _user_ ID
     is zero.  The effective group ID only affects access permissions.

     The return values and error conditions for 'setegid' are the same
     as those for 'seteuid'.

     This function is only present if '_POSIX_SAVED_IDS' is defined.

 -- Function: int setgid (gid_t NEWGID)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function sets both the real and effective group ID of the
     process to NEWGID, provided that the process is privileged.  It
     also deletes the file group ID, if any.

     If the process is not privileged, then 'setgid' behaves like
     'setegid'.

     The return values and error conditions for 'setgid' are the same as
     those for 'seteuid'.

 -- Function: int setregid (gid_t RGID, gid_t EGID)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function sets the real group ID of the process to RGID and the
     effective group ID to EGID.  If RGID is '-1', it means not to
     change the real group ID; likewise if EGID is '-1', it means not to
     change the effective group ID.

     The 'setregid' function is provided for compatibility with 4.3 BSD
     Unix, which does not support file IDs.  You can use this function
     to swap the effective and real group IDs of the process.
     (Privileged processes are not limited to this usage.)  If file IDs
     are supported, you should use that feature instead of using this
     function.  *Note Enable/Disable Setuid::.

     The return values and error conditions for 'setregid' are the same
     as those for 'setreuid'.

   'setuid' and 'setgid' behave differently depending on whether the
effective user ID at the time is zero.  If it is not zero, they behave
like 'seteuid' and 'setegid'.  If it is, they change both effective and
real IDs and delete the file ID. To avoid confusion, we recommend you
always use 'seteuid' and 'setegid' except when you know the effective
user ID is zero and your intent is to change the persona permanently.
This case is rare--most of the programs that need it, such as 'login' and
'su', have already been written.

   Note that if your program is setuid to some user other than 'root',
there is no way to drop privileges permanently.

   The system also lets privileged processes change their supplementary
group IDs.  To use 'setgroups' or 'initgroups', your programs should
include the header file 'grp.h'.

 -- Function: int setgroups (size_t COUNT, const gid_t *GROUPS)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     This function sets the process's supplementary group IDs.  It can
     only be called from privileged processes.  The COUNT argument
     specifies the number of group IDs in the array GROUPS.

     This function returns '0' if successful and '-1' on error.  The
     following 'errno' error conditions are defined for this function:

     'EPERM'
          The calling process is not privileged.

 -- Function: int initgroups (const char *USER, gid_t GROUP)

     Preliminary: | MT-Safe locale | AS-Unsafe dlopen plugin heap lock |
     AC-Unsafe corrupt mem fd lock | *Note POSIX Safety Concepts::.

     The 'initgroups' function sets the process's supplementary group
     IDs to be the normal default for the user name USER.  The group
     GROUP is automatically included.

     This function works by scanning the group database for all the
     groups USER belongs to.  It then calls 'setgroups' with the list it
     has constructed.

     The return values and error conditions are the same as for
     'setgroups'.

   If you are interested in the groups a particular user belongs to, but
do not want to change the process's supplementary group IDs, you can use
'getgrouplist'.  To use 'getgrouplist', your programs should include the
header file 'grp.h'.

 -- Function: int getgrouplist (const char *USER, gid_t GROUP, gid_t
          *GROUPS, int *NGROUPS)

     Preliminary: | MT-Safe locale | AS-Unsafe dlopen plugin heap lock |
     AC-Unsafe corrupt mem fd lock | *Note POSIX Safety Concepts::.

     The 'getgrouplist' function scans the group database for all the
     groups USER belongs to.  Up to *NGROUPS group IDs corresponding to
     these groups are stored in the array GROUPS; the return value from
     the function is the number of group IDs actually stored.  If
     *NGROUPS is smaller than the total number of groups found, then
     'getgrouplist' returns a value of '-1' and stores the actual number
     of groups in *NGROUPS.  The group GROUP is automatically included
     in the list of groups returned by 'getgrouplist'.

     Here's how to use 'getgrouplist' to read all supplementary groups
     for USER:

          gid_t *
          supplementary_groups (char *user)
          {
            int ngroups = 16;
            gid_t *groups
              = (gid_t *) xmalloc (ngroups * sizeof (gid_t));
            struct passwd *pw = getpwnam (user);

            if (pw == NULL)
              return NULL;

            if (getgrouplist (pw->pw_name, pw->pw_gid, groups, &ngroups) < 0)
              {
                groups = xrealloc (ngroups * sizeof (gid_t));
                getgrouplist (pw->pw_name, pw->pw_gid, groups, &ngroups);
              }
            return groups;
          }

==============================================================================
File: libc.info,  Node: |Enable/Disable_Setuid|,  Next: |Setuid_Program_Example|,  Prev: |Setting_Groups|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Enable/Disable_Setuid*

30.8 Enabling and Disabling Setuid Access
=====------------------------------------

A typical setuid program does not need its special access all of the
time.  It's a good idea to turn off this access when it isn't needed, so
it can't possibly give unintended access.

   If the system supports the '_POSIX_SAVED_IDS' feature, you can
accomplish this with 'seteuid'.  When the game program starts, its real
user ID is 'jdoe', its effective user ID is 'games', and its saved user
ID is also 'games'.  The program should record both user ID values once
at the beginning, like this:

     user_user_id = getuid ();
     game_user_id = geteuid ();

   Then it can turn off game file access with

     seteuid (user_user_id);

and turn it on with

     seteuid (game_user_id);

Throughout this process, the real user ID remains 'jdoe' and the file
user ID remains 'games', so the program can always set its effective
user ID to either one.

   On other systems that don't support file user IDs, you can turn
setuid access on and off by using 'setreuid' to swap the real and
effective user IDs of the process, as follows:

     setreuid (geteuid (), getuid ());

This special case is always allowed--it cannot fail.

   Why does this have the effect of toggling the setuid access?  Suppose
a game program has just started, and its real user ID is 'jdoe' while
its effective user ID is 'games'.  In this state, the game can write the
scores file.  If it swaps the two uids, the real becomes 'games' and the
effective becomes 'jdoe'; now the program has only 'jdoe' access.
Another swap brings 'games' back to the effective user ID and restores
access to the scores file.

   In order to handle both kinds of systems, test for the saved user ID
feature with a preprocessor conditional, like this:

     #ifdef _POSIX_SAVED_IDS
       seteuid (user_user_id);
     #else
       setreuid (geteuid (), getuid ());
     #endif

==============================================================================
File: libc.info,  Node: |Setuid_Program_Example|,  Next: |Tips_for_Setuid|,  Prev: |Enable/Disable_Setuid|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Setuid_Program_Example*

30.9 Setuid Program Example
=====----------------------

Here's an example showing how to set up a program that changes its
effective user ID.

   This is part of a game program called 'caber-toss' that manipulates a
file 'scores' that should be writable only by the game program itself.
The program assumes that its executable file will be installed with the
setuid bit set and owned by the same user as the 'scores' file.
Typically, a system administrator will set up an account like 'games'
for this purpose.

   The executable file is given mode '4755', so that doing an 'ls -l' on
it produces output like:

     -rwsr-xr-x   1 games    184422 Jul 30 15:17 caber-toss

The setuid bit shows up in the file modes as the 's'.

   The scores file is given mode '644', and doing an 'ls -l' on it
shows:

     -rw-r--r--  1 games           0 Jul 31 15:33 scores

   Here are the parts of the program that show how to set up the changed
user ID. This program is conditionalized so that it makes use of the
file IDs feature if it is supported, and otherwise uses 'setreuid' to
swap the effective and real user IDs.

     #include <stdio.h>
     #include <sys/types.h>
     #include <unistd.h>
     #include <stdlib.h>


     /* Remember the effective and real UIDs. */

     static uid_t euid, ruid;


     /* Restore the effective UID to its original value. */

     void
     do_setuid (void)
     {
       int status;

     #ifdef _POSIX_SAVED_IDS
       status = seteuid (euid);
     #else
       status = setreuid (ruid, euid);
     #endif
       if (status < 0) {
         fprintf (stderr, "Couldn't set uid.\n");
         exit (status);
         }
     }


     /* Set the effective UID to the real UID. */

     void
     undo_setuid (void)
     {
       int status;

     #ifdef _POSIX_SAVED_IDS
       status = seteuid (ruid);
     #else
       status = setreuid (euid, ruid);
     #endif
       if (status < 0) {
         fprintf (stderr, "Couldn't set uid.\n");
         exit (status);
         }
     }

     /* Main program. */

     int
     main (void)
     {
       /* Remember the real and effective user IDs.  */
       ruid = getuid ();
       euid = geteuid ();
       undo_setuid ();

       /* Do the game and record the score.  */
       ...
     }

   Notice how the first thing the 'main' function does is to set the
effective user ID back to the real user ID. This is so that any other
file accesses that are performed while the user is playing the game use
the real user ID for determining permissions.  Only when the program
needs to open the scores file does it switch back to the file user ID,
like this:

     /* Record the score. */

     int
     record_score (int score)
     {
       FILE *stream;
       char *myname;

       /* Open the scores file. */
       do_setuid ();
       stream = fopen (SCORES_FILE, "a");
       undo_setuid ();

       /* Write the score to the file. */
       if (stream)
         {
           myname = cuserid (NULL);
           if (score < 0)
             fprintf (stream, "%10s: Couldn't lift the caber.\n", myname);
           else
             fprintf (stream, "%10s: %d feet.\n", myname, score);
           fclose (stream);
           return 0;
         }
       else
         return -1;
     }

==============================================================================
File: libc.info,  Node: |Tips_for_Setuid|,  Next: |Who_Logged_In|,  Prev: |Setuid_Program_Example|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Tips_for_Setuid*

30.10 Tips for Writing Setuid Programs
=====---------------------------------

It is easy for setuid programs to give the user access that isn't
intended--in fact, if you want to avoid this, you need to be careful.
Here are some guidelines for preventing unintended access and minimizing
its consequences when it does occur:

   * Don't have 'setuid' programs with privileged user IDs such as
     'root' unless it is absolutely necessary.  If the resource is
     specific to your particular program, it's better to define a new,
     nonprivileged user ID or group ID just to manage that resource.
     It's better if you can write your program to use a special group
     than a special user.

   * Be cautious about using the 'exec' functions in combination with
     changing the effective user ID. Don't let users of your program
     execute arbitrary programs under a changed user ID. Executing a
     shell is especially bad news.  Less obviously, the 'execlp' and
     'execvp' functions are a potential risk (since the program they
     execute depends on the user's 'PATH' environment variable).

     If you must 'exec' another program under a changed ID, specify an
     absolute file name (*note File Name Resolution::) for the
     executable, and make sure that the protections on that executable
     and _all_ containing directories are such that ordinary users
     cannot replace it with some other program.

     You should also check the arguments passed to the program to make
     sure they do not have unexpected effects.  Likewise, you should
     examine the environment variables.  Decide which arguments and
     variables are safe, and reject all others.

     You should never use 'system' in a privileged program, because it
     invokes a shell.

   * Only use the user ID controlling the resource in the part of the
     program that actually uses that resource.  When you're finished
     with it, restore the effective user ID back to the actual user's
     user ID. *Note Enable/Disable Setuid::.

   * If the 'setuid' part of your program needs to access other files
     besides the controlled resource, it should verify that the real
     user would ordinarily have permission to access those files.  You
     can use the 'access' function (*note Access Permission::) to check
     this; it uses the real user and group IDs, rather than the
     effective IDs.

==============================================================================
File: libc.info,  Node: |Who_Logged_In|,  Next: |User_Accounting_Database|,  Prev: |Tips_for_Setuid|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Who_Logged_In*

30.11 Identifying Who Logged In
=====--------------------------

You can use the functions listed in this section to determine the login
name of the user who is running a process, and the name of the user who
logged in the current session.  See also the function 'getuid' and
friends (*note Reading Persona::).  How this information is collected by
the system and how to control/add/remove information from the background
storage is described in *note User Accounting Database::.

   The 'getlogin' function is declared in 'unistd.h', while 'cuserid'
and 'L_cuserid' are declared in 'stdio.h'.

 -- Function: char * getlogin (void)

     Preliminary: | MT-Unsafe race:getlogin race:utent sig:ALRM timer
     locale | AS-Unsafe dlopen plugin heap lock | AC-Unsafe corrupt lock
     fd mem | *Note POSIX Safety Concepts::.

     The 'getlogin' function returns a pointer to a string containing
     the name of the user logged in on the controlling terminal of the
     process, or a null pointer if this information cannot be
     determined.  The string is statically allocated and might be
     overwritten on subsequent calls to this function or to 'cuserid'.

 -- Function: char * cuserid (char *STRING)

     Preliminary: | MT-Unsafe race:cuserid/!string locale | AS-Unsafe
     dlopen plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note
     POSIX Safety Concepts::.

     The 'cuserid' function returns a pointer to a string containing a
     user name associated with the effective ID of the process.  If
     STRING is not a null pointer, it should be an array that can hold
     at least 'L_cuserid' characters; the string is returned in this
     array.  Otherwise, a pointer to a string in a static area is
     returned.  This string is statically allocated and might be
     overwritten on subsequent calls to this function or to 'getlogin'.

     The use of this function is deprecated since it is marked to be
     withdrawn in XPG4.2 and has already been removed from newer
     revisions of POSIX.1.

 -- Macro: int L_cuserid

     An integer constant that indicates how long an array you might need
     to store a user name.

   These functions let your program identify positively the user who is
running or the user who logged in this session.  (These can differ when
setuid programs are involved; see *note Process Persona::.)  The user
cannot do anything to fool these functions.

   For most purposes, it is more useful to use the environment variable
'LOGNAME' to find out who the user is.  This is more flexible precisely
because the user can set 'LOGNAME' arbitrarily.  *Note Standard
Environment::.

==============================================================================
File: libc.info,  Node: |User_Accounting_Database|,  Next: |User_Database|,  Prev: |Who_Logged_In|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *User_Accounting_Database*

30.12 The User Accounting Database
=====-----------------------------

Most Unix-like operating systems keep track of logged in users by
maintaining a user accounting database.  This user accounting database
stores for each terminal, who has logged on, at what time, the process
ID of the user's login shell, etc., etc., but also stores information
about the run level of the system, the time of the last system reboot,
and possibly more.

   The user accounting database typically lives in '/etc/utmp',
'/var/adm/utmp' or '/var/run/utmp'.  However, these files should never
be accessed directly.  For reading information from and writing
information to the user accounting database, the functions described in
this section should be used.

MENU

* |Manipulating_the_Database|::   Scanning and modifying the user
                                 accounting database.
* |XPG_Functions|::               A standardized way for doing the same thing.
* |Logging_In_and_Out|::          Functions from BSD that modify the user
                                 accounting database.

==============================================================================
File: libc.info,  Node: |Manipulating_the_Database|,  Next: |XPG_Functions|,  Up: |User_Accounting_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Manipulating_the_Database*

30.12.1 Manipulating the User Accounting Database
-------------------------------------------------

These functions and the corresponding data structures are declared in
the header file 'utmp.h'.

 -- Data Type: struct exit_status

     The 'exit_status' data structure is used to hold information about
     the exit status of processes marked as 'DEAD_PROCESS' in the user
     accounting database.

     'short int e_termination'
          The exit status of the process.

     'short int e_exit'
          The exit status of the process.

 -- Data Type: struct utmp
     The 'utmp' data structure is used to hold information about entries
     in the user accounting database.  On GNU systems it has the
     following members:

     'short int ut_type'
          Specifies the type of login; one of 'EMPTY', 'RUN_LVL',
          'BOOT_TIME', 'OLD_TIME', 'NEW_TIME', 'INIT_PROCESS',
          'LOGIN_PROCESS', 'USER_PROCESS', 'DEAD_PROCESS' or
          'ACCOUNTING'.

     'pid_t ut_pid'
          The process ID number of the login process.

     'char ut_line[]'
          The device name of the tty (without '/dev/').

     'char ut_id[]'
          The inittab ID of the process.

     'char ut_user[]'
          The user's login name.

     'char ut_host[]'
          The name of the host from which the user logged in.

     'struct exit_status ut_exit'
          The exit status of a process marked as 'DEAD_PROCESS'.

     'long ut_session'
          The Session ID, used for windowing.

     'struct timeval ut_tv'
          Time the entry was made.  For entries of type 'OLD_TIME' this
          is the time when the system clock changed, and for entries of
          type 'NEW_TIME' this is the time the system clock was set to.

     'int32_t ut_addr_v6[4]'
          The Internet address of a remote host.

   The 'ut_type', 'ut_pid', 'ut_id', 'ut_tv', and 'ut_host' fields are
not available on all systems.  Portable applications therefore should be
prepared for these situations.  To help do this the 'utmp.h' header
provides macros '_HAVE_UT_TYPE', '_HAVE_UT_PID', '_HAVE_UT_ID',
'_HAVE_UT_TV', and '_HAVE_UT_HOST' if the respective field is available.
The programmer can handle the situations by using '#ifdef' in the
program code.

   The following macros are defined for use as values for the 'ut_type'
member of the 'utmp' structure.  The values are integer constants.

'EMPTY'

     This macro is used to indicate that the entry contains no valid
     user accounting information.

'RUN_LVL'

     This macro is used to identify the system's runlevel.

'BOOT_TIME'

     This macro is used to identify the time of system boot.

'OLD_TIME'

     This macro is used to identify the time when the system clock
     changed.

'NEW_TIME'

     This macro is used to identify the time after the system clock
     changed.

'INIT_PROCESS'

     This macro is used to identify a process spawned by the init
     process.

'LOGIN_PROCESS'

     This macro is used to identify the session leader of a logged in
     user.

'USER_PROCESS'

     This macro is used to identify a user process.

'DEAD_PROCESS'

     This macro is used to identify a terminated process.

'ACCOUNTING'

     ???

   The size of the 'ut_line', 'ut_id', 'ut_user' and 'ut_host' arrays
can be found using the 'sizeof' operator.

   Many older systems have, instead of an 'ut_tv' member, an 'ut_time'
member, usually of type 'time_t', for representing the time associated
with the entry.  Therefore, for backwards compatibility only, 'utmp.h'
defines 'ut_time' as an alias for 'ut_tv.tv_sec'.

 -- Function: void setutent (void)

     Preliminary: | MT-Unsafe race:utent | AS-Unsafe lock | AC-Unsafe
     lock fd | *Note POSIX Safety Concepts::.

     This function opens the user accounting database to begin scanning
     it.  You can then call 'getutent', 'getutid' or 'getutline' to read
     entries and 'pututline' to write entries.

     If the database is already open, it resets the input to the
     beginning of the database.

 -- Function: struct utmp * getutent (void)

     Preliminary: | MT-Unsafe init race:utent race:utentbuf sig:ALRM
     timer | AS-Unsafe heap lock | AC-Unsafe lock fd mem | *Note POSIX
     Safety Concepts::.

     The 'getutent' function reads the next entry from the user
     accounting database.  It returns a pointer to the entry, which is
     statically allocated and may be overwritten by subsequent calls to
     'getutent'.  You must copy the contents of the structure if you
     wish to save the information or you can use the 'getutent_r'
     function which stores the data in a user-provided buffer.

     A null pointer is returned in case no further entry is available.

 -- Function: void endutent (void)

     Preliminary: | MT-Unsafe race:utent | AS-Unsafe lock | AC-Unsafe
     lock fd | *Note POSIX Safety Concepts::.

     This function closes the user accounting database.

 -- Function: struct utmp * getutid (const struct utmp *ID)

     Preliminary: | MT-Unsafe init race:utent sig:ALRM timer | AS-Unsafe
     lock heap | AC-Unsafe lock mem fd | *Note POSIX Safety Concepts::.

     This function searches forward from the current point in the
     database for an entry that matches ID.  If the 'ut_type' member of
     the ID structure is one of 'RUN_LVL', 'BOOT_TIME', 'OLD_TIME' or
     'NEW_TIME' the entries match if the 'ut_type' members are
     identical.  If the 'ut_type' member of the ID structure is
     'INIT_PROCESS', 'LOGIN_PROCESS', 'USER_PROCESS' or 'DEAD_PROCESS',
     the entries match if the 'ut_type' member of the entry read from
     the database is one of these four, and the 'ut_id' members match.
     However if the 'ut_id' member of either the ID structure or the
     entry read from the database is empty it checks if the 'ut_line'
     members match instead.  If a matching entry is found, 'getutid'
     returns a pointer to the entry, which is statically allocated, and
     may be overwritten by a subsequent call to 'getutent', 'getutid' or
     'getutline'.  You must copy the contents of the structure if you
     wish to save the information.

     A null pointer is returned in case the end of the database is
     reached without a match.

     The 'getutid' function may cache the last read entry.  Therefore,
     if you are using 'getutid' to search for multiple occurrences, it
     is necessary to zero out the static data after each call.
     Otherwise 'getutid' could just return a pointer to the same entry
     over and over again.

 -- Function: struct utmp * getutline (const struct utmp *LINE)

     Preliminary: | MT-Unsafe init race:utent sig:ALRM timer | AS-Unsafe
     heap lock | AC-Unsafe lock fd mem | *Note POSIX Safety Concepts::.

     This function searches forward from the current point in the
     database until it finds an entry whose 'ut_type' value is
     'LOGIN_PROCESS' or 'USER_PROCESS', and whose 'ut_line' member
     matches the 'ut_line' member of the LINE structure.  If it finds
     such an entry, it returns a pointer to the entry which is
     statically allocated, and may be overwritten by a subsequent call
     to 'getutent', 'getutid' or 'getutline'.  You must copy the
     contents of the structure if you wish to save the information.

     A null pointer is returned in case the end of the database is
     reached without a match.

     The 'getutline' function may cache the last read entry.  Therefore
     if you are using 'getutline' to search for multiple occurrences, it
     is necessary to zero out the static data after each call.
     Otherwise 'getutline' could just return a pointer to the same entry
     over and over again.

 -- Function: struct utmp * pututline (const struct utmp *UTMP)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     | AC-Unsafe lock fd | *Note POSIX Safety Concepts::.

     The 'pututline' function inserts the entry '*UTMP' at the
     appropriate place in the user accounting database.  If it finds
     that it is not already at the correct place in the database, it
     uses 'getutid' to search for the position to insert the entry,
     however this will not modify the static structure returned by
     'getutent', 'getutid' and 'getutline'.  If this search fails, the
     entry is appended to the database.

     The 'pututline' function returns a pointer to a copy of the entry
     inserted in the user accounting database, or a null pointer if the
     entry could not be added.  The following 'errno' error conditions
     are defined for this function:

     'EPERM'
          The process does not have the appropriate privileges; you
          cannot modify the user accounting database.

   All the 'get*' functions mentioned before store the information they
return in a static buffer.  This can be a problem in multi-threaded
programs since the data returned for the request is overwritten by the
return value data in another thread.  Therefore the GNU C Library
provides as extensions three more functions which return the data in a
user-provided buffer.

 -- Function: int getutent_r (struct utmp *BUFFER, struct utmp **RESULT)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     | AC-Unsafe lock fd | *Note POSIX Safety Concepts::.

     The 'getutent_r' is equivalent to the 'getutent' function.  It
     returns the next entry from the database.  But instead of storing
     the information in a static buffer it stores it in the buffer
     pointed to by the parameter BUFFER.

     If the call was successful, the function returns '0' and the
     pointer variable pointed to by the parameter RESULT contains a
     pointer to the buffer which contains the result (this is most
     probably the same value as BUFFER).  If something went wrong during
     the execution of 'getutent_r' the function returns '-1'.

     This function is a GNU extension.

 -- Function: int getutid_r (const struct utmp *ID, struct utmp *BUFFER,
          struct utmp **RESULT)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     | AC-Unsafe lock fd | *Note POSIX Safety Concepts::.

     This function retrieves just like 'getutid' the next entry matching
     the information stored in ID.  But the result is stored in the
     buffer pointed to by the parameter BUFFER.

     If successful the function returns '0' and the pointer variable
     pointed to by the parameter RESULT contains a pointer to the buffer
     with the result (probably the same as RESULT.  If not successful
     the function return '-1'.

     This function is a GNU extension.

 -- Function: int getutline_r (const struct utmp *LINE, struct utmp
          *BUFFER, struct utmp **RESULT)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     | AC-Unsafe lock fd | *Note POSIX Safety Concepts::.

     This function retrieves just like 'getutline' the next entry
     matching the information stored in LINE.  But the result is stored
     in the buffer pointed to by the parameter BUFFER.

     If successful the function returns '0' and the pointer variable
     pointed to by the parameter RESULT contains a pointer to the buffer
     with the result (probably the same as RESULT.  If not successful
     the function return '-1'.

     This function is a GNU extension.

   In addition to the user accounting database, most systems keep a
number of similar databases.  For example most systems keep a log file
with all previous logins (usually in '/etc/wtmp' or '/var/log/wtmp').

   For specifying which database to examine, the following function
should be used.

 -- Function: int utmpname (const char *FILE)

     Preliminary: | MT-Unsafe race:utent | AS-Unsafe lock heap |
     AC-Unsafe lock mem | *Note POSIX Safety Concepts::.

     The 'utmpname' function changes the name of the database to be
     examined to FILE, and closes any previously opened database.  By
     default 'getutent', 'getutid', 'getutline' and 'pututline' read
     from and write to the user accounting database.

     The following macros are defined for use as the FILE argument:

      -- Macro: char * _PATH_UTMP
          This macro is used to specify the user accounting database.

      -- Macro: char * _PATH_WTMP
          This macro is used to specify the user accounting log file.

     The 'utmpname' function returns a value of '0' if the new name was
     successfully stored, and a value of '-1' to indicate an error.
     Note that 'utmpname' does not try to open the database, and that
     therefore the return value does not say anything about whether the
     database can be successfully opened.

   Specially for maintaining log-like databases the GNU C Library
provides the following function:

 -- Function: void updwtmp (const char *WTMP_FILE, const struct utmp
          *UTMP)

     Preliminary: | MT-Unsafe sig:ALRM timer | AS-Unsafe | AC-Unsafe fd
     | *Note POSIX Safety Concepts::.

     The 'updwtmp' function appends the entry *UTMP to the database
     specified by WTMP_FILE.  For possible values for the WTMP_FILE
     argument see the 'utmpname' function.

   *Portability Note:* Although many operating systems provide a subset
of these functions, they are not standardized.  There are often subtle
differences in the return types, and there are considerable differences
between the various definitions of 'struct utmp'.  When programming for
the GNU C Library, it is probably best to stick with the functions
described in this section.  If however, you want your program to be
portable, consider using the XPG functions described in *note XPG
Functions::, or take a look at the BSD compatible functions in *note
Logging In and Out::.

==============================================================================
File: libc.info,  Node: |XPG_Functions|,  Next: |Logging_In_and_Out|,  Prev: |Manipulating_the_Database|,  Up: |User_Accounting_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *XPG_Functions*

30.12.2 XPG User Accounting Database Functions
----------------------------------------------

These functions, described in the X/Open Portability Guide, are declared
in the header file 'utmpx.h'.

 -- Data Type: struct utmpx
     The 'utmpx' data structure contains at least the following members:

     'short int ut_type'
          Specifies the type of login; one of 'EMPTY', 'RUN_LVL',
          'BOOT_TIME', 'OLD_TIME', 'NEW_TIME', 'INIT_PROCESS',
          'LOGIN_PROCESS', 'USER_PROCESS' or 'DEAD_PROCESS'.

     'pid_t ut_pid'
          The process ID number of the login process.

     'char ut_line[]'
          The device name of the tty (without '/dev/').

     'char ut_id[]'
          The inittab ID of the process.

     'char ut_user[]'
          The user's login name.

     'struct timeval ut_tv'
          Time the entry was made.  For entries of type 'OLD_TIME' this
          is the time when the system clock changed, and for entries of
          type 'NEW_TIME' this is the time the system clock was set to.
     In the GNU C Library, 'struct utmpx' is identical to 'struct utmp'
     except for the fact that including 'utmpx.h' does not make visible
     the declaration of 'struct exit_status'.

   The following macros are defined for use as values for the 'ut_type'
member of the 'utmpx' structure.  The values are integer constants and
are, in the GNU C Library, identical to the definitions in 'utmp.h'.

'EMPTY'

     This macro is used to indicate that the entry contains no valid
     user accounting information.

'RUN_LVL'

     This macro is used to identify the system's runlevel.

'BOOT_TIME'

     This macro is used to identify the time of system boot.

'OLD_TIME'

     This macro is used to identify the time when the system clock
     changed.

'NEW_TIME'

     This macro is used to identify the time after the system clock
     changed.

'INIT_PROCESS'

     This macro is used to identify a process spawned by the init
     process.

'LOGIN_PROCESS'

     This macro is used to identify the session leader of a logged in
     user.

'USER_PROCESS'

     This macro is used to identify a user process.

'DEAD_PROCESS'

     This macro is used to identify a terminated process.

   The size of the 'ut_line', 'ut_id' and 'ut_user' arrays can be found
using the 'sizeof' operator.

 -- Function: void setutxent (void)

     Preliminary: | MT-Unsafe race:utent | AS-Unsafe lock | AC-Unsafe
     lock fd | *Note POSIX Safety Concepts::.

     This function is similar to 'setutent'.  In the GNU C Library it is
     simply an alias for 'setutent'.

 -- Function: struct utmpx * getutxent (void)

     Preliminary: | MT-Unsafe init race:utent sig:ALRM timer | AS-Unsafe
     heap lock | AC-Unsafe lock fd mem | *Note POSIX Safety Concepts::.

     The 'getutxent' function is similar to 'getutent', but returns a
     pointer to a 'struct utmpx' instead of 'struct utmp'.  In the GNU C
     Library it simply is an alias for 'getutent'.

 -- Function: void endutxent (void)

     Preliminary: | MT-Unsafe race:utent | AS-Unsafe lock | AC-Unsafe
     lock | *Note POSIX Safety Concepts::.

     This function is similar to 'endutent'.  In the GNU C Library it is
     simply an alias for 'endutent'.

 -- Function: struct utmpx * getutxid (const struct utmpx *ID)

     Preliminary: | MT-Unsafe init race:utent sig:ALRM timer | AS-Unsafe
     lock heap | AC-Unsafe lock mem fd | *Note POSIX Safety Concepts::.

     This function is similar to 'getutid', but uses 'struct utmpx'
     instead of 'struct utmp'.  In the GNU C Library it is simply an
     alias for 'getutid'.

 -- Function: struct utmpx * getutxline (const struct utmpx *LINE)

     Preliminary: | MT-Unsafe init race:utent sig:ALRM timer | AS-Unsafe
     heap lock | AC-Unsafe lock fd mem | *Note POSIX Safety Concepts::.

     This function is similar to 'getutid', but uses 'struct utmpx'
     instead of 'struct utmp'.  In the GNU C Library it is simply an
     alias for 'getutline'.

 -- Function: struct utmpx * pututxline (const struct utmpx *UTMP)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     | AC-Unsafe lock fd | *Note POSIX Safety Concepts::.

     The 'pututxline' function is functionally identical to 'pututline',
     but uses 'struct utmpx' instead of 'struct utmp'.  In the GNU C
     Library, 'pututxline' is simply an alias for 'pututline'.

 -- Function: int utmpxname (const char *FILE)

     Preliminary: | MT-Unsafe race:utent | AS-Unsafe lock heap |
     AC-Unsafe lock mem | *Note POSIX Safety Concepts::.

     The 'utmpxname' function is functionally identical to 'utmpname'.
     In the GNU C Library, 'utmpxname' is simply an alias for
     'utmpname'.

   You can translate between a traditional 'struct utmp' and an XPG
'struct utmpx' with the following functions.  In the GNU C Library,
these functions are merely copies, since the two structures are
identical.

 -- Function: int getutmp (const struct utmpx *UTMPX, struct utmp *UTMP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'getutmp' copies the information, insofar as the structures are
     compatible, from UTMPX to UTMP.

 -- Function: int getutmpx (const struct utmp *UTMP, struct utmpx
          *UTMPX)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'getutmpx' copies the information, insofar as the structures are
     compatible, from UTMP to UTMPX.

==============================================================================
File: libc.info,  Node: |Logging_In_and_Out|,  Prev: |XPG_Functions|,  Up: |User_Accounting_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Logging_In_and_Out*

30.12.3 Logging In and Out
--------------------------

These functions, derived from BSD, are available in the separate
'libutil' library, and declared in 'utmp.h'.

   Note that the 'ut_user' member of 'struct utmp' is called 'ut_name'
in BSD. Therefore, 'ut_name' is defined as an alias for 'ut_user' in
'utmp.h'.

 -- Function: int login_tty (int FILEDES)

     Preliminary: | MT-Unsafe race:ttyname | AS-Unsafe heap lock |
     AC-Unsafe lock fd mem | *Note POSIX Safety Concepts::.

     This function makes FILEDES the controlling terminal of the current
     process, redirects standard input, standard output and standard
     error output to this terminal, and closes FILEDES.

     This function returns '0' on successful completion, and '-1' on
     error.

 -- Function: void login (const struct utmp *ENTRY)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     heap | AC-Unsafe lock corrupt fd mem | *Note POSIX Safety
     Concepts::.

     The 'login' functions inserts an entry into the user accounting
     database.  The 'ut_line' member is set to the name of the terminal
     on standard input.  If standard input is not a terminal 'login'
     uses standard output or standard error output to determine the name
     of the terminal.  If 'struct utmp' has a 'ut_type' member, 'login'
     sets it to 'USER_PROCESS', and if there is an 'ut_pid' member, it
     will be set to the process ID of the current process.  The
     remaining entries are copied from ENTRY.

     A copy of the entry is written to the user accounting log file.

 -- Function: int logout (const char *UT_LINE)

     Preliminary: | MT-Unsafe race:utent sig:ALRM timer | AS-Unsafe lock
     heap | AC-Unsafe lock fd mem | *Note POSIX Safety Concepts::.

     This function modifies the user accounting database to indicate
     that the user on UT_LINE has logged out.

     The 'logout' function returns '1' if the entry was successfully
     written to the database, or '0' on error.

 -- Function: void logwtmp (const char *UT_LINE, const char *UT_NAME,
          const char *UT_HOST)

     Preliminary: | MT-Unsafe sig:ALRM timer | AS-Unsafe | AC-Unsafe fd
     | *Note POSIX Safety Concepts::.

     The 'logwtmp' function appends an entry to the user accounting log
     file, for the current time and the information provided in the
     UT_LINE, UT_NAME and UT_HOST arguments.

   *Portability Note:* The BSD 'struct utmp' only has the 'ut_line',
'ut_name', 'ut_host' and 'ut_time' members.  Older systems do not even
have the 'ut_host' member.

==============================================================================
File: libc.info,  Node: |User_Database|,  Next: |Group_Database|,  Prev: |User_Accounting_Database|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *User_Database*

30.13 User Database
=====--------------

This section describes how to search and scan the database of registered
users.  The database itself is kept in the file '/etc/passwd' on most
systems, but on some systems a special network server gives access to
it.

   Historically, this database included one-way hashes of user
passphrases (*note Passphrase Storage::) as well as public information
about each user (such as their user ID and full name).  Many of the
functions and data structures associated with this database, and the
filename '/etc/passwd' itself, reflect this history.  However, the
information in this database is available to all users, and it is no
longer considered safe to make passphrase hashes available to all users,
so they have been moved to a "shadow" database that can only be accessed
with special privileges.

MENU

* |User_Data_Structure|::         What each user record contains.
* |Lookup_User|::                 How to look for a particular user.
* |Scanning_All_Users|::          Scanning the list of all users, one by one.
* |Writing_a_User_Entry|::        How a program can rewrite a user's record.

==============================================================================
File: libc.info,  Node: |User_Data_Structure|,  Next: |Lookup_User|,  Up: |User_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *User_Data_Structure*

30.13.1 The Data Structure that Describes a User
------------------------------------------------

The functions and data structures for accessing the system user database
are declared in the header file 'pwd.h'.

 -- Data Type: struct passwd

     The 'passwd' data structure is used to hold information about
     entries in the system user data base.  It has at least the
     following members:

     'char *pw_name'
          The user's login name.

     'char *pw_passwd'
          Historically, this field would hold the one-way hash of the
          user's passphrase.  Nowadays, it will almost always be the
          single character 'x', indicating that the hash is in the
          shadow database.

     'uid_t pw_uid'
          The user ID number.

     'gid_t pw_gid'
          The user's default group ID number.

     'char *pw_gecos'
          A string typically containing the user's real name, and
          possibly other information such as a phone number.

     'char *pw_dir'
          The user's home directory, or initial working directory.  This
          might be a null pointer, in which case the interpretation is
          system-dependent.

     'char *pw_shell'
          The user's default shell, or the initial program run when the
          user logs in.  This might be a null pointer, indicating that
          the system default should be used.

==============================================================================
File: libc.info,  Node: |Lookup_User|,  Next: |Scanning_All_Users|,  Prev: |User_Data_Structure|,  Up: |User_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Lookup_User*

30.13.2 Looking Up One User
---------------------------

You can search the system user database for information about a specific
user using 'getpwuid' or 'getpwnam'.  These functions are declared in
'pwd.h'.

 -- Function: struct passwd * getpwuid (uid_t UID)

     Preliminary: | MT-Unsafe race:pwuid locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function returns a pointer to a statically-allocated structure
     containing information about the user whose user ID is UID.  This
     structure may be overwritten on subsequent calls to 'getpwuid'.

     A null pointer value indicates there is no user in the data base
     with user ID UID.

 -- Function: int getpwuid_r (uid_t UID, struct passwd *RESULT_BUF, char
          *BUFFER, size_t BUFLEN, struct passwd **RESULT)

     Preliminary: | MT-Safe locale | AS-Unsafe dlopen plugin heap lock |
     AC-Unsafe corrupt lock fd mem | *Note POSIX Safety Concepts::.

     This function is similar to 'getpwuid' in that it returns
     information about the user whose user ID is UID.  However, it fills
     the user supplied structure pointed to by RESULT_BUF with the
     information instead of using a static buffer.  The first BUFLEN
     bytes of the additional buffer pointed to by BUFFER are used to
     contain additional information, normally strings which are pointed
     to by the elements of the result structure.

     If a user with ID UID is found, the pointer returned in RESULT
     points to the record which contains the wanted data (i.e., RESULT
     contains the value RESULT_BUF).  If no user is found or if an error
     occurred, the pointer returned in RESULT is a null pointer.  The
     function returns zero or an error code.  If the buffer BUFFER is
     too small to contain all the needed information, the error code
     'ERANGE' is returned and ERRNO is set to 'ERANGE'.

 -- Function: struct passwd * getpwnam (const char *NAME)

     Preliminary: | MT-Unsafe race:pwnam locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function returns a pointer to a statically-allocated structure
     containing information about the user whose user name is NAME.
     This structure may be overwritten on subsequent calls to
     'getpwnam'.

     A null pointer return indicates there is no user named NAME.

 -- Function: int getpwnam_r (const char *NAME, struct passwd
          *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd
          **RESULT)

     Preliminary: | MT-Safe locale | AS-Unsafe dlopen plugin heap lock |
     AC-Unsafe corrupt lock fd mem | *Note POSIX Safety Concepts::.

     This function is similar to 'getpwnam' in that it returns
     information about the user whose user name is NAME.  However, like
     'getpwuid_r', it fills the user supplied buffers in RESULT_BUF and
     BUFFER with the information instead of using a static buffer.

     The return values are the same as for 'getpwuid_r'.

==============================================================================
File: libc.info,  Node: |Scanning_All_Users|,  Next: |Writing_a_User_Entry|,  Prev: |Lookup_User|,  Up: |User_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Scanning_All_Users*

30.13.3 Scanning the List of All Users
--------------------------------------

This section explains how a program can read the list of all users in
the system, one user at a time.  The functions described here are
declared in 'pwd.h'.

   You can use the 'fgetpwent' function to read user entries from a
particular file.

 -- Function: struct passwd * fgetpwent (FILE *STREAM)

     Preliminary: | MT-Unsafe race:fpwent | AS-Unsafe corrupt lock |
     AC-Unsafe corrupt lock | *Note POSIX Safety Concepts::.

     This function reads the next user entry from STREAM and returns a
     pointer to the entry.  The structure is statically allocated and is
     rewritten on subsequent calls to 'fgetpwent'.  You must copy the
     contents of the structure if you wish to save the information.

     The stream must correspond to a file in the same format as the
     standard user database file.

 -- Function: int fgetpwent_r (FILE *STREAM, struct passwd *RESULT_BUF,
          char *BUFFER, size_t BUFLEN, struct passwd **RESULT)

     Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock
     | *Note POSIX Safety Concepts::.

     This function is similar to 'fgetpwent' in that it reads the next
     user entry from STREAM.  But the result is returned in the
     structure pointed to by RESULT_BUF.  The first BUFLEN bytes of the
     additional buffer pointed to by BUFFER are used to contain
     additional information, normally strings which are pointed to by
     the elements of the result structure.

     The stream must correspond to a file in the same format as the
     standard user database file.

     If the function returns zero RESULT points to the structure with
     the wanted data (normally this is in RESULT_BUF).  If errors
     occurred the return value is nonzero and RESULT contains a null
     pointer.

   The way to scan all the entries in the user database is with
'setpwent', 'getpwent', and 'endpwent'.

 -- Function: void setpwent (void)

     Preliminary: | MT-Unsafe race:pwent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function initializes a stream which 'getpwent' and
     'getpwent_r' use to read the user database.

 -- Function: struct passwd * getpwent (void)

     Preliminary: | MT-Unsafe race:pwent race:pwentbuf locale |
     AS-Unsafe dlopen plugin heap lock | AC-Unsafe corrupt lock fd mem |
     *Note POSIX Safety Concepts::.

     The 'getpwent' function reads the next entry from the stream
     initialized by 'setpwent'.  It returns a pointer to the entry.  The
     structure is statically allocated and is rewritten on subsequent
     calls to 'getpwent'.  You must copy the contents of the structure
     if you wish to save the information.

     A null pointer is returned when no more entries are available.

 -- Function: int getpwent_r (struct passwd *RESULT_BUF, char *BUFFER,
          size_t BUFLEN, struct passwd **RESULT)

     Preliminary: | MT-Unsafe race:pwent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function is similar to 'getpwent' in that it returns the next
     entry from the stream initialized by 'setpwent'.  Like
     'fgetpwent_r', it uses the user-supplied buffers in RESULT_BUF and
     BUFFER to return the information requested.

     The return values are the same as for 'fgetpwent_r'.

 -- Function: void endpwent (void)

     Preliminary: | MT-Unsafe race:pwent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function closes the internal stream used by 'getpwent' or
     'getpwent_r'.

==============================================================================
File: libc.info,  Node: |Writing_a_User_Entry|,  Prev: |Scanning_All_Users|,  Up: |User_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Writing_a_User_Entry*

30.13.4 Writing a User Entry
----------------------------

 -- Function: int putpwent (const struct passwd *P, FILE *STREAM)

     Preliminary: | MT-Safe locale | AS-Unsafe corrupt | AC-Unsafe lock
     corrupt | *Note POSIX Safety Concepts::.

     This function writes the user entry '*P' to the stream STREAM, in
     the format used for the standard user database file.  The return
     value is zero on success and nonzero on failure.

     This function exists for compatibility with SVID. We recommend that
     you avoid using it, because it makes sense only on the assumption
     that the 'struct passwd' structure has no members except the
     standard ones; on a system which merges the traditional Unix data
     base with other extended information about users, adding an entry
     using this function would inevitably leave out much of the
     important information.

     The group and user ID fields are left empty if the group or user
     name starts with a - or +.

     The function 'putpwent' is declared in 'pwd.h'.

==============================================================================
File: libc.info,  Node: |Group_Database|,  Next: |Database_Example|,  Prev: |User_Database|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Group_Database*

30.14 Group Database
=====---------------

This section describes how to search and scan the database of registered
groups.  The database itself is kept in the file '/etc/group' on most
systems, but on some systems a special network service provides access
to it.

MENU

* |Group_Data_Structure|::        What each group record contains.
* |Lookup_Group|::                How to look for a particular group.
* |Scanning_All_Groups|::         Scanning the list of all groups.

==============================================================================
File: libc.info,  Node: |Group_Data_Structure|,  Next: |Lookup_Group|,  Up: |Group_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Group_Data_Structure*

30.14.1 The Data Structure for a Group
--------------------------------------

The functions and data structures for accessing the system group
database are declared in the header file 'grp.h'.

 -- Data Type: struct group

     The 'group' structure is used to hold information about an entry in
     the system group database.  It has at least the following members:

     'char *gr_name'
          The name of the group.

     'gid_t gr_gid'
          The group ID of the group.

     'char **gr_mem'
          A vector of pointers to the names of users in the group.  Each
          user name is a null-terminated string, and the vector itself
          is terminated by a null pointer.

==============================================================================
File: libc.info,  Node: |Lookup_Group|,  Next: |Scanning_All_Groups|,  Prev: |Group_Data_Structure|,  Up: |Group_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Lookup_Group*

30.14.2 Looking Up One Group
----------------------------

You can search the group database for information about a specific group
using 'getgrgid' or 'getgrnam'.  These functions are declared in
'grp.h'.

 -- Function: struct group * getgrgid (gid_t GID)

     Preliminary: | MT-Unsafe race:grgid locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function returns a pointer to a statically-allocated structure
     containing information about the group whose group ID is GID.  This
     structure may be overwritten by subsequent calls to 'getgrgid'.

     A null pointer indicates there is no group with ID GID.

 -- Function: int getgrgid_r (gid_t GID, struct group *RESULT_BUF, char
          *BUFFER, size_t BUFLEN, struct group **RESULT)

     Preliminary: | MT-Safe locale | AS-Unsafe dlopen plugin heap lock |
     AC-Unsafe corrupt lock fd mem | *Note POSIX Safety Concepts::.

     This function is similar to 'getgrgid' in that it returns
     information about the group whose group ID is GID.  However, it
     fills the user supplied structure pointed to by RESULT_BUF with the
     information instead of using a static buffer.  The first BUFLEN
     bytes of the additional buffer pointed to by BUFFER are used to
     contain additional information, normally strings which are pointed
     to by the elements of the result structure.

     If a group with ID GID is found, the pointer returned in RESULT
     points to the record which contains the wanted data (i.e., RESULT
     contains the value RESULT_BUF).  If no group is found or if an
     error occurred, the pointer returned in RESULT is a null pointer.
     The function returns zero or an error code.  If the buffer BUFFER
     is too small to contain all the needed information, the error code
     'ERANGE' is returned and ERRNO is set to 'ERANGE'.

 -- Function: struct group * getgrnam (const char *NAME)

     Preliminary: | MT-Unsafe race:grnam locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function returns a pointer to a statically-allocated structure
     containing information about the group whose group name is NAME.
     This structure may be overwritten by subsequent calls to
     'getgrnam'.

     A null pointer indicates there is no group named NAME.

 -- Function: int getgrnam_r (const char *NAME, struct group
          *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group
          **RESULT)

     Preliminary: | MT-Safe locale | AS-Unsafe dlopen plugin heap lock |
     AC-Unsafe corrupt lock fd mem | *Note POSIX Safety Concepts::.

     This function is similar to 'getgrnam' in that it returns
     information about the group whose group name is NAME.  Like
     'getgrgid_r', it uses the user supplied buffers in RESULT_BUF and
     BUFFER, not a static buffer.

     The return values are the same as for 'getgrgid_r'.

==============================================================================
File: libc.info,  Node: |Scanning_All_Groups|,  Prev: |Lookup_Group|,  Up: |Group_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Scanning_All_Groups*

30.14.3 Scanning the List of All Groups
---------------------------------------

This section explains how a program can read the list of all groups in
the system, one group at a time.  The functions described here are
declared in 'grp.h'.

   You can use the 'fgetgrent' function to read group entries from a
particular file.

 -- Function: struct group * fgetgrent (FILE *STREAM)

     Preliminary: | MT-Unsafe race:fgrent | AS-Unsafe corrupt lock |
     AC-Unsafe corrupt lock | *Note POSIX Safety Concepts::.

     The 'fgetgrent' function reads the next entry from STREAM.  It
     returns a pointer to the entry.  The structure is statically
     allocated and is overwritten on subsequent calls to 'fgetgrent'.
     You must copy the contents of the structure if you wish to save the
     information.

     The stream must correspond to a file in the same format as the
     standard group database file.

 -- Function: int fgetgrent_r (FILE *STREAM, struct group *RESULT_BUF,
          char *BUFFER, size_t BUFLEN, struct group **RESULT)

     Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Unsafe corrupt lock
     | *Note POSIX Safety Concepts::.

     This function is similar to 'fgetgrent' in that it reads the next
     user entry from STREAM.  But the result is returned in the
     structure pointed to by RESULT_BUF.  The first BUFLEN bytes of the
     additional buffer pointed to by BUFFER are used to contain
     additional information, normally strings which are pointed to by
     the elements of the result structure.

     This stream must correspond to a file in the same format as the
     standard group database file.

     If the function returns zero RESULT points to the structure with
     the wanted data (normally this is in RESULT_BUF).  If errors
     occurred the return value is non-zero and RESULT contains a null
     pointer.

   The way to scan all the entries in the group database is with
'setgrent', 'getgrent', and 'endgrent'.

 -- Function: void setgrent (void)

     Preliminary: | MT-Unsafe race:grent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function initializes a stream for reading from the group data
     base.  You use this stream by calling 'getgrent' or 'getgrent_r'.

 -- Function: struct group * getgrent (void)

     Preliminary: | MT-Unsafe race:grent race:grentbuf locale |
     AS-Unsafe dlopen plugin heap lock | AC-Unsafe corrupt lock fd mem |
     *Note POSIX Safety Concepts::.

     The 'getgrent' function reads the next entry from the stream
     initialized by 'setgrent'.  It returns a pointer to the entry.  The
     structure is statically allocated and is overwritten on subsequent
     calls to 'getgrent'.  You must copy the contents of the structure
     if you wish to save the information.

 -- Function: int getgrent_r (struct group *RESULT_BUF, char *BUFFER,
          size_t BUFLEN, struct group **RESULT)

     Preliminary: | MT-Unsafe race:grent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function is similar to 'getgrent' in that it returns the next
     entry from the stream initialized by 'setgrent'.  Like
     'fgetgrent_r', it places the result in user-supplied buffers
     pointed to by RESULT_BUF and BUFFER.

     If the function returns zero RESULT contains a pointer to the data
     (normally equal to RESULT_BUF).  If errors occurred the return
     value is non-zero and RESULT contains a null pointer.

 -- Function: void endgrent (void)

     Preliminary: | MT-Unsafe race:grent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function closes the internal stream used by 'getgrent' or
     'getgrent_r'.

==============================================================================
File: libc.info,  Node: |Database_Example|,  Next: |Netgroup_Database|,  Prev: |Group_Database|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Database_Example*

30.15 User and Group Database Example
=====--------------------------------

Here is an example program showing the use of the system database
inquiry functions.  The program prints some information about the user
running the program.


     #include <grp.h>
     #include <pwd.h>
     #include <sys/types.h>
     #include <unistd.h>
     #include <stdlib.h>

     int
     main (void)
     {
       uid_t me;
       struct passwd *my_passwd;
       struct group *my_group;
       char **members;

       /* Get information about the user ID. */
       me = getuid ();
       my_passwd = getpwuid (me);
       if (!my_passwd)
         {
           printf ("Couldn't find out about user %d.\n", (int) me);
           exit (EXIT_FAILURE);
         }

       /* Print the information. */
       printf ("I am %s.\n", my_passwd->pw_gecos);
       printf ("My login name is %s.\n", my_passwd->pw_name);
       printf ("My uid is %d.\n", (int) (my_passwd->pw_uid));
       printf ("My home directory is %s.\n", my_passwd->pw_dir);
       printf ("My default shell is %s.\n", my_passwd->pw_shell);

       /* Get information about the default group ID. */
       my_group = getgrgid (my_passwd->pw_gid);
       if (!my_group)
         {
           printf ("Couldn't find out about group %d.\n",
                   (int) my_passwd->pw_gid);
           exit (EXIT_FAILURE);
         }

       /* Print the information. */
       printf ("My default group is %s (%d).\n",
               my_group->gr_name, (int) (my_passwd->pw_gid));
       printf ("The members of this group are:\n");
       members = my_group->gr_mem;
       while (*members)
         {
           printf ("  %s\n", *(members));
           members++;
         }

       return EXIT_SUCCESS;
     }

   Here is some output from this program:

     I am Throckmorton Snurd.
     My login name is snurd.
     My uid is 31093.
     My home directory is /home/fsg/snurd.
     My default shell is /bin/sh.
     My default group is guest (12).
     The members of this group are:
       friedman
       tami

==============================================================================
File: libc.info,  Node: |Netgroup_Database|,  Prev: |Database_Example|,  Up: |Users_and_Groups|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Netgroup_Database*

30.16 Netgroup Database
=====------------------

MENU

* |Netgroup_Data|::                  Data in the Netgroup database and where
                                   it comes from.
* |Lookup_Netgroup|::                How to look for a particular netgroup.
* |Netgroup_Membership|::            How to test for netgroup membership.

==============================================================================
File: libc.info,  Node: |Netgroup_Data|,  Next: |Lookup_Netgroup|,  Up: |Netgroup_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Netgroup_Data*

30.16.1 Netgroup Data
---------------------

Sometimes it is useful to group users according to other criteria (*note
Group Database::).  E.g., it is useful to associate a certain group of
users with a certain machine.  On the other hand grouping of host names
is not supported so far.

   In Sun Microsystems' SunOS appeared a new kind of database, the
netgroup database.  It allows grouping hosts, users, and domains freely,
giving them individual names.  To be more concrete, a netgroup is a list
of triples consisting of a host name, a user name, and a domain name
where any of the entries can be a wildcard entry matching all inputs.  A
last possibility is that names of other netgroups can also be given in
the list specifying a netgroup.  So one can construct arbitrary
hierarchies without loops.

   Sun's implementation allows netgroups only for the 'nis' or 'nisplus'
service, *note Services in the NSS configuration::.  The implementation
in the GNU C Library has no such restriction.  An entry in either of the
input services must have the following form:

     GROUPNAME ( GROUPNAME | (HOSTNAME,USERNAME,domainname) )+

   Any of the fields in the triple can be empty which means anything
matches.  While describing the functions we will see that the opposite
case is useful as well.  I.e., there may be entries which will not match
any input.  For entries like this, a name consisting of the single
character '-' shall be used.

==============================================================================
File: libc.info,  Node: |Lookup_Netgroup|,  Next: |Netgroup_Membership|,  Prev: |Netgroup_Data|,  Up: |Netgroup_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Lookup_Netgroup*

30.16.2 Looking up one Netgroup
-------------------------------

The lookup functions for netgroups are a bit different than all other
system database handling functions.  Since a single netgroup can contain
many entries a two-step process is needed.  First a single netgroup is
selected and then one can iterate over all entries in this netgroup.
These functions are declared in 'netdb.h'.

 -- Function: int setnetgrent (const char *NETGROUP)

     Preliminary: | MT-Unsafe race:netgrent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     A call to this function initializes the internal state of the
     library to allow following calls of 'getnetgrent' to iterate over
     all entries in the netgroup with name NETGROUP.

     When the call is successful (i.e., when a netgroup with this name
     exists) the return value is '1'.  When the return value is '0' no
     netgroup of this name is known or some other error occurred.

   It is important to remember that there is only one single state for
iterating the netgroups.  Even if the programmer uses the
'getnetgrent_r' function the result is not really reentrant since always
only one single netgroup at a time can be processed.  If the program
needs to process more than one netgroup simultaneously she must protect
this by using external locking.  This problem was introduced in the
original netgroups implementation in SunOS and since we must stay
compatible it is not possible to change this.

   Some other functions also use the netgroups state.  Currently these
are the 'innetgr' function and parts of the implementation of the
'compat' service part of the NSS implementation.

 -- Function: int getnetgrent (char **HOSTP, char **USERP, char
          **DOMAINP)

     Preliminary: | MT-Unsafe race:netgrent race:netgrentbuf locale |
     AS-Unsafe dlopen plugin heap lock | AC-Unsafe corrupt lock fd mem |
     *Note POSIX Safety Concepts::.

     This function returns the next unprocessed entry of the currently
     selected netgroup.  The string pointers, in which addresses are
     passed in the arguments HOSTP, USERP, and DOMAINP, will contain
     after a successful call pointers to appropriate strings.  If the
     string in the next entry is empty the pointer has the value 'NULL'.
     The returned string pointers are only valid if none of the netgroup
     related functions are called.

     The return value is '1' if the next entry was successfully read.  A
     value of '0' means no further entries exist or internal errors
     occurred.

 -- Function: int getnetgrent_r (char **HOSTP, char **USERP, char
          **DOMAINP, char *BUFFER, size_t BUFLEN)

     Preliminary: | MT-Unsafe race:netgrent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function is similar to 'getnetgrent' with only one exception:
     the strings the three string pointers HOSTP, USERP, and DOMAINP
     point to, are placed in the buffer of BUFLEN bytes starting at
     BUFFER.  This means the returned values are valid even after other
     netgroup related functions are called.

     The return value is '1' if the next entry was successfully read and
     the buffer contains enough room to place the strings in it.  '0' is
     returned in case no more entries are found, the buffer is too
     small, or internal errors occurred.

     This function is a GNU extension.  The original implementation in
     the SunOS libc does not provide this function.

 -- Function: void endnetgrent (void)

     Preliminary: | MT-Unsafe race:netgrent | AS-Unsafe dlopen plugin
     heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX Safety
     Concepts::.

     This function frees all buffers which were allocated to process the
     last selected netgroup.  As a result all string pointers returned
     by calls to 'getnetgrent' are invalid afterwards.

==============================================================================
File: libc.info,  Node: |Netgroup_Membership|,  Prev: |Lookup_Netgroup|,  Up: |Netgroup_Database|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Netgroup_Membership*

30.16.3 Testing for Netgroup Membership
---------------------------------------

It is often not necessary to scan the whole netgroup since often the
only interesting question is whether a given entry is part of the
selected netgroup.

 -- Function: int innetgr (const char *NETGROUP, const char *HOST, const
          char *USER, const char *DOMAIN)

     Preliminary: | MT-Unsafe race:netgrent locale | AS-Unsafe dlopen
     plugin heap lock | AC-Unsafe corrupt lock fd mem | *Note POSIX
     Safety Concepts::.

     This function tests whether the triple specified by the parameters
     HOST, USER, and DOMAIN is part of the netgroup NETGROUP.  Using
     this function has the advantage that

       1. no other netgroup function can use the global netgroup state
          since internal locking is used and
       2. the function is implemented more efficiently than successive
          calls to the other 'set'/'get'/'endnetgrent' functions.

     Any of the pointers HOST, USER, or DOMAIN can be 'NULL' which means
     any value is accepted in this position.  This is also true for the
     name '-' which should not match any other string otherwise.

     The return value is '1' if an entry matching the given triple is
     found in the netgroup.  The return value is '0' if the netgroup
     itself is not found, the netgroup does not contain the triple or
     internal errors occurred.

==============================================================================
File: libc.info,  Node: |System_Management|,  Next: |System_Configuration|,  Prev: |Users_and_Groups|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *System_Management*

31 System Management
*****===============

This chapter describes facilities for controlling the system that
underlies a process (including the operating system and hardware) and
for getting information about it.  Anyone can generally use the
informational facilities, but usually only a properly privileged process
can make changes.

MENU

* |Host_Identification|::         Determining the name of the machine.
* |Platform_Type|::               Determining operating system and basic
                                  machine type
* |Filesystem_Handling|::         Controlling/querying mounts
* |System_Parameters|::           Getting and setting various system parameters

   To get information on parameters of the system that are built into
the system, such as the maximum length of a filename, *note System
Configuration::.

==============================================================================
File: libc.info,  Node: |Host_Identification|,  Next: |Platform_Type|,  Up: |System_Management|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Host_Identification*

31.1 Host Identification
=====-------------------

This section explains how to identify the particular system on which
your program is running.  First, let's review the various ways computer
systems are named, which is a little complicated because of the history
of the development of the Internet.

   Every Unix system (also known as a host) has a host name, whether
it's connected to a network or not.  In its simplest form, as used
before computer networks were an issue, it's just a word like 'chicken'.

   But any system attached to the Internet or any network like it
conforms to a more rigorous naming convention as part of the Domain Name
System (DNS). In the DNS, every host name is composed of two parts:

  1. hostname
  2. domain name

   You will note that "hostname" looks a lot like "host name", but is
not the same thing, and that people often incorrectly refer to entire
host names as "domain names."

   In the DNS, the full host name is properly called the FQDN (Fully
Qualified Domain Name) and consists of the hostname, then a period, then
the domain name.  The domain name itself usually has multiple components
separated by periods.  So for example, a system's hostname may be
'chicken' and its domain name might be 'ai.mit.edu', so its FQDN (which
is its host name) is 'chicken.ai.mit.edu'.

   Adding to the confusion, though, is that the DNS is not the only name
space in which a computer needs to be known.  Another name space is the
NIS (aka YP) name space.  For NIS purposes, there is another domain
name, which is called the NIS domain name or the YP domain name.  It
need not have anything to do with the DNS domain name.

   Confusing things even more is the fact that in the DNS, it is
possible for multiple FQDNs to refer to the same system.  However, there
is always exactly one of them that is the true host name, and it is
called the canonical FQDN.

   In some contexts, the host name is called a "node name."

   For more information on DNS host naming, see *note Host Names::.

   Prototypes for these functions appear in 'unistd.h'.

   The programs 'hostname', 'hostid', and 'domainname' work by calling
these functions.

 -- Function: int gethostname (char *NAME, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns the host name of the system on which it is
     called, in the array NAME.  The SIZE argument specifies the size of
     this array, in bytes.  Note that this is _not_ the DNS hostname.
     If the system participates in the DNS, this is the FQDN (see
     above).

     The return value is '0' on success and '-1' on failure.  In the GNU
     C Library, 'gethostname' fails if SIZE is not large enough; then
     you can try again with a larger array.  The following 'errno' error
     condition is defined for this function:

     'ENAMETOOLONG'
          The SIZE argument is less than the size of the host name plus
          one.

     On some systems, there is a symbol for the maximum possible host
     name length: 'MAXHOSTNAMELEN'.  It is defined in 'sys/param.h'.
     But you can't count on this to exist, so it is cleaner to handle
     failure and try again.

     'gethostname' stores the beginning of the host name in NAME even if
     the host name won't entirely fit.  For some purposes, a truncated
     host name is good enough.  If it is, you can ignore the error code.

 -- Function: int sethostname (const char *NAME, size_t LENGTH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'sethostname' function sets the host name of the system that
     calls it to NAME, a string with length LENGTH.  Only privileged
     processes are permitted to do this.

     Usually 'sethostname' gets called just once, at system boot time.
     Often, the program that calls it sets it to the value it finds in
     the file '/etc/hostname'.

     Be sure to set the host name to the full host name, not just the
     DNS hostname (see above).

     The return value is '0' on success and '-1' on failure.  The
     following 'errno' error condition is defined for this function:

     'EPERM'
          This process cannot set the host name because it is not
          privileged.

 -- Function: int getdomainnname (char *NAME, size_t LENGTH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'getdomainname' returns the NIS (aka YP) domain name of the system
     on which it is called.  Note that this is not the more popular DNS
     domain name.  Get that with 'gethostname'.

     The specifics of this function are analogous to 'gethostname',
     above.

 -- Function: int setdomainname (const char *NAME, size_t LENGTH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'setdomainname' sets the NIS (aka YP) domain name of the system on
     which it is called.  Note that this is not the more popular DNS
     domain name.  Set that with 'sethostname'.

     The specifics of this function are analogous to 'sethostname',
     above.

 -- Function: long int gethostid (void)

     Preliminary: | MT-Safe hostid env locale | AS-Unsafe dlopen plugin
     corrupt heap lock | AC-Unsafe lock corrupt mem fd | *Note POSIX
     Safety Concepts::.

     This function returns the "host ID" of the machine the program is
     running on.  By convention, this is usually the primary Internet IP
     address of that machine, converted to a 'long int'.  However, on
     some systems it is a meaningless but unique number which is
     hard-coded for each machine.

     This is not widely used.  It arose in BSD 4.2, but was dropped in
     BSD 4.4.  It is not required by POSIX.

     The proper way to query the IP address is to use 'gethostbyname' on
     the results of 'gethostname'.  For more information on IP
     addresses, *Note Host Addresses::.

 -- Function: int sethostid (long int ID)

     Preliminary: | MT-Unsafe const:hostid | AS-Unsafe | AC-Unsafe
     corrupt fd | *Note POSIX Safety Concepts::.

     The 'sethostid' function sets the "host ID" of the host machine to
     ID.  Only privileged processes are permitted to do this.  Usually
     it happens just once, at system boot time.

     The proper way to establish the primary IP address of a system is
     to configure the IP address resolver to associate that IP address
     with the system's host name as returned by 'gethostname'.  For
     example, put a record for the system in '/etc/hosts'.

     See 'gethostid' above for more information on host ids.

     The return value is '0' on success and '-1' on failure.  The
     following 'errno' error conditions are defined for this function:

     'EPERM'
          This process cannot set the host name because it is not
          privileged.

     'ENOSYS'
          The operating system does not support setting the host ID. On
          some systems, the host ID is a meaningless but unique number
          hard-coded for each machine.

==============================================================================
File: libc.info,  Node: |Platform_Type|,  Next: |Filesystem_Handling|,  Prev: |Host_Identification|,  Up: |System_Management|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Platform_Type*

31.2 Platform Type Identification
=====----------------------------

You can use the 'uname' function to find out some information about the
type of computer your program is running on.  This function and the
associated data type are declared in the header file 'sys/utsname.h'.

   As a bonus, 'uname' also gives some information identifying the
particular system your program is running on.  This is the same
information which you can get with functions targeted to this purpose
described in *note Host Identification::.

 -- Data Type: struct utsname

     The 'utsname' structure is used to hold information returned by the
     'uname' function.  It has the following members:

     'char sysname[]'
          This is the name of the operating system in use.

     'char release[]'
          This is the current release level of the operating system
          implementation.

     'char version[]'
          This is the current version level within the release of the
          operating system.

     'char machine[]'
          This is a description of the type of hardware that is in use.

          Some systems provide a mechanism to interrogate the kernel
          directly for this information.  On systems without such a
          mechanism, the GNU C Library fills in this field based on the
          configuration name that was specified when building and
          installing the library.

          GNU uses a three-part name to describe a system configuration;
          the three parts are CPU, MANUFACTURER and SYSTEM-TYPE, and
          they are separated with dashes.  Any possible combination of
          three names is potentially meaningful, but most such
          combinations are meaningless in practice and even the
          meaningful ones are not necessarily supported by any
          particular GNU program.

          Since the value in 'machine' is supposed to describe just the
          hardware, it consists of the first two parts of the
          configuration name: 'CPU-MANUFACTURER'.  For example, it might
          be one of these:

               '"sparc-sun"', '"i386-ANYTHING"', '"m68k-hp"',
               '"m68k-sony"', '"m68k-sun"', '"mips-dec"'

     'char nodename[]'
          This is the host name of this particular computer.  In the GNU
          C Library, the value is the same as that returned by
          'gethostname'; see *note Host Identification::.

          'gethostname' is implemented with a call to 'uname'.

     'char domainname[]'
          This is the NIS or YP domain name.  It is the same value
          returned by 'getdomainname'; see *note Host Identification::.
          This element is a relatively recent invention and use of it is
          not as portable as use of the rest of the structure.

 -- Function: int uname (struct utsname *INFO)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'uname' function fills in the structure pointed to by INFO with
     information about the operating system and host machine.  A
     non-negative return value indicates that the data was successfully
     stored.

     '-1' as the return value indicates an error.  The only error
     possible is 'EFAULT', which we normally don't mention as it is
     always a possibility.

==============================================================================
File: libc.info,  Node: |Filesystem_Handling|,  Next: |System_Parameters|,  Prev: |Platform_Type|,  Up: |System_Management|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Filesystem_Handling*

31.3 Controlling and Querying Mounts
=====-------------------------------

All files are in filesystems, and before you can access any file, its
filesystem must be mounted.  Because of Unix's concept of _Everything is
a file_, mounting of filesystems is central to doing almost anything.
This section explains how to find out what filesystems are currently
mounted and what filesystems are available for mounting, and how to
change what is mounted.

   The classic filesystem is the contents of a disk drive.  The concept
is considerably more abstract, though, and lots of things other than
disk drives can be mounted.

   Some block devices don't correspond to traditional devices like disk
drives.  For example, a loop device is a block device whose driver uses
a regular file in another filesystem as its medium.  So if that regular
file contains appropriate data for a filesystem, you can by mounting the
loop device essentially mount a regular file.

   Some filesystems aren't based on a device of any kind.  The "proc"
filesystem, for example, contains files whose data is made up by the
filesystem driver on the fly whenever you ask for it.  And when you
write to it, the data you write causes changes in the system.  No data
gets stored.

MENU

* |Mount_Information|::           What is or could be mounted?
* |Mount_Unmount_Remount|::       Controlling what is mounted and how

==============================================================================
File: libc.info,  Node: |Mount_Information|,  Next: |Mount_Unmount_Remount|,  Up: Filesystem Handling
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Mount_Information*

31.3.1 Mount Information
------------------------

For some programs it is desirable and necessary to access information
about whether a certain filesystem is mounted and, if it is, where, or
simply to get lists of all the available filesystems.  The GNU C Library
provides some functions to retrieve this information portably.

   Traditionally Unix systems have a file named '/etc/fstab' which
describes all possibly mounted filesystems.  The 'mount' program uses
this file to mount at startup time of the system all the necessary
filesystems.  The information about all the filesystems actually mounted
is normally kept in a file named either '/var/run/mtab' or '/etc/mtab'.
Both files share the same syntax and it is crucial that this syntax is
followed all the time.  Therefore it is best to never directly write to
the files.  The functions described in this section can do this and they
also provide the functionality to convert the external textual
representation to the internal representation.

   Note that the 'fstab' and 'mtab' files are maintained on a system by
_convention_.  It is possible for the files not to exist or not to be
consistent with what is really mounted or available to mount, if the
system's administration policy allows it.  But programs that mount and
unmount filesystems typically maintain and use these files as described
herein.

   The filenames given above should never be used directly.  The
portable way to handle these files is to use the macros '_PATH_FSTAB',
defined in 'fstab.h', or '_PATH_MNTTAB', defined in 'mntent.h' and
'paths.h', for 'fstab'; and the macro '_PATH_MOUNTED', also defined in
'mntent.h' and 'paths.h', for 'mtab'.  There are also two alternate
macro names 'FSTAB', 'MNTTAB', and 'MOUNTED' defined but these names are
deprecated and kept only for backward compatibility.  The names
'_PATH_MNTTAB' and '_PATH_MOUNTED' should always be used.

MENU

* |fstab|::                       The 'fstab' file
* |mtab|::                        The 'mtab' file
* |Other_Mount_Information|::     Other (non-libc) sources of mount information

==============================================================================
File: libc.info,  Node: |fstab|,  Next: |mtab|,  Up: Mount Information
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *fstab*

31.3.1.1 The 'fstab' file
.....--------------------

The internal representation for entries of the file is 'struct fstab',
defined in 'fstab.h'.

 -- Data Type: struct fstab

     This structure is used with the 'getfsent', 'getfsspec', and
     'getfsfile' functions.

     'char *fs_spec'
          This element describes the device from which the filesystem is
          mounted.  Normally this is the name of a special device, such
          as a hard disk partition, but it could also be a more or less
          generic string.  For "NFS" it would be a hostname and
          directory name combination.

          Even though the element is not declared 'const' it shouldn't
          be modified.  The missing 'const' has historic reasons, since
          this function predates ISO C. The same is true for the other
          string elements of this structure.

     'char *fs_file'
          This describes the mount point on the local system.  I.e.,
          accessing any file in this filesystem has implicitly or
          explicitly this string as a prefix.

     'char *fs_vfstype'
          This is the type of the filesystem.  Depending on what the
          underlying kernel understands it can be any string.

     'char *fs_mntops'
          This is a string containing options passed to the kernel with
          the 'mount' call.  Again, this can be almost anything.  There
          can be more than one option, separated from the others by a
          comma.  Each option consists of a name and an optional value
          part, introduced by an '=' character.

          If the value of this element must be processed it should
          ideally be done using the 'getsubopt' function; see *note
          Suboptions::.

     'const char *fs_type'
          This name is poorly chosen.  This element points to a string
          (possibly in the 'fs_mntops' string) which describes the modes
          with which the filesystem is mounted.  'fstab' defines five
          macros to describe the possible values:

          'FSTAB_RW'
               The filesystem gets mounted with read and write enabled.
          'FSTAB_RQ'
               The filesystem gets mounted with read and write enabled.
               Write access is restricted by quotas.
          'FSTAB_RO'
               The filesystem gets mounted read-only.
          'FSTAB_SW'
               This is not a real filesystem, it is a swap device.
          'FSTAB_XX'
               This entry from the 'fstab' file is totally ignored.

          Testing for equality with these values must happen using
          'strcmp' since these are all strings.  Comparing the pointer
          will probably always fail.

     'int fs_freq'
          This element describes the dump frequency in days.

     'int fs_passno'
          This element describes the pass number on parallel dumps.  It
          is closely related to the 'dump' utility used on Unix systems.

   To read the entire content of the of the 'fstab' file the GNU C
Library contains a set of three functions which are designed in the
usual way.

 -- Function: int setfsent (void)

     Preliminary: | MT-Unsafe race:fsent | AS-Unsafe heap corrupt lock |
     AC-Unsafe corrupt lock mem fd | *Note POSIX Safety Concepts::.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
