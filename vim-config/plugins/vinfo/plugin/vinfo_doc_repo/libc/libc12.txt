
     This function makes sure that the internal read pointer for the
     'fstab' file is at the beginning of the file.  This is done by
     either opening the file or resetting the read pointer.

     Since the file handle is internal to the libc this function is not
     thread-safe.

     This function returns a non-zero value if the operation was
     successful and the 'getfs*' functions can be used to read the
     entries of the file.

 -- Function: void endfsent (void)

     Preliminary: | MT-Unsafe race:fsent | AS-Unsafe heap corrupt lock |
     AC-Unsafe corrupt lock mem fd | *Note POSIX Safety Concepts::.

     This function makes sure that all resources acquired by a prior
     call to 'setfsent' (explicitly or implicitly by calling 'getfsent')
     are freed.

 -- Function: struct fstab * getfsent (void)

     Preliminary: | MT-Unsafe race:fsent locale | AS-Unsafe corrupt heap
     lock | AC-Unsafe corrupt lock mem | *Note POSIX Safety Concepts::.

     This function returns the next entry of the 'fstab' file.  If this
     is the first call to any of the functions handling 'fstab' since
     program start or the last call of 'endfsent', the file will be
     opened.

     The function returns a pointer to a variable of type 'struct
     fstab'.  This variable is shared by all threads and therefore this
     function is not thread-safe.  If an error occurred 'getfsent'
     returns a 'NULL' pointer.

 -- Function: struct fstab * getfsspec (const char *NAME)

     Preliminary: | MT-Unsafe race:fsent locale | AS-Unsafe corrupt heap
     lock | AC-Unsafe corrupt lock mem | *Note POSIX Safety Concepts::.

     This function returns the next entry of the 'fstab' file which has
     a string equal to NAME pointed to by the 'fs_spec' element.  Since
     there is normally exactly one entry for each special device it
     makes no sense to call this function more than once for the same
     argument.  If this is the first call to any of the functions
     handling 'fstab' since program start or the last call of
     'endfsent', the file will be opened.

     The function returns a pointer to a variable of type 'struct
     fstab'.  This variable is shared by all threads and therefore this
     function is not thread-safe.  If an error occurred 'getfsent'
     returns a 'NULL' pointer.

 -- Function: struct fstab * getfsfile (const char *NAME)

     Preliminary: | MT-Unsafe race:fsent locale | AS-Unsafe corrupt heap
     lock | AC-Unsafe corrupt lock mem | *Note POSIX Safety Concepts::.

     This function returns the next entry of the 'fstab' file which has
     a string equal to NAME pointed to by the 'fs_file' element.  Since
     there is normally exactly one entry for each mount point it makes
     no sense to call this function more than once for the same
     argument.  If this is the first call to any of the functions
     handling 'fstab' since program start or the last call of
     'endfsent', the file will be opened.

     The function returns a pointer to a variable of type 'struct
     fstab'.  This variable is shared by all threads and therefore this
     function is not thread-safe.  If an error occurred 'getfsent'
     returns a 'NULL' pointer.

==============================================================================
File: libc.info,  Node: |mtab|,  Next: |Other_Mount_Information|,  Prev: |fstab|,  Up: |Mount_Information|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *mtab*

31.3.1.2 The 'mtab' file
------------------------

The following functions and data structure access the 'mtab' file.

 -- Data Type: struct mntent

     This structure is used with the 'getmntent', 'getmntent_r',
     'addmntent', and 'hasmntopt' functions.

     'char *mnt_fsname'
          This element contains a pointer to a string describing the
          name of the special device from which the filesystem is
          mounted.  It corresponds to the 'fs_spec' element in 'struct
          fstab'.

     'char *mnt_dir'
          This element points to a string describing the mount point of
          the filesystem.  It corresponds to the 'fs_file' element in
          'struct fstab'.

     'char *mnt_type'
          'mnt_type' describes the filesystem type and is therefore
          equivalent to 'fs_vfstype' in 'struct fstab'.  'mntent.h'
          defines a few symbolic names for some of the values this
          string can have.  But since the kernel can support arbitrary
          filesystems it does not make much sense to give them symbolic
          names.  If one knows the symbol name one also knows the
          filesystem name.  Nevertheless here follows the list of the
          symbols provided in 'mntent.h'.

          'MNTTYPE_IGNORE'
               This symbol expands to '"ignore"'.  The value is
               sometimes used in 'fstab' files to make sure entries are
               not used without removing them.
          'MNTTYPE_NFS'
               Expands to '"nfs"'.  Using this macro sometimes could
               make sense since it names the default NFS implementation,
               in case both version 2 and 3 are supported.
          'MNTTYPE_SWAP'
               This symbol expands to '"swap"'.  It names the special
               'fstab' entry which names one of the possibly multiple
               swap partitions.

     'char *mnt_opts'
          The element contains a string describing the options used
          while mounting the filesystem.  As for the equivalent element
          'fs_mntops' of 'struct fstab' it is best to use the function
          'getsubopt' (*note Suboptions::) to access the parts of this
          string.

          The 'mntent.h' file defines a number of macros with string
          values which correspond to some of the options understood by
          the kernel.  There might be many more options which are
          possible so it doesn't make much sense to rely on these macros
          but to be consistent here is the list:

          'MNTOPT_DEFAULTS'
               Expands to '"defaults"'.  This option should be used
               alone since it indicates all values for the customizable
               values are chosen to be the default.
          'MNTOPT_RO'
               Expands to '"ro"'.  See the 'FSTAB_RO' value, it means
               the filesystem is mounted read-only.
          'MNTOPT_RW'
               Expands to '"rw"'.  See the 'FSTAB_RW' value, it means
               the filesystem is mounted with read and write
               permissions.
          'MNTOPT_SUID'
               Expands to '"suid"'.  This means that the SUID bit (*note
               How Change Persona::) is respected when a program from
               the filesystem is started.
          'MNTOPT_NOSUID'
               Expands to '"nosuid"'.  This is the opposite of
               'MNTOPT_SUID', the SUID bit for all files from the
               filesystem is ignored.
          'MNTOPT_NOAUTO'
               Expands to '"noauto"'.  At startup time the 'mount'
               program will ignore this entry if it is started with the
               '-a' option to mount all filesystems mentioned in the
               'fstab' file.

          As for the 'FSTAB_*' entries introduced above it is important
          to use 'strcmp' to check for equality.

     'mnt_freq'
          This elements corresponds to 'fs_freq' and also specifies the
          frequency in days in which dumps are made.

     'mnt_passno'
          This element is equivalent to 'fs_passno' with the same
          meaning which is uninteresting for all programs beside 'dump'.

   For accessing the 'mtab' file there is again a set of three functions
to access all entries in a row.  Unlike the functions to handle 'fstab'
these functions do not access a fixed file and there is even a thread
safe variant of the get function.  Besides this the GNU C Library
contains functions to alter the file and test for specific options.

 -- Function: FILE * setmntent (const char *FILE, const char *MODE)

     Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe mem fd
     lock | *Note POSIX Safety Concepts::.

     The 'setmntent' function prepares the file named FILE which must be
     in the format of a 'fstab' and 'mtab' file for the upcoming
     processing through the other functions of the family.  The MODE
     parameter can be chosen in the way the OPENTYPE parameter for
     'fopen' (*note Opening Streams::) can be chosen.  If the file is
     opened for writing the file is also allowed to be empty.

     If the file was successfully opened 'setmntent' returns a file
     handle for future use.  Otherwise the return value is 'NULL' and
     'errno' is set accordingly.

 -- Function: int endmntent (FILE *STREAM)

     Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe lock mem
     fd | *Note POSIX Safety Concepts::.

     This function takes for the STREAM parameter a file handle which
     previously was returned from the 'setmntent' call.  'endmntent'
     closes the stream and frees all resources.

     The return value is 1 unless an error occurred in which case it is
     0.

 -- Function: struct mntent * getmntent (FILE *STREAM)

     Preliminary: | MT-Unsafe race:mntentbuf locale | AS-Unsafe corrupt
     heap init | AC-Unsafe init corrupt lock mem | *Note POSIX Safety
     Concepts::.

     The 'getmntent' function takes as the parameter a file handle
     previously returned by a successful call to 'setmntent'.  It
     returns a pointer to a static variable of type 'struct mntent'
     which is filled with the information from the next entry from the
     file currently read.

     The file format used prescribes the use of spaces or tab characters
     to separate the fields.  This makes it harder to use names
     containing one of these characters (e.g., mount points using
     spaces).  Therefore these characters are encoded in the files and
     the 'getmntent' function takes care of the decoding while reading
     the entries back in.  ''\040'' is used to encode a space character,
     ''\011'' to encode a tab character, ''\012'' to encode a newline
     character, and ''\\'' to encode a backslash.

     If there was an error or the end of the file is reached the return
     value is 'NULL'.

     This function is not thread-safe since all calls to this function
     return a pointer to the same static variable.  'getmntent_r' should
     be used in situations where multiple threads access the file.

 -- Function: struct mntent * getmntent_r (FILE *STREAM, struct mntent
          *RESULT, char *BUFFER, int BUFSIZE)

     Preliminary: | MT-Safe locale | AS-Unsafe corrupt heap | AC-Unsafe
     corrupt lock mem | *Note POSIX Safety Concepts::.

     The 'getmntent_r' function is the reentrant variant of 'getmntent'.
     It also returns the next entry from the file and returns a pointer.
     The actual variable the values are stored in is not static, though.
     Instead the function stores the values in the variable pointed to
     by the RESULT parameter.  Additional information (e.g., the strings
     pointed to by the elements of the result) are kept in the buffer of
     size BUFSIZE pointed to by BUFFER.

     Escaped characters (space, tab, backslash) are converted back in
     the same way as it happens for 'getmentent'.

     The function returns a 'NULL' pointer in error cases.  Errors could
     be:
        * error while reading the file,
        * end of file reached,
        * BUFSIZE is too small for reading a complete new entry.

 -- Function: int addmntent (FILE *STREAM, const struct mntent *MNT)

     Preliminary: | MT-Safe race:stream locale | AS-Unsafe corrupt |
     AC-Unsafe corrupt | *Note POSIX Safety Concepts::.

     The 'addmntent' function allows adding a new entry to the file
     previously opened with 'setmntent'.  The new entries are always
     appended.  I.e., even if the position of the file descriptor is not
     at the end of the file this function does not overwrite an existing
     entry following the current position.

     The implication of this is that to remove an entry from a file one
     has to create a new file while leaving out the entry to be removed
     and after closing the file remove the old one and rename the new
     file to the chosen name.

     This function takes care of spaces and tab characters in the names
     to be written to the file.  It converts them and the backslash
     character into the format described in the 'getmntent' description
     above.

     This function returns 0 in case the operation was successful.
     Otherwise the return value is 1 and 'errno' is set appropriately.

 -- Function: char * hasmntopt (const struct mntent *MNT, const char
          *OPT)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function can be used to check whether the string pointed to by
     the 'mnt_opts' element of the variable pointed to by MNT contains
     the option OPT.  If this is true a pointer to the beginning of the
     option in the 'mnt_opts' element is returned.  If no such option
     exists the function returns 'NULL'.

     This function is useful to test whether a specific option is
     present but when all options have to be processed one is better off
     with using the 'getsubopt' function to iterate over all options in
     the string.

==============================================================================
File: libc.info,  Node: |Other_Mount_Information|,  Prev: |mtab|,  Up: |Mount_Information|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Other_Mount_Information*

31.3.1.3 Other (Non-libc) Sources of Mount Information
------------------------------------------------------

On a system with a Linux kernel and the 'proc' filesystem, you can get
information on currently mounted filesystems from the file 'mounts' in
the 'proc' filesystem.  Its format is similar to that of the 'mtab'
file, but represents what is truly mounted without relying on facilities
outside the kernel to keep 'mtab' up to date.

==============================================================================
File: libc.info,  Node: |Mount_Unmount_Remount|,  Prev: Mount Information,  Up: |Filesystem_Handling|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Mount_Unmount_Remount*

31.3.2 Mount, Unmount, Remount
------------------------------

This section describes the functions for mounting, unmounting, and
remounting filesystems.

   Only the superuser can mount, unmount, or remount a filesystem.

   These functions do not access the 'fstab' and 'mtab' files.  You
should maintain and use these separately.  *Note Mount Information::.

   The symbols in this section are declared in 'sys/mount.h'.

 -- Function: int mount (const char *SPECIAL_FILE, const char *DIR,
          const char *FSTYPE, unsigned long int OPTIONS, const void
          *DATA)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'mount' mounts or remounts a filesystem.  The two operations are
     quite different and are merged rather unnaturally into this one
     function.  The 'MS_REMOUNT' option, explained below, determines
     whether 'mount' mounts or remounts.

     For a mount, the filesystem on the block device represented by the
     device special file named SPECIAL_FILE gets mounted over the mount
     point DIR.  This means that the directory DIR (along with any files
     in it) is no longer visible; in its place (and still with the name
     DIR) is the root directory of the filesystem on the device.

     As an exception, if the filesystem type (see below) is one which is
     not based on a device (e.g.  "proc"), 'mount' instantiates a
     filesystem and mounts it over DIR and ignores SPECIAL_FILE.

     For a remount, DIR specifies the mount point where the filesystem
     to be remounted is (and remains) mounted and SPECIAL_FILE is
     ignored.  Remounting a filesystem means changing the options that
     control operations on the filesystem while it is mounted.  It does
     not mean unmounting and mounting again.

     For a mount, you must identify the type of the filesystem with
     FSTYPE.  This type tells the kernel how to access the filesystem
     and can be thought of as the name of a filesystem driver.  The
     acceptable values are system dependent.  On a system with a Linux
     kernel and the 'proc' filesystem, the list of possible values is in
     the file 'filesystems' in the 'proc' filesystem (e.g.  type 'cat
     /proc/filesystems' to see the list).  With a Linux kernel, the
     types of filesystems that 'mount' can mount, and their type names,
     depends on what filesystem drivers are configured into the kernel
     or loaded as loadable kernel modules.  An example of a common value
     for FSTYPE is 'ext2'.

     For a remount, 'mount' ignores FSTYPE.

     OPTIONS specifies a variety of options that apply until the
     filesystem is unmounted or remounted.  The precise meaning of an
     option depends on the filesystem and with some filesystems, an
     option may have no effect at all.  Furthermore, for some
     filesystems, some of these options (but never 'MS_RDONLY') can be
     overridden for individual file accesses via 'ioctl'.

     OPTIONS is a bit string with bit fields defined using the following
     mask and masked value macros:

     'MS_MGC_MASK'
          This multibit field contains a magic number.  If it does not
          have the value 'MS_MGC_VAL', 'mount' assumes all the following
          bits are zero and the DATA argument is a null string,
          regardless of their actual values.

     'MS_REMOUNT'
          This bit on means to remount the filesystem.  Off means to
          mount it.

     'MS_RDONLY'
          This bit on specifies that no writing to the filesystem shall
          be allowed while it is mounted.  This cannot be overridden by
          'ioctl'.  This option is available on nearly all filesystems.

     'MS_NOSUID'
          This bit on specifies that Setuid and Setgid permissions on
          files in the filesystem shall be ignored while it is mounted.

     'MS_NOEXEC'
          This bit on specifies that no files in the filesystem shall be
          executed while the filesystem is mounted.

     'MS_NODEV'
          This bit on specifies that no device special files in the
          filesystem shall be accessible while the filesystem is
          mounted.

     'MS_SYNCHRONOUS'
          This bit on specifies that all writes to the filesystem while
          it is mounted shall be synchronous; i.e., data shall be synced
          before each write completes rather than held in the buffer
          cache.

     'MS_MANDLOCK'
          This bit on specifies that mandatory locks on files shall be
          permitted while the filesystem is mounted.

     'MS_NOATIME'
          This bit on specifies that access times of files shall not be
          updated when the files are accessed while the filesystem is
          mounted.

     'MS_NODIRATIME'
          This bit on specifies that access times of directories shall
          not be updated when the directories are accessed while the
          filesystem in mounted.

     Any bits not covered by the above masks should be set off;
     otherwise, results are undefined.

     The meaning of DATA depends on the filesystem type and is
     controlled entirely by the filesystem driver in the kernel.

     Example:

          #include <sys/mount.h>

          mount("/dev/hdb", "/cdrom", MS_MGC_VAL | MS_RDONLY | MS_NOSUID, "");

          mount("/dev/hda2", "/mnt", MS_MGC_VAL | MS_REMOUNT, "");


     Appropriate arguments for 'mount' are conventionally recorded in
     the 'fstab' table.  *Note Mount Information::.

     The return value is zero if the mount or remount is successful.
     Otherwise, it is '-1' and 'errno' is set appropriately.  The values
     of 'errno' are filesystem dependent, but here is a general list:

     'EPERM'
          The process is not superuser.
     'ENODEV'
          The file system type FSTYPE is not known to the kernel.
     'ENOTBLK'
          The file DEV is not a block device special file.
     'EBUSY'

             * The device is already mounted.

             * The mount point is busy.  (E.g.  it is some process'
               working directory or has a filesystem mounted on it
               already).

             * The request is to remount read-only, but there are files
               open for writing.

     'EINVAL'

             * A remount was attempted, but there is no filesystem
               mounted over the specified mount point.

             * The supposed filesystem has an invalid superblock.

     'EACCES'

             * The filesystem is inherently read-only (possibly due to a
               switch on the device) and the process attempted to mount
               it read/write (by setting the 'MS_RDONLY' bit off).

             * SPECIAL_FILE or DIR is not accessible due to file
               permissions.

             * SPECIAL_FILE is not accessible because it is in a
               filesystem that is mounted with the 'MS_NODEV' option.

     'EM_FILE'
          The table of dummy devices is full.  'mount' needs to create a
          dummy device (aka "unnamed" device) if the filesystem being
          mounted is not one that uses a device.

 -- Function: int umount2 (const char *FILE, int FLAGS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'umount2' unmounts a filesystem.

     You can identify the filesystem to unmount either by the device
     special file that contains the filesystem or by the mount point.
     The effect is the same.  Specify either as the string FILE.

     FLAGS contains the one-bit field identified by the following mask
     macro:

     'MNT_FORCE'
          This bit on means to force the unmounting even if the
          filesystem is busy, by making it unbusy first.  If the bit is
          off and the filesystem is busy, 'umount2' fails with 'errno' =
          'EBUSY'.  Depending on the filesystem, this may override all,
          some, or no busy conditions.

     All other bits in FLAGS should be set to zero; otherwise, the
     result is undefined.

     Example:

          #include <sys/mount.h>

          umount2("/mnt", MNT_FORCE);

          umount2("/dev/hdd1", 0);


     After the filesystem is unmounted, the directory that was the mount
     point is visible, as are any files in it.

     As part of unmounting, 'umount2' syncs the filesystem.

     If the unmounting is successful, the return value is zero.
     Otherwise, it is '-1' and 'errno' is set accordingly:

     'EPERM'
          The process is not superuser.
     'EBUSY'
          The filesystem cannot be unmounted because it is busy.  E.g.
          it contains a directory that is some process's working
          directory or a file that some process has open.  With some
          filesystems in some cases, you can avoid this failure with the
          'MNT_FORCE' option.

     'EINVAL'
          FILE validly refers to a file, but that file is neither a
          mount point nor a device special file of a currently mounted
          filesystem.

     This function is not available on all systems.

 -- Function: int umount (const char *FILE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'umount' does the same thing as 'umount2' with FLAGS set to zeroes.
     It is more widely available than 'umount2' but since it lacks the
     possibility to forcefully unmount a filesystem is deprecated when
     'umount2' is also available.

==============================================================================
File: libc.info,  Node: |System_Parameters|,  Prev: Filesystem Handling,  Up: System Management
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *System_Parameters*

31.4 System Parameters
----------------------

This section describes the 'sysctl' function, which gets and sets a
variety of system parameters.

   The symbols used in this section are declared in the file
'sys/sysctl.h'.

 -- Function: int sysctl (int *NAMES, int NLEN, void *OLDVAL, size_t
          *OLDLENP, void *NEWVAL, size_t NEWLEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'sysctl' gets or sets a specified system parameter.  There are so
     many of these parameters that it is not practical to list them all
     here, but here are some examples:

        * network domain name
        * paging parameters
        * network Address Resolution Protocol timeout time
        * maximum number of files that may be open
        * root filesystem device
        * when kernel was built

     The set of available parameters depends on the kernel configuration
     and can change while the system is running, particularly when you
     load and unload loadable kernel modules.

     The system parameters with which 'sysctl' is concerned are arranged
     in a hierarchical structure like a hierarchical filesystem.  To
     identify a particular parameter, you specify a path through the
     structure in a way analogous to specifying the pathname of a file.
     Each component of the path is specified by an integer and each of
     these integers has a macro defined for it by 'sys/sysctl.h'.  NAMES
     is the path, in the form of an array of integers.  Each component
     of the path is one element of the array, in order.  NLEN is the
     number of components in the path.

     For example, the first component of the path for all the paging
     parameters is the value 'CTL_VM'.  For the free page thresholds,
     the second component of the path is 'VM_FREEPG'.  So to get the
     free page threshold values, make NAMES an array containing the two
     elements 'CTL_VM' and 'VM_FREEPG' and make NLEN = 2.

     The format of the value of a parameter depends on the parameter.
     Sometimes it is an integer; sometimes it is an ASCII string;
     sometimes it is an elaborate structure.  In the case of the free
     page thresholds used in the example above, the parameter value is a
     structure containing several integers.

     In any case, you identify a place to return the parameter's value
     with OLDVAL and specify the amount of storage available at that
     location as *OLDLENP.  *OLDLENP does double duty because it is also
     the output location that contains the actual length of the returned
     value.

     If you don't want the parameter value returned, specify a null
     pointer for OLDVAL.

     To set the parameter, specify the address and length of the new
     value as NEWVAL and NEWLEN.  If you don't want to set the
     parameter, specify a null pointer as NEWVAL.

     If you get and set a parameter in the same 'sysctl' call, the value
     returned is the value of the parameter before it was set.

     Each system parameter has a set of permissions similar to the
     permissions for a file (including the permissions on directories in
     its path) that determine whether you may get or set it.  For the
     purposes of these permissions, every parameter is considered to be
     owned by the superuser and Group 0 so processes with that effective
     uid or gid may have more access to system parameters.  Unlike with
     files, the superuser does not invariably have full permission to
     all system parameters, because some of them are designed not to be
     changed ever.

     'sysctl' returns a zero return value if it succeeds.  Otherwise, it
     returns '-1' and sets 'errno' appropriately.  Besides the failures
     that apply to all system calls, the following are the 'errno' codes
     for all possible failures:

     'EPERM'
          The process is not permitted to access one of the components
          of the path of the system parameter or is not permitted to
          access the system parameter itself in the way (read or write)
          that it requested.
     'ENOTDIR'
          There is no system parameter corresponding to NAME.
     'EFAULT'
          OLDVAL is not null, which means the process wanted to read the
          parameter, but *OLDLENP is zero, so there is no place to
          return it.
     'EINVAL'
             * The process attempted to set a system parameter to a
               value that is not valid for that parameter.
             * The space provided for the return of the system parameter
               is not the right size for that parameter.
     'ENOMEM'
          This value may be returned instead of the more correct
          'EINVAL' in some cases where the space provided for the return
          of the system parameter is too small.

   If you have a Linux kernel with the 'proc' filesystem, you can get
and set most of the same parameters by reading and writing to files in
the 'sys' directory of the 'proc' filesystem.  In the 'sys' directory,
the directory structure represents the hierarchical structure of the
parameters.  E.g.  you can display the free page thresholds with
     cat /proc/sys/vm/freepages

   Some more traditional and more widely available, though less general,
GNU C Library functions for getting and setting some of the same system
parameters are:

   * 'getdomainname', 'setdomainname'
   * 'gethostname', 'sethostname' (*Note Host Identification::.)
   * 'uname' (*Note Platform Type::.)

==============================================================================
File: libc.info,  Node: |System_Configuration|,  Next: |Cryptographic_Functions|,  Prev: |System_Management|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *System_Configuration*

32 System Configuration Parameters
==================================

The functions and macros listed in this chapter give information about
configuration parameters of the operating system--for example, capacity
limits, presence of optional POSIX features, and the default path for
executable files (*note String Parameters::).

MENU

* |General_Limits|::           Constants and functions that describe
				various process-related limits that have
				one uniform value for any given machine.
* |System_Options|::           Optional POSIX features.
* |Version_Supported|::        Version numbers of POSIX.1 and POSIX.2.
* |Sysconf|::                  Getting specific configuration values
                                of general limits and system options.
* |Minimums|::                 Minimum values for general limits.

* |Limits_for_Files|::         Size limitations that pertain to individual files.
                                These can vary between file systems
                                or even from file to file.
* |Options_for_Files|::        Optional features that some files may support.
* |File_Minimums|::            Minimum values for file limits.
* |Pathconf|::                 Getting the limit values for a particular file.

* |Utility_Limits|::           Capacity limits of some POSIX.2 utility programs.
* |Utility_Minimums|::         Minimum allowable values of those limits.

* |String_Parameters|::        Getting the default search path.

==============================================================================
File: libc.info,  Node: |General_Limits|,  Next: |System_Options|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *General_Limits*

32.1 General Capacity Limits
----------------------------

The POSIX.1 and POSIX.2 standards specify a number of parameters that
describe capacity limitations of the system.  These limits can be fixed
constants for a given operating system, or they can vary from machine to
machine.  For example, some limit values may be configurable by the
system administrator, either at run time or by rebuilding the kernel,
and this should not require recompiling application programs.

   Each of the following limit parameters has a macro that is defined in
'limits.h' only if the system has a fixed, uniform limit for the
parameter in question.  If the system allows different file systems or
files to have different limits, then the macro is undefined; use
'sysconf' to find out the limit that applies at a particular time on a
particular machine.  *Note Sysconf::.

   Each of these parameters also has another macro, with a name starting
with '_POSIX', which gives the lowest value that the limit is allowed to
have on _any_ POSIX system.  *Note Minimums::.

 -- Macro: int ARG_MAX

     If defined, the unvarying maximum combined length of the ARGV and
     ENVIRON arguments that can be passed to the 'exec' functions.

 -- Macro: int CHILD_MAX

     If defined, the unvarying maximum number of processes that can
     exist with the same real user ID at any one time.  In BSD and GNU,
     this is controlled by the 'RLIMIT_NPROC' resource limit; *note
     Limits on Resources::.

 -- Macro: int OPEN_MAX

     If defined, the unvarying maximum number of files that a single
     process can have open simultaneously.  In BSD and GNU, this is
     controlled by the 'RLIMIT_NOFILE' resource limit; *note Limits on
     Resources::.

 -- Macro: int STREAM_MAX

     If defined, the unvarying maximum number of streams that a single
     process can have open simultaneously.  *Note Opening Streams::.

 -- Macro: int TZNAME_MAX

     If defined, the unvarying maximum length of a time zone name.
     *Note Time Zone Functions::.

   These limit macros are always defined in 'limits.h'.

 -- Macro: int NGROUPS_MAX

     The maximum number of supplementary group IDs that one process can
     have.

     The value of this macro is actually a lower bound for the maximum.
     That is, you can count on being able to have that many
     supplementary group IDs, but a particular machine might let you
     have even more.  You can use 'sysconf' to see whether a particular
     machine will let you have more (*note Sysconf::).

 -- Macro: ssize_t SSIZE_MAX

     The largest value that can fit in an object of type 'ssize_t'.
     Effectively, this is the limit on the number of bytes that can be
     read or written in a single operation.

     This macro is defined in all POSIX systems because this limit is
     never configurable.

 -- Macro: int RE_DUP_MAX

     The largest number of repetitions you are guaranteed is allowed in
     the construct '\{MIN,MAX\}' in a regular expression.

     The value of this macro is actually a lower bound for the maximum.
     That is, you can count on being able to have that many repetitions,
     but a particular machine might let you have even more.  You can use
     'sysconf' to see whether a particular machine will let you have
     more (*note Sysconf::).  And even the value that 'sysconf' tells
     you is just a lower bound--larger values might work.

     This macro is defined in all POSIX.2 systems, because POSIX.2 says
     it should always be defined even if there is no specific imposed
     limit.

==============================================================================
File: libc.info,  Node: |System_Options|,  Next: |Version_Supported|,  Prev: |General_Limits|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *System_Options*

32.2 Overall System Options
---------------------------

POSIX defines certain system-specific options that not all POSIX systems
support.  Since these options are provided in the kernel, not in the
library, simply using the GNU C Library does not guarantee any of these
features are supported; it depends on the system you are using.

   You can test for the availability of a given option using the macros
in this section, together with the function 'sysconf'.  The macros are
defined only if you include 'unistd.h'.

   For the following macros, if the macro is defined in 'unistd.h', then
the option is supported.  Otherwise, the option may or may not be
supported; use 'sysconf' to find out.  *Note Sysconf::.

 -- Macro: int _POSIX_JOB_CONTROL

     If this symbol is defined, it indicates that the system supports
     job control.  Otherwise, the implementation behaves as if all
     processes within a session belong to a single process group.  *Note
     Job Control::.

 -- Macro: int _POSIX_SAVED_IDS

     If this symbol is defined, it indicates that the system remembers
     the effective user and group IDs of a process before it executes an
     executable file with the set-user-ID or set-group-ID bits set, and
     that explicitly changing the effective user or group IDs back to
     these values is permitted.  If this option is not defined, then if
     a nonprivileged process changes its effective user or group ID to
     the real user or group ID of the process, it can't change it back
     again.  *Note Enable/Disable Setuid::.

   For the following macros, if the macro is defined in 'unistd.h', then
its value indicates whether the option is supported.  A value of '-1'
means no, and any other value means yes.  If the macro is not defined,
then the option may or may not be supported; use 'sysconf' to find out.
*Note Sysconf::.

 -- Macro: int _POSIX2_C_DEV

     If this symbol is defined, it indicates that the system has the
     POSIX.2 C compiler command, 'c89'.  The GNU C Library always
     defines this as '1', on the assumption that you would not have
     installed it if you didn't have a C compiler.

 -- Macro: int _POSIX2_FORT_DEV

     If this symbol is defined, it indicates that the system has the
     POSIX.2 Fortran compiler command, 'fort77'.  The GNU C Library
     never defines this, because we don't know what the system has.

 -- Macro: int _POSIX2_FORT_RUN

     If this symbol is defined, it indicates that the system has the
     POSIX.2 'asa' command to interpret Fortran carriage control.  The
     GNU C Library never defines this, because we don't know what the
     system has.

 -- Macro: int _POSIX2_LOCALEDEF

     If this symbol is defined, it indicates that the system has the
     POSIX.2 'localedef' command.  The GNU C Library never defines this,
     because we don't know what the system has.

 -- Macro: int _POSIX2_SW_DEV

     If this symbol is defined, it indicates that the system has the
     POSIX.2 commands 'ar', 'make', and 'strip'.  The GNU C Library
     always defines this as '1', on the assumption that you had to have
     'ar' and 'make' to install the library, and it's unlikely that
     'strip' would be absent when those are present.

==============================================================================
File: libc.info,  Node: |Version_Supported|,  Next: |Sysconf|,  Prev: |System_Options|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Version_Supported*

32.3 Which Version of POSIX is Supported
----------------------------------------

 -- Macro: long int _POSIX_VERSION

     This constant represents the version of the POSIX.1 standard to
     which the implementation conforms.  For an implementation
     conforming to the 1995 POSIX.1 standard, the value is the integer
     '199506L'.

     '_POSIX_VERSION' is always defined (in 'unistd.h') in any POSIX
     system.

     *Usage Note:* Don't try to test whether the system supports POSIX
     by including 'unistd.h' and then checking whether '_POSIX_VERSION'
     is defined.  On a non-POSIX system, this will probably fail because
     there is no 'unistd.h'.  We do not know of _any_ way you can
     reliably test at compilation time whether your target system
     supports POSIX or whether 'unistd.h' exists.

 -- Macro: long int _POSIX2_C_VERSION

     This constant represents the version of the POSIX.2 standard which
     the library and system kernel support.  We don't know what value
     this will be for the first version of the POSIX.2 standard, because
     the value is based on the year and month in which the standard is
     officially adopted.

     The value of this symbol says nothing about the utilities installed
     on the system.

     *Usage Note:* You can use this macro to tell whether a POSIX.1
     system library supports POSIX.2 as well.  Any POSIX.1 system
     contains 'unistd.h', so include that file and then test 'defined
     (_POSIX2_C_VERSION)'.

==============================================================================
File: libc.info,  Node: |Sysconf|,  Next: |Minimums|,  Prev: |Version_Supported|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Sysconf*

32.4 Using 'sysconf'
--------------------

When your system has configurable system limits, you can use the
'sysconf' function to find out the value that applies to any particular
machine.  The function and the associated PARAMETER constants are
declared in the header file 'unistd.h'.

MENU

* |Sysconf_Definition|::        Detailed specifications of 'sysconf'.
* |Constants_for_Sysconf|::     The list of parameters 'sysconf' can read.
* |Examples_of_Sysconf|::       How to use 'sysconf' and the parameter
				 macros properly together.

==============================================================================
File: libc.info,  Node: |Sysconf_Definition|,  Next: |Constants_for_Sysconf|,  Up: |Sysconf|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Sysconf_Definition*

32.4.1 Definition of 'sysconf'
------------------------------

 -- Function: long int sysconf (int PARAMETER)

     Preliminary: | MT-Safe env | AS-Unsafe lock heap | AC-Unsafe lock
     mem fd | *Note POSIX Safety Concepts::.

     This function is used to inquire about runtime system parameters.
     The PARAMETER argument should be one of the '_SC_' symbols listed
     below.

     The normal return value from 'sysconf' is the value you requested.
     A value of '-1' is returned both if the implementation does not
     impose a limit, and in case of an error.

     The following 'errno' error conditions are defined for this
     function:

     'EINVAL'
          The value of the PARAMETER is invalid.

==============================================================================
File: libc.info,  Node: |Constants_for_Sysconf|,  Next: |Examples_of_Sysconf|,  Prev: |Sysconf_Definition|,  Up: |Sysconf|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Constants_for_Sysconf*

32.4.2 Constants for 'sysconf' Parameters
-----------------------------------------

Here are the symbolic constants for use as the PARAMETER argument to
'sysconf'.  The values are all integer constants (more specifically,
enumeration type values).

'_SC_ARG_MAX'

     Inquire about the parameter corresponding to 'ARG_MAX'.

'_SC_CHILD_MAX'

     Inquire about the parameter corresponding to 'CHILD_MAX'.

'_SC_OPEN_MAX'

     Inquire about the parameter corresponding to 'OPEN_MAX'.

'_SC_STREAM_MAX'

     Inquire about the parameter corresponding to 'STREAM_MAX'.

'_SC_TZNAME_MAX'

     Inquire about the parameter corresponding to 'TZNAME_MAX'.

'_SC_NGROUPS_MAX'

     Inquire about the parameter corresponding to 'NGROUPS_MAX'.

'_SC_JOB_CONTROL'

     Inquire about the parameter corresponding to '_POSIX_JOB_CONTROL'.

'_SC_SAVED_IDS'

     Inquire about the parameter corresponding to '_POSIX_SAVED_IDS'.

'_SC_VERSION'

     Inquire about the parameter corresponding to '_POSIX_VERSION'.

'_SC_CLK_TCK'

     Inquire about the number of clock ticks per second; *note CPU
     Time::.  The corresponding parameter 'CLK_TCK' is obsolete.

'_SC_CHARCLASS_NAME_MAX'

     Inquire about the parameter corresponding to maximal length allowed
     for a character class name in an extended locale specification.
     These extensions are not yet standardized and so this option is not
     standardized as well.

'_SC_REALTIME_SIGNALS'

     Inquire about the parameter corresponding to
     '_POSIX_REALTIME_SIGNALS'.

'_SC_PRIORITY_SCHEDULING'

     Inquire about the parameter corresponding to
     '_POSIX_PRIORITY_SCHEDULING'.

'_SC_TIMERS'

     Inquire about the parameter corresponding to '_POSIX_TIMERS'.

'_SC_ASYNCHRONOUS_IO'

     Inquire about the parameter corresponding to
     '_POSIX_ASYNCHRONOUS_IO'.

'_SC_PRIORITIZED_IO'

     Inquire about the parameter corresponding to
     '_POSIX_PRIORITIZED_IO'.

'_SC_SYNCHRONIZED_IO'

     Inquire about the parameter corresponding to
     '_POSIX_SYNCHRONIZED_IO'.

'_SC_FSYNC'

     Inquire about the parameter corresponding to '_POSIX_FSYNC'.

'_SC_MAPPED_FILES'

     Inquire about the parameter corresponding to '_POSIX_MAPPED_FILES'.

'_SC_MEMLOCK'

     Inquire about the parameter corresponding to '_POSIX_MEMLOCK'.

'_SC_MEMLOCK_RANGE'

     Inquire about the parameter corresponding to
     '_POSIX_MEMLOCK_RANGE'.

'_SC_MEMORY_PROTECTION'

     Inquire about the parameter corresponding to
     '_POSIX_MEMORY_PROTECTION'.

'_SC_MESSAGE_PASSING'

     Inquire about the parameter corresponding to
     '_POSIX_MESSAGE_PASSING'.

'_SC_SEMAPHORES'

     Inquire about the parameter corresponding to '_POSIX_SEMAPHORES'.

'_SC_SHARED_MEMORY_OBJECTS'

     Inquire about the parameter corresponding to
     '_POSIX_SHARED_MEMORY_OBJECTS'.

'_SC_AIO_LISTIO_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_AIO_LISTIO_MAX'.

'_SC_AIO_MAX'

     Inquire about the parameter corresponding to '_POSIX_AIO_MAX'.

'_SC_AIO_PRIO_DELTA_MAX'

     Inquire about the value by which a process can decrease its
     asynchronous I/O priority level from its own scheduling priority.
     This corresponds to the run-time invariant value
     'AIO_PRIO_DELTA_MAX'.

'_SC_DELAYTIMER_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_DELAYTIMER_MAX'.

'_SC_MQ_OPEN_MAX'

     Inquire about the parameter corresponding to '_POSIX_MQ_OPEN_MAX'.

'_SC_MQ_PRIO_MAX'

     Inquire about the parameter corresponding to '_POSIX_MQ_PRIO_MAX'.

'_SC_RTSIG_MAX'

     Inquire about the parameter corresponding to '_POSIX_RTSIG_MAX'.

'_SC_SEM_NSEMS_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_SEM_NSEMS_MAX'.

'_SC_SEM_VALUE_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_SEM_VALUE_MAX'.

'_SC_SIGQUEUE_MAX'

     Inquire about the parameter corresponding to '_POSIX_SIGQUEUE_MAX'.

'_SC_TIMER_MAX'

     Inquire about the parameter corresponding to '_POSIX_TIMER_MAX'.

'_SC_PII'

     Inquire about the parameter corresponding to '_POSIX_PII'.

'_SC_PII_XTI'

     Inquire about the parameter corresponding to '_POSIX_PII_XTI'.

'_SC_PII_SOCKET'

     Inquire about the parameter corresponding to '_POSIX_PII_SOCKET'.

'_SC_PII_INTERNET'

     Inquire about the parameter corresponding to '_POSIX_PII_INTERNET'.

'_SC_PII_OSI'

     Inquire about the parameter corresponding to '_POSIX_PII_OSI'.

'_SC_SELECT'

     Inquire about the parameter corresponding to '_POSIX_SELECT'.

'_SC_UIO_MAXIOV'

     Inquire about the parameter corresponding to '_POSIX_UIO_MAXIOV'.

'_SC_PII_INTERNET_STREAM'

     Inquire about the parameter corresponding to
     '_POSIX_PII_INTERNET_STREAM'.

'_SC_PII_INTERNET_DGRAM'

     Inquire about the parameter corresponding to
     '_POSIX_PII_INTERNET_DGRAM'.

'_SC_PII_OSI_COTS'

     Inquire about the parameter corresponding to '_POSIX_PII_OSI_COTS'.

'_SC_PII_OSI_CLTS'

     Inquire about the parameter corresponding to '_POSIX_PII_OSI_CLTS'.

'_SC_PII_OSI_M'

     Inquire about the parameter corresponding to '_POSIX_PII_OSI_M'.

'_SC_T_IOV_MAX'

     Inquire about the value associated with the 'T_IOV_MAX' variable.

'_SC_THREADS'

     Inquire about the parameter corresponding to '_POSIX_THREADS'.

'_SC_THREAD_SAFE_FUNCTIONS'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_SAFE_FUNCTIONS'.

'_SC_GETGR_R_SIZE_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_GETGR_R_SIZE_MAX'.

'_SC_GETPW_R_SIZE_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_GETPW_R_SIZE_MAX'.

'_SC_LOGIN_NAME_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_LOGIN_NAME_MAX'.

'_SC_TTY_NAME_MAX'

     Inquire about the parameter corresponding to '_POSIX_TTY_NAME_MAX'.

'_SC_THREAD_DESTRUCTOR_ITERATIONS'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_DESTRUCTOR_ITERATIONS'.

'_SC_THREAD_KEYS_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_KEYS_MAX'.

'_SC_THREAD_STACK_MIN'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_STACK_MIN'.

'_SC_THREAD_THREADS_MAX'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_THREADS_MAX'.

'_SC_THREAD_ATTR_STACKADDR'

     Inquire about the parameter corresponding to
     a '_POSIX_THREAD_ATTR_STACKADDR'.

'_SC_THREAD_ATTR_STACKSIZE'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_ATTR_STACKSIZE'.

'_SC_THREAD_PRIORITY_SCHEDULING'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_PRIORITY_SCHEDULING'.

'_SC_THREAD_PRIO_INHERIT'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_PRIO_INHERIT'.

'_SC_THREAD_PRIO_PROTECT'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_PRIO_PROTECT'.

'_SC_THREAD_PROCESS_SHARED'

     Inquire about the parameter corresponding to
     '_POSIX_THREAD_PROCESS_SHARED'.

'_SC_2_C_DEV'

     Inquire about whether the system has the POSIX.2 C compiler
     command, 'c89'.

'_SC_2_FORT_DEV'

     Inquire about whether the system has the POSIX.2 Fortran compiler
     command, 'fort77'.

'_SC_2_FORT_RUN'

     Inquire about whether the system has the POSIX.2 'asa' command to
     interpret Fortran carriage control.

'_SC_2_LOCALEDEF'

     Inquire about whether the system has the POSIX.2 'localedef'
     command.

'_SC_2_SW_DEV'

     Inquire about whether the system has the POSIX.2 commands 'ar',
     'make', and 'strip'.

'_SC_BC_BASE_MAX'

     Inquire about the maximum value of 'obase' in the 'bc' utility.

'_SC_BC_DIM_MAX'

     Inquire about the maximum size of an array in the 'bc' utility.

'_SC_BC_SCALE_MAX'

     Inquire about the maximum value of 'scale' in the 'bc' utility.

'_SC_BC_STRING_MAX'

     Inquire about the maximum size of a string constant in the 'bc'
     utility.

'_SC_COLL_WEIGHTS_MAX'

     Inquire about the maximum number of weights that can necessarily be
     used in defining the collating sequence for a locale.

'_SC_EXPR_NEST_MAX'

     Inquire about the maximum number of expressions nested within
     parentheses when using the 'expr' utility.

'_SC_LINE_MAX'

     Inquire about the maximum size of a text line that the POSIX.2 text
     utilities can handle.

'_SC_EQUIV_CLASS_MAX'

     Inquire about the maximum number of weights that can be assigned to
     an entry of the 'LC_COLLATE' category 'order' keyword in a locale
     definition.  The GNU C Library does not presently support locale
     definitions.

'_SC_VERSION'

     Inquire about the version number of POSIX.1 that the library and
     kernel support.

'_SC_2_VERSION'

     Inquire about the version number of POSIX.2 that the system
     utilities support.

'_SC_PAGESIZE'

     Inquire about the virtual memory page size of the machine.
     'getpagesize' returns the same value (*note Query Memory
     Parameters::).

'_SC_NPROCESSORS_CONF'

     Inquire about the number of configured processors.

'_SC_NPROCESSORS_ONLN'

     Inquire about the number of processors online.

'_SC_PHYS_PAGES'

     Inquire about the number of physical pages in the system.

'_SC_AVPHYS_PAGES'

     Inquire about the number of available physical pages in the system.

'_SC_ATEXIT_MAX'

     Inquire about the number of functions which can be registered as
     termination functions for 'atexit'; *note Cleanups on Exit::.

'_SC_LEVEL1_ICACHE_SIZE'

     Inquire about the size of the Level 1 instruction cache.

'_SC_LEVEL1_ICACHE_ASSOC'

     Inquire about the associativity of the Level 1 instruction cache.

'_SC_LEVEL1_ICACHE_LINESIZE'

     Inquire about the line length of the Level 1 instruction cache.

     On aarch64, the cache line size returned is the minimum instruction
     cache line size observable by userspace.  This is typically the
     same as the L1 icache size but on some cores it may not be so.
     However, it is specified in the architecture that operations such
     as cache line invalidation are consistent with the size reported
     with this variable.

'_SC_LEVEL1_DCACHE_SIZE'

     Inquire about the size of the Level 1 data cache.

'_SC_LEVEL1_DCACHE_ASSOC'

     Inquire about the associativity of the Level 1 data cache.

'_SC_LEVEL1_DCACHE_LINESIZE'

     Inquire about the line length of the Level 1 data cache.

     On aarch64, the cache line size returned is the minimum data cache
     line size observable by userspace.  This is typically the same as
     the L1 dcache size but on some cores it may not be so.  However, it
     is specified in the architecture that operations such as cache line
     invalidation are consistent with the size reported with this
     variable.

'_SC_LEVEL2_CACHE_SIZE'

     Inquire about the size of the Level 2 cache.

'_SC_LEVEL2_CACHE_ASSOC'

     Inquire about the associativity of the Level 2 cache.

'_SC_LEVEL2_CACHE_LINESIZE'

     Inquire about the line length of the Level 2 cache.

'_SC_LEVEL3_CACHE_SIZE'

     Inquire about the size of the Level 3 cache.

'_SC_LEVEL3_CACHE_ASSOC'

     Inquire about the associativity of the Level 3 cache.

'_SC_LEVEL3_CACHE_LINESIZE'

     Inquire about the line length of the Level 3 cache.

'_SC_LEVEL4_CACHE_SIZE'

     Inquire about the size of the Level 4 cache.

'_SC_LEVEL4_CACHE_ASSOC'

     Inquire about the associativity of the Level 4 cache.

'_SC_LEVEL4_CACHE_LINESIZE'

     Inquire about the line length of the Level 4 cache.

'_SC_XOPEN_VERSION'

     Inquire about the parameter corresponding to '_XOPEN_VERSION'.

'_SC_XOPEN_XCU_VERSION'

     Inquire about the parameter corresponding to '_XOPEN_XCU_VERSION'.

'_SC_XOPEN_UNIX'

     Inquire about the parameter corresponding to '_XOPEN_UNIX'.

'_SC_XOPEN_REALTIME'

     Inquire about the parameter corresponding to '_XOPEN_REALTIME'.

'_SC_XOPEN_REALTIME_THREADS'

     Inquire about the parameter corresponding to
     '_XOPEN_REALTIME_THREADS'.

'_SC_XOPEN_LEGACY'

     Inquire about the parameter corresponding to '_XOPEN_LEGACY'.

'_SC_XOPEN_CRYPT'

     Inquire about the parameter corresponding to '_XOPEN_CRYPT'.  The
     GNU C Library no longer implements the '_XOPEN_CRYPT' extensions,
     so 'sysconf (_SC_XOPEN_CRYPT)' always returns '-1'.

'_SC_XOPEN_ENH_I18N'

     Inquire about the parameter corresponding to '_XOPEN_ENH_I18N'.

'_SC_XOPEN_SHM'

     Inquire about the parameter corresponding to '_XOPEN_SHM'.

'_SC_XOPEN_XPG2'

     Inquire about the parameter corresponding to '_XOPEN_XPG2'.

'_SC_XOPEN_XPG3'

     Inquire about the parameter corresponding to '_XOPEN_XPG3'.

'_SC_XOPEN_XPG4'

     Inquire about the parameter corresponding to '_XOPEN_XPG4'.

'_SC_CHAR_BIT'

     Inquire about the number of bits in a variable of type 'char'.

'_SC_CHAR_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'char'.

'_SC_CHAR_MIN'

     Inquire about the minimum value which can be stored in a variable
     of type 'char'.

'_SC_INT_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'int'.

'_SC_INT_MIN'

     Inquire about the minimum value which can be stored in a variable
     of type 'int'.

'_SC_LONG_BIT'

     Inquire about the number of bits in a variable of type 'long int'.

'_SC_WORD_BIT'

     Inquire about the number of bits in a variable of a register word.

'_SC_MB_LEN_MAX'

     Inquire about the maximum length of a multi-byte representation of
     a wide character value.

'_SC_NZERO'

     Inquire about the value used to internally represent the zero
     priority level for the process execution.

'_SC_SSIZE_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'ssize_t'.

'_SC_SCHAR_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'signed char'.

'_SC_SCHAR_MIN'

     Inquire about the minimum value which can be stored in a variable
     of type 'signed char'.

'_SC_SHRT_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'short int'.

'_SC_SHRT_MIN'

     Inquire about the minimum value which can be stored in a variable
     of type 'short int'.

'_SC_UCHAR_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'unsigned char'.

'_SC_UINT_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'unsigned int'.

'_SC_ULONG_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'unsigned long int'.

'_SC_USHRT_MAX'

     Inquire about the maximum value which can be stored in a variable
     of type 'unsigned short int'.

'_SC_NL_ARGMAX'

     Inquire about the parameter corresponding to 'NL_ARGMAX'.

'_SC_NL_LANGMAX'

     Inquire about the parameter corresponding to 'NL_LANGMAX'.

'_SC_NL_MSGMAX'

     Inquire about the parameter corresponding to 'NL_MSGMAX'.

'_SC_NL_NMAX'

     Inquire about the parameter corresponding to 'NL_NMAX'.

'_SC_NL_SETMAX'

     Inquire about the parameter corresponding to 'NL_SETMAX'.

'_SC_NL_TEXTMAX'

     Inquire about the parameter corresponding to 'NL_TEXTMAX'.

==============================================================================
File: libc.info,  Node: |Examples_of_Sysconf|,  Prev: |Constants_for_Sysconf|,  Up: |Sysconf|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Examples_of_Sysconf*

32.4.3 Examples of 'sysconf'
----------------------------

We recommend that you first test for a macro definition for the
parameter you are interested in, and call 'sysconf' only if the macro is
not defined.  For example, here is how to test whether job control is
supported:

     int
     have_job_control (void)
     {
     #ifdef _POSIX_JOB_CONTROL
       return 1;
     #else
       int value = sysconf (_SC_JOB_CONTROL);
       if (value < 0)
         /* If the system is that badly wedged,
            there's no use trying to go on.  */
         fatal (strerror (errno));
       return value;
     #endif
     }

   Here is how to get the value of a numeric limit:

     int
     get_child_max ()
     {
     #ifdef CHILD_MAX
       return CHILD_MAX;
     #else
       int value = sysconf (_SC_CHILD_MAX);
       if (value < 0)
         fatal (strerror (errno));
       return value;
     #endif
     }

==============================================================================
File: libc.info,  Node: |Minimums|,  Next: |Limits_for_Files|,  Prev: |Sysconf|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Minimums*

32.5 Minimum Values for General Capacity Limits
-----------------------------------------------

Here are the names for the POSIX minimum upper bounds for the system
limit parameters.  The significance of these values is that you can
safely push to these limits without checking whether the particular
system you are using can go that far.

'_POSIX_AIO_LISTIO_MAX'

     The most restrictive limit permitted by POSIX for the maximum
     number of I/O operations that can be specified in a list I/O call.
     The value of this constant is '2'; thus you can add up to two new
     entries of the list of outstanding operations.

'_POSIX_AIO_MAX'

     The most restrictive limit permitted by POSIX for the maximum
     number of outstanding asynchronous I/O operations.  The value of
     this constant is '1'.  So you cannot expect that you can issue more
     than one operation and immediately continue with the normal work,
     receiving the notifications asynchronously.

'_POSIX_ARG_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum combined length of the ARGV and ENVIRON
     arguments that can be passed to the 'exec' functions.  Its value is
     '4096'.

'_POSIX_CHILD_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of simultaneous processes per real
     user ID. Its value is '6'.

'_POSIX_NGROUPS_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of supplementary group IDs per
     process.  Its value is '0'.

'_POSIX_OPEN_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of files that a single process can
     have open simultaneously.  Its value is '16'.

'_POSIX_SSIZE_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum value that can be stored in an object of type
     'ssize_t'.  Its value is '32767'.

'_POSIX_STREAM_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of streams that a single process can
     have open simultaneously.  Its value is '8'.

'_POSIX_TZNAME_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum length of a time zone name.  Its value is
     '3'.

'_POSIX2_RE_DUP_MAX'

     The value of this macro is the most restrictive limit permitted by
     POSIX for the numbers used in the '\{MIN,MAX\}' construct in a
     regular expression.  Its value is '255'.

==============================================================================
File: libc.info,  Node: |Limits_for_Files|,  Next: |Options_for_Files|,  Prev: |Minimums|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Limits_for_Files*

32.6 Limits on File System Capacity
-----------------------------------

The POSIX.1 standard specifies a number of parameters that describe the
limitations of the file system.  It's possible for the system to have a
fixed, uniform limit for a parameter, but this isn't the usual case.  On
most systems, it's possible for different file systems (and, for some
parameters, even different files) to have different maximum limits.  For
example, this is very likely if you use NFS to mount some of the file
systems from other machines.

   Each of the following macros is defined in 'limits.h' only if the
system has a fixed, uniform limit for the parameter in question.  If the
system allows different file systems or files to have different limits,
then the macro is undefined; use 'pathconf' or 'fpathconf' to find out
the limit that applies to a particular file.  *Note Pathconf::.

   Each parameter also has another macro, with a name starting with
'_POSIX', which gives the lowest value that the limit is allowed to have
on _any_ POSIX system.  *Note File Minimums::.

 -- Macro: int LINK_MAX

     The uniform system limit (if any) for the number of names for a
     given file.  *Note Hard Links::.

 -- Macro: int MAX_CANON

     The uniform system limit (if any) for the amount of text in a line
     of input when input editing is enabled.  *Note Canonical or Not::.

 -- Macro: int MAX_INPUT

     The uniform system limit (if any) for the total number of
     characters typed ahead as input.  *Note I/O Queues::.

 -- Macro: int NAME_MAX

     The uniform system limit (if any) for the length of a file name
     component, not including the terminating null character.

     *Portability Note:* On some systems, the GNU C Library defines
     'NAME_MAX', but does not actually enforce this limit.

 -- Macro: int PATH_MAX

     The uniform system limit (if any) for the length of an entire file
     name (that is, the argument given to system calls such as 'open'),
     including the terminating null character.

     *Portability Note:* The GNU C Library does not enforce this limit
     even if 'PATH_MAX' is defined.

 -- Macro: int PIPE_BUF

     The uniform system limit (if any) for the number of bytes that can
     be written atomically to a pipe.  If multiple processes are writing
     to the same pipe simultaneously, output from different processes
     might be interleaved in chunks of this size.  *Note Pipes and
     FIFOs::.

   These are alternative macro names for some of the same information.

 -- Macro: int MAXNAMLEN

     This is the BSD name for 'NAME_MAX'.  It is defined in 'dirent.h'.

 -- Macro: int FILENAME_MAX

     The value of this macro is an integer constant expression that
     represents the maximum length of a file name string.  It is defined
     in 'stdio.h'.

     Unlike 'PATH_MAX', this macro is defined even if there is no actual
     limit imposed.  In such a case, its value is typically a very large
     number.  *This is always the case on GNU/Hurd systems.*

     *Usage Note:* Don't use 'FILENAME_MAX' as the size of an array in
     which to store a file name!  You can't possibly make an array that
     big!  Use dynamic allocation (*note Memory Allocation::) instead.

==============================================================================
File: libc.info,  Node: |Options_for_Files|,  Next: |File_Minimums|,  Prev: |Limits_for_Files|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Options_for_Files*

32.7 Optional Features in File Support
--------------------------------------

POSIX defines certain system-specific options in the system calls for
operating on files.  Some systems support these options and others do
not.  Since these options are provided in the kernel, not in the
library, simply using the GNU C Library does not guarantee that any of
these features is supported; it depends on the system you are using.
They can also vary between file systems on a single machine.

   This section describes the macros you can test to determine whether a
particular option is supported on your machine.  If a given macro is
defined in 'unistd.h', then its value says whether the corresponding
feature is supported.  (A value of '-1' indicates no; any other value
indicates yes.)  If the macro is undefined, it means particular files
may or may not support the feature.

   Since all the machines that support the GNU C Library also support
NFS, one can never make a general statement about whether all file
systems support the '_POSIX_CHOWN_RESTRICTED' and '_POSIX_NO_TRUNC'
features.  So these names are never defined as macros in the GNU C
Library.

 -- Macro: int _POSIX_CHOWN_RESTRICTED

     If this option is in effect, the 'chown' function is restricted so
     that the only changes permitted to nonprivileged processes is to
     change the group owner of a file to either be the effective group
     ID of the process, or one of its supplementary group IDs.  *Note
     File Owner::.

 -- Macro: int _POSIX_NO_TRUNC

     If this option is in effect, file name components longer than
     'NAME_MAX' generate an 'ENAMETOOLONG' error.  Otherwise, file name
     components that are too long are silently truncated.

 -- Macro: unsigned char _POSIX_VDISABLE

     This option is only meaningful for files that are terminal devices.
     If it is enabled, then handling for special control characters can
     be disabled individually.  *Note Special Characters::.

   If one of these macros is undefined, that means that the option might
be in effect for some files and not for others.  To inquire about a
particular file, call 'pathconf' or 'fpathconf'.  *Note Pathconf::.

==============================================================================
File: libc.info,  Node: |File_Minimums|,  Next: |Pathconf|,  Prev: |Options_for_Files|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *File_Minimums*

32.8 Minimum Values for File System Limits
------------------------------------------

Here are the names for the POSIX minimum upper bounds for some of the
above parameters.  The significance of these values is that you can
safely push to these limits without checking whether the particular
system you are using can go that far.  In most cases GNU systems do not
have these strict limitations.  The actual limit should be requested if
necessary.

'_POSIX_LINK_MAX'

     The most restrictive limit permitted by POSIX for the maximum value
     of a file's link count.  The value of this constant is '8'; thus,
     you can always make up to eight names for a file without running
     into a system limit.

'_POSIX_MAX_CANON'

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a canonical input line from a terminal device.
     The value of this constant is '255'.

'_POSIX_MAX_INPUT'

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a terminal device input queue (or typeahead
     buffer).  *Note Input Modes::.  The value of this constant is
     '255'.

'_POSIX_NAME_MAX'

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a file name component.  The value of this
     constant is '14'.

'_POSIX_PATH_MAX'

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a file name.  The value of this constant is
     '256'.

'_POSIX_PIPE_BUF'

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes that can be written atomically to a pipe.  The
     value of this constant is '512'.

'SYMLINK_MAX'

     Maximum number of bytes in a symbolic link.

'POSIX_REC_INCR_XFER_SIZE'

     Recommended increment for file transfer sizes between the
     'POSIX_REC_MIN_XFER_SIZE' and 'POSIX_REC_MAX_XFER_SIZE' values.

'POSIX_REC_MAX_XFER_SIZE'

     Maximum recommended file transfer size.

'POSIX_REC_MIN_XFER_SIZE'

     Minimum recommended file transfer size.

'POSIX_REC_XFER_ALIGN'

     Recommended file transfer buffer alignment.

==============================================================================
File: libc.info,  Node: |Pathconf|,  Next: |Utility_Limits|,  Prev: |File_Minimums|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Pathconf*

32.9 Using 'pathconf'
---------------------

When your machine allows different files to have different values for a
file system parameter, you can use the functions in this section to find
out the value that applies to any particular file.

   These functions and the associated constants for the PARAMETER
argument are declared in the header file 'unistd.h'.

 -- Function: long int pathconf (const char *FILENAME, int PARAMETER)

     Preliminary: | MT-Safe | AS-Unsafe lock heap | AC-Unsafe lock fd
     mem | *Note POSIX Safety Concepts::.

     This function is used to inquire about the limits that apply to the
     file named FILENAME.

     The PARAMETER argument should be one of the '_PC_' constants listed
     below.

     The normal return value from 'pathconf' is the value you requested.
     A value of '-1' is returned both if the implementation does not
     impose a limit, and in case of an error.  In the former case,
     'errno' is not set, while in the latter case, 'errno' is set to
     indicate the cause of the problem.  So the only way to use this
     function robustly is to store '0' into 'errno' just before calling
     it.

     Besides the usual file name errors (*note File Name Errors::), the
     following error condition is defined for this function:

     'EINVAL'
          The value of PARAMETER is invalid, or the implementation
          doesn't support the PARAMETER for the specific file.

 -- Function: long int fpathconf (int FILEDES, int PARAMETER)

     Preliminary: | MT-Safe | AS-Unsafe lock heap | AC-Unsafe lock fd
     mem | *Note POSIX Safety Concepts::.

     This is just like 'pathconf' except that an open file descriptor is
     used to specify the file for which information is requested,
     instead of a file name.

     The following 'errno' error conditions are defined for this
     function:

     'EBADF'
          The FILEDES argument is not a valid file descriptor.

     'EINVAL'
          The value of PARAMETER is invalid, or the implementation
          doesn't support the PARAMETER for the specific file.

   Here are the symbolic constants that you can use as the PARAMETER
argument to 'pathconf' and 'fpathconf'.  The values are all integer
constants.

'_PC_LINK_MAX'

     Inquire about the value of 'LINK_MAX'.

'_PC_MAX_CANON'

     Inquire about the value of 'MAX_CANON'.

'_PC_MAX_INPUT'

     Inquire about the value of 'MAX_INPUT'.

'_PC_NAME_MAX'

     Inquire about the value of 'NAME_MAX'.

'_PC_PATH_MAX'

     Inquire about the value of 'PATH_MAX'.

'_PC_PIPE_BUF'

     Inquire about the value of 'PIPE_BUF'.

'_PC_CHOWN_RESTRICTED'

     Inquire about the value of '_POSIX_CHOWN_RESTRICTED'.

'_PC_NO_TRUNC'

     Inquire about the value of '_POSIX_NO_TRUNC'.

'_PC_VDISABLE'

     Inquire about the value of '_POSIX_VDISABLE'.

'_PC_SYNC_IO'

     Inquire about the value of '_POSIX_SYNC_IO'.

'_PC_ASYNC_IO'

     Inquire about the value of '_POSIX_ASYNC_IO'.

'_PC_PRIO_IO'

     Inquire about the value of '_POSIX_PRIO_IO'.

'_PC_FILESIZEBITS'

     Inquire about the availability of large files on the filesystem.

'_PC_REC_INCR_XFER_SIZE'

     Inquire about the value of 'POSIX_REC_INCR_XFER_SIZE'.

'_PC_REC_MAX_XFER_SIZE'

     Inquire about the value of 'POSIX_REC_MAX_XFER_SIZE'.

'_PC_REC_MIN_XFER_SIZE'

     Inquire about the value of 'POSIX_REC_MIN_XFER_SIZE'.

'_PC_REC_XFER_ALIGN'

     Inquire about the value of 'POSIX_REC_XFER_ALIGN'.

   *Portability Note:* On some systems, the GNU C Library does not
enforce '_PC_NAME_MAX' or '_PC_PATH_MAX' limits.

==============================================================================
File: libc.info,  Node: |Utility_Limits|,  Next: |Utility_Minimums|,  Prev: |Pathconf|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Utility_Limits*

32.10 Utility Program Capacity Limits
-------------------------------------

The POSIX.2 standard specifies certain system limits that you can access
through 'sysconf' that apply to utility behavior rather than the
behavior of the library or the operating system.

   The GNU C Library defines macros for these limits, and 'sysconf'
returns values for them if you ask; but these values convey no
meaningful information.  They are simply the smallest values that
POSIX.2 permits.

 -- Macro: int BC_BASE_MAX

     The largest value of 'obase' that the 'bc' utility is guaranteed to
     support.

 -- Macro: int BC_DIM_MAX

     The largest number of elements in one array that the 'bc' utility
     is guaranteed to support.

 -- Macro: int BC_SCALE_MAX

     The largest value of 'scale' that the 'bc' utility is guaranteed to
     support.

 -- Macro: int BC_STRING_MAX

     The largest number of characters in one string constant that the
     'bc' utility is guaranteed to support.

 -- Macro: int COLL_WEIGHTS_MAX

     The largest number of weights that can necessarily be used in
     defining the collating sequence for a locale.

 -- Macro: int EXPR_NEST_MAX

     The maximum number of expressions that can be nested within
     parentheses by the 'expr' utility.

 -- Macro: int LINE_MAX

     The largest text line that the text-oriented POSIX.2 utilities can
     support.  (If you are using the GNU versions of these utilities,
     then there is no actual limit except that imposed by the available
     virtual memory, but there is no way that the library can tell you
     this.)

 -- Macro: int EQUIV_CLASS_MAX

     The maximum number of weights that can be assigned to an entry of
     the 'LC_COLLATE' category 'order' keyword in a locale definition.
     The GNU C Library does not presently support locale definitions.

==============================================================================
File: libc.info,  Node: |Utility_Minimums|,  Next: |String_Parameters|,  Prev: |Utility_Limits|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Utility_Minimums*

32.11 Minimum Values for Utility Limits
---------------------------------------

'_POSIX2_BC_BASE_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     value of 'obase' in the 'bc' utility.  Its value is '99'.

'_POSIX2_BC_DIM_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     size of an array in the 'bc' utility.  Its value is '2048'.

'_POSIX2_BC_SCALE_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     value of 'scale' in the 'bc' utility.  Its value is '99'.

'_POSIX2_BC_STRING_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     size of a string constant in the 'bc' utility.  Its value is
     '1000'.

'_POSIX2_COLL_WEIGHTS_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     number of weights that can necessarily be used in defining the
     collating sequence for a locale.  Its value is '2'.

'_POSIX2_EXPR_NEST_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     number of expressions nested within parenthesis when using the
     'expr' utility.  Its value is '32'.

'_POSIX2_LINE_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     size of a text line that the text utilities can handle.  Its value
     is '2048'.

'_POSIX2_EQUIV_CLASS_MAX'

     The most restrictive limit permitted by POSIX.2 for the maximum
     number of weights that can be assigned to an entry of the
     'LC_COLLATE' category 'order' keyword in a locale definition.  Its
     value is '2'.  The GNU C Library does not presently support locale
     definitions.

==============================================================================
File: libc.info,  Node: |String_Parameters|,  Prev: |Utility_Minimums|,  Up: |System_Configuration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *String_Parameters*

32.12 String-Valued Parameters
------------------------------

POSIX.2 defines a way to get string-valued parameters from the operating
system with the function 'confstr':

 -- Function: size_t confstr (int PARAMETER, char *BUF, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function reads the value of a string-valued system parameter,
     storing the string into LEN bytes of memory space starting at BUF.
     The PARAMETER argument should be one of the '_CS_' symbols listed
     below.

     The normal return value from 'confstr' is the length of the string
     value that you asked for.  If you supply a null pointer for BUF,
     then 'confstr' does not try to store the string; it just returns
     its length.  A value of '0' indicates an error.

     If the string you asked for is too long for the buffer (that is,
     longer than 'LEN - 1'), then 'confstr' stores just that much
     (leaving room for the terminating null character).  You can tell
     that this has happened because 'confstr' returns a value greater
     than or equal to LEN.

     The following 'errno' error conditions are defined for this
     function:

     'EINVAL'
          The value of the PARAMETER is invalid.

   Currently there is just one parameter you can read with 'confstr':

'_CS_PATH'

     This parameter's value is the recommended default path for
     searching for executable files.  This is the path that a user has
     by default just after logging in.

'_CS_LFS_CFLAGS'

     The returned string specifies which additional flags must be given
     to the C compiler if a source is compiled using the
     '_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

'_CS_LFS_LDFLAGS'

     The returned string specifies which additional flags must be given
     to the linker if a source is compiled using the '_LARGEFILE_SOURCE'
     feature select macro; *note Feature Test Macros::.

'_CS_LFS_LIBS'

     The returned string specifies which additional libraries must be
     linked to the application if a source is compiled using the
     '_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

'_CS_LFS_LINTFLAGS'

     The returned string specifies which additional flags must be given
     to the lint tool if a source is compiled using the
     '_LARGEFILE_SOURCE' feature select macro; *note Feature Test
     Macros::.

'_CS_LFS64_CFLAGS'

     The returned string specifies which additional flags must be given
     to the C compiler if a source is compiled using the
     '_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

'_CS_LFS64_LDFLAGS'

     The returned string specifies which additional flags must be given
     to the linker if a source is compiled using the
     '_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

'_CS_LFS64_LIBS'

     The returned string specifies which additional libraries must be
     linked to the application if a source is compiled using the
     '_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

'_CS_LFS64_LINTFLAGS'

     The returned string specifies which additional flags must be given
     to the lint tool if a source is compiled using the
     '_LARGEFILE64_SOURCE' feature select macro; *note Feature Test
     Macros::.

   The way to use 'confstr' without any arbitrary limit on string size
is to call it twice: first call it to get the length, allocate the
buffer accordingly, and then call 'confstr' again to fill the buffer,
like this:

     char *
     get_default_path (void)
     {
       size_t len = confstr (_CS_PATH, NULL, 0);
       char *buffer = (char *) xmalloc (len);

       if (confstr (_CS_PATH, buf, len + 1) == 0)
         {
           free (buffer);
           return NULL;
         }

       return buffer;
     }
==============================================================================
File: libc.info,  Node: |Cryptographic_Functions|,  Next: |Debugging_Support|,  Prev: |System_Configuration|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Cryptographic_Functions*

33 Cryptographic Functions
==========================

The GNU C Library includes only a few special-purpose cryptographic
functions: one-way hash functions for passphrase storage, and access to
a cryptographic randomness source, if one is provided by the operating
system.  Programs that need general-purpose cryptography should use a
dedicated cryptography library, such as libgcrypt.

   Many countries place legal restrictions on the import, export,
possession, or use of cryptographic software.  We deplore these
restrictions, but we must still warn you that the GNU C Library may be
subject to them, even if you do not use the functions in this chapter
yourself.  The restrictions vary from place to place and are changed
often, so we cannot give any more specific advice than this warning.

MENU

* |Passphrase_Storage|::          One-way hashing for passphrases.
* |Unpredictable_Bytes|::         Randomness for cryptographic purposes.

==============================================================================
File: libc.info,  Node: |Passphrase_Storage|,  Next: |Unpredictable_Bytes|,  Up: |Cryptographic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Passphrase_Storage*

33.1 Passphrase Storage
-----------------------

Sometimes it is necessary to be sure that a user is authorized to use
some service a machine provides--for instance, to log in as a particular
user id (*note Users and Groups::).  One traditional way of doing this
is for each user to choose a secret "passphrase"; then, the system can
ask someone claiming to be a user what the user's passphrase is, and if
the person gives the correct passphrase then the system can grant the
appropriate privileges.  (Traditionally, these were called "passwords,"
but nowadays a single word is too easy to guess.)

   Programs that handle passphrases must take special care not to reveal
them to anyone, no matter what.  It is not enough to keep them in a file
that is only accessible with special privileges.  The file might be
"leaked" via a bug or misconfiguration, and system administrators
shouldn't learn everyone's passphrase even if they have to edit that
file for some reason.  To avoid this, passphrases should also be
converted into "one-way hashes", using a "one-way function", before they
are stored.

   A one-way function is easy to compute, but there is no known way to
compute its inverse.  This means the system can easily check
passphrases, by hashing them and comparing the result with the stored
hash.  But an attacker who discovers someone's passphrase hash can only
discover the passphrase it corresponds to by guessing and checking.  The
one-way functions are designed to make this process impractically slow,
for all but the most obvious guesses.  (Do not use a word from the
dictionary as your passphrase.)

   The GNU C Library provides an interface to four one-way functions,
based on the SHA-2-512, SHA-2-256, MD5, and DES cryptographic
primitives.  New passphrases should be hashed with either of the
SHA-based functions.  The others are too weak for newly set passphrases,
but we continue to support them for verifying old passphrases.  The
DES-based hash is especially weak, because it ignores all but the first
eight characters of its input.

 -- Function: char * crypt (const char *PHRASE, const char *SALT)

     Preliminary: | MT-Unsafe race:crypt | AS-Unsafe corrupt lock heap
     dlopen | AC-Unsafe lock mem | *Note POSIX Safety Concepts::.

     The function 'crypt' converts a passphrase string, PHRASE, into a
     one-way hash suitable for storage in the user database.  The string
     that it returns will consist entirely of printable ASCII
     characters.  It will not contain whitespace, nor any of the
     characters ':', ';', '*', '!', or '\'.

     The SALT parameter controls which one-way function is used, and it
     also ensures that the output of the one-way function is different
     for every user, even if they have the same passphrase.  This makes
     it harder to guess passphrases from a large user database.  Without
     salt, the attacker could make a guess, run 'crypt' on it once, and
     compare the result with all the hashes.  Salt forces the attacker
     to make separate calls to 'crypt' for each user.

     To verify a passphrase, pass the previously hashed passphrase as
     the SALT.  To hash a new passphrase for storage, set SALT to a
     string consisting of a prefix plus a sequence of randomly chosen
     characters, according to this table:

     One-way        Prefix  Random sequence
     function
     ----------------------------------------------
     SHA-2-512      '$6$'   16 characters
     SHA-2-256      '$5$'   16 characters
     MD5            '$1$'   8 characters
     DES            ''      2 characters

     In all cases, the random characters should be chosen from the
     alphabet './0-9A-Za-z'.

     With all of the hash functions _except_ DES, PHRASE can be
     arbitrarily long, and all eight bits of each byte are significant.
     With DES, only the first eight characters of PHRASE affect the
     output, and the eighth bit of each byte is also ignored.

     'crypt' can fail.  Some implementations return 'NULL' on failure,
     and others return an _invalid_ hashed passphrase, which will begin
     with a '*' and will not be the same as SALT.  In either case,
     'errno' will be set to indicate the problem.  Some of the possible
     error codes are:

     'EINVAL'
          SALT is invalid; neither a previously hashed passphrase, nor a
          well-formed new salt for any of the supported hash functions.

     'EPERM'
          The system configuration forbids use of the hash function
          selected by SALT.

     'ENOMEM'
          Failed to allocate internal scratch storage.

     'ENOSYS'
     'EOPNOTSUPP'
          Hashing passphrases is not supported at all, or the hash
          function selected by SALT is not supported.  The GNU C Library
          does not use these error codes, but they may be encountered on
          other operating systems.

     'crypt' uses static storage for both internal scratchwork and the
     string it returns.  It is not safe to call 'crypt' from multiple
     threads simultaneously, and the string it returns will be
     overwritten by any subsequent call to 'crypt'.

     'crypt' is specified in the X/Open Portability Guide and is present
     on nearly all historical Unix systems.  However, the XPG does not
     specify any one-way functions.

     'crypt' is declared in 'unistd.h'.  The GNU C Library also declares
     this function in 'crypt.h'.

 -- Function: char * crypt_r (const char *PHRASE, const char *SALT,
          struct crypt_data *DATA)

     Preliminary: | MT-Safe | AS-Unsafe corrupt lock heap dlopen |
     AC-Unsafe lock mem | *Note POSIX Safety Concepts::.

     The function 'crypt_r' is a thread-safe version of 'crypt'.
     Instead of static storage, it uses the memory pointed to by its
     DATA argument for both scratchwork and the string it returns.  It
     can safely be used from multiple threads, as long as different DATA
     objects are used in each thread.  The string it returns will still
     be overwritten by another call with the same DATA.

     DATA must point to a 'struct crypt_data' object allocated by the
     caller.  All of the fields of 'struct crypt_data' are private, but
     before one of these objects is used for the first time, it must be
     initialized to all zeroes, using 'memset' or similar.  After that,
     it can be reused for many calls to 'crypt_r' without erasing it
     again.  'struct crypt_data' is very large, so it is best to
     allocate it with 'malloc' rather than as a local variable.  *Note
     Memory Allocation::.

     'crypt_r' is a GNU extension.  It is declared in 'crypt.h', as is
     'struct crypt_data'.

   The following program shows how to use 'crypt' the first time a
passphrase is entered.  It uses 'getentropy' to make the salt as
unpredictable as possible; *note Unpredictable Bytes::.


     #include <stdio.h>
     #include <unistd.h>
     #include <crypt.h>

     int
     main(void)
     {
       unsigned char ubytes[16];
       char salt[20];
       const char *const saltchars =
         "./0123456789ABCDEFGHIJKLMNOPQRST"
         "UVWXYZabcdefghijklmnopqrstuvwxyz";
       char *hash;
       int i;

       /* Retrieve 16 unpredictable bytes from the operating system. */
       if (getentropy (ubytes, sizeof ubytes))
         {
           perror ("getentropy");
           return 1;
         }

       /* Use them to fill in the salt string. */
       salt[0] = '$';
       salt[1] = '5'; /* SHA-256 */
       salt[2] = '$';
       for (i = 0; i < 16; i++)
         salt[3+i] = saltchars[ubytes[i] & 0x3f];
       salt[3+i] = '\0';

       /* Read in the user's passphrase and hash it. */
       hash = crypt (getpass ("Enter new passphrase: "), salt);
       if (!hash || hash[0] == '*')
         {
           perror ("crypt");
           return 1;
         }

       /* Print the results. */
       puts (hash);
       return 0;
     }

   The next program demonstrates how to verify a passphrase.  It checks
a hash hardcoded into the program, because looking up real users' hashed
passphrases may require special privileges (*note User Database::).  It
also shows that different one-way functions produce different hashes for
the same passphrase.


     #include <stdio.h>
     #include <string.h>
     #include <unistd.h>
     #include <crypt.h>

     /* 'GNU's Not Unix' hashed using SHA-256, MD5, and DES. */
     static const char hash_sha[] =
       "$5$DQ2z5NHf1jNJnChB$kV3ZTR0aUaosujPhLzR84Llo3BsspNSe4/tsp7VoEn6";
     static const char hash_md5[] = "$1$A3TxDv41$rtXVTUXl2LkeSV0UU5xxs1";
     static const char hash_des[] = "FgkTuF98w5DaI";

     int
     main(void)
     {
       char *phrase;
       int status = 0;

       /* Prompt for a passphrase. */
       phrase = getpass ("Enter passphrase: ");

       /* Compare against the stored hashes.  Any input that begins with
          'GNU's No' will match the DES hash, but the other two will
          only match 'GNU's Not Unix'. */

       if (strcmp (crypt (phrase, hash_sha), hash_sha))
         {
           puts ("SHA: not ok");
           status = 1;
         }
       else
         puts ("SHA: ok");

       if (strcmp (crypt (phrase, hash_md5), hash_md5))
         {
           puts ("MD5: not ok");
           status = 1;
         }
       else
         puts ("MD5: ok");

       if (strcmp (crypt (phrase, hash_des), hash_des))
         {
           puts ("DES: not ok");
           status = 1;
         }
       else
         puts ("DES: ok");

       return status;
     }

==============================================================================
File: libc.info,  Node: |Unpredictable_Bytes|,  Prev: |Passphrase_Storage|,  Up: |Cryptographic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Unpredictable_Bytes*

33.2 Generating Unpredictable Bytes
-----------------------------------

Cryptographic applications often need some random data that will be as
difficult as possible for a hostile eavesdropper to guess.  For
instance, encryption keys should be chosen at random, and the "salt"
strings used by 'crypt' (*note Passphrase Storage::) should also be
chosen at random.

   Some pseudo-random number generators do not provide
unpredictable-enough output for cryptographic applications; *note
Pseudo-Random Numbers::.  Such applications need to use a "cryptographic
random number generator" (CRNG), also sometimes called a
"cryptographically strong pseudo-random number generator" (CSPRNG) or
"deterministic random bit generator" (DRBG).

   Currently, the GNU C Library does not provide a cryptographic random
number generator, but it does provide functions that read random data
from a "randomness source" supplied by the operating system.  The
randomness source is a CRNG at heart, but it also continually "re-seeds"
itself from physical sources of randomness, such as electronic noise and
clock jitter.  This means applications do not need to do anything to
ensure that the random numbers it produces are different on each run.

   The catch, however, is that these functions will only produce
relatively short random strings in any one call.  Often this is not a
problem, but applications that need more than a few kilobytes of
cryptographically strong random data should call these functions once
and use their output to seed a CRNG.

   Most applications should use 'getentropy'.  The 'getrandom' function
is intended for low-level applications which need additional control
over blocking behavior.

 -- Function: int getentropy (void *BUFFER, size_t LENGTH)

     | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety Concepts::.

     This function writes exactly LENGTH bytes of random data to the
     array starting at BUFFER.  LENGTH can be no more than 256.  On
     success, it returns zero.  On failure, it returns -1, and 'errno'
     is set to indicate the problem.  Some of the possible errors are
     listed below.

     'ENOSYS'
          The operating system does not implement a randomness source,
          or does not support this way of accessing it.  (For instance,
          the system call used by this function was added to the Linux
          kernel in version 3.17.)

     'EFAULT'
          The combination of BUFFER and LENGTH arguments specifies an
          invalid memory range.

     'EIO'
          LENGTH is larger than 256, or the kernel entropy pool has
          suffered a catastrophic failure.

     A call to 'getentropy' can only block when the system has just
     booted and the randomness source has not yet been initialized.
     However, if it does block, it cannot be interrupted by signals or
     thread cancellation.  Programs intended to run in very early stages
     of the boot process may need to use 'getrandom' in non-blocking
     mode instead, and be prepared to cope with random data not being
     available at all.

     The 'getentropy' function is declared in the header file
     'sys/random.h'.  It is derived from OpenBSD.

 -- Function: ssize_t getrandom (void *BUFFER, size_t LENGTH, unsigned
          int FLAGS)

     | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety Concepts::.

     This function writes up to LENGTH bytes of random data to the array
     starting at BUFFER.  The FLAGS argument should be either zero, or
     the bitwise OR of some of the following flags:

     'GRND_RANDOM'
          Use the '/dev/random' (blocking) source instead of the
          '/dev/urandom' (non-blocking) source to obtain randomness.

          If this flag is specified, the call may block, potentially for
          quite some time, even after the randomness source has been
          initialized.  If it is not specified, the call can only block
          when the system has just booted and the randomness source has
          not yet been initialized.

     'GRND_NONBLOCK'
          Instead of blocking, return to the caller immediately if no
          data is available.

     Unlike 'getentropy', the 'getrandom' function is a cancellation
     point, and if it blocks, it can be interrupted by signals.

     On success, 'getrandom' returns the number of bytes which have been
     written to the buffer, which may be less than LENGTH.  On error, it
     returns -1, and 'errno' is set to indicate the problem.  Some of
     the possible errors are:

     'ENOSYS'
          The operating system does not implement a randomness source,
          or does not support this way of accessing it.  (For instance,
          the system call used by this function was added to the Linux
          kernel in version 3.17.)

     'EAGAIN'
          No random data was available and 'GRND_NONBLOCK' was specified
          in FLAGS.

     'EFAULT'
          The combination of BUFFER and LENGTH arguments specifies an
          invalid memory range.

     'EINTR'
          The system call was interrupted.  During the system boot
          process, before the kernel randomness pool is initialized,
          this can happen even if FLAGS is zero.

     'EINVAL'
          The FLAGS argument contains an invalid combination of flags.

     The 'getrandom' function is declared in the header file
     'sys/random.h'.  It is a GNU extension.

==============================================================================
File: libc.info,  Node: |Debugging_Support|,  Next: |Threads|,  Prev: |Cryptographic_Functions|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Debugging_Support*

34 Debugging support
====================

Applications are usually debugged using dedicated debugger programs.
But sometimes this is not possible and, in any case, it is useful to
provide the developer with as much information as possible at the time
the problems are experienced.  For this reason a few functions are
provided which a program can use to help the developer more easily
locate the problem.

MENU

* |Backtraces|::                Obtaining and printing a back trace of the
                               current stack.

==============================================================================
File: libc.info,  Node: |Backtraces|,  Up: |Debugging_Support|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Backtraces*

34.1 Backtraces
---------------

A "backtrace" is a list of the function calls that are currently active
in a thread.  The usual way to inspect a backtrace of a program is to
use an external debugger such as gdb.  However, sometimes it is useful
to obtain a backtrace programmatically from within a program, e.g., for
the purposes of logging or diagnostics.

   The header file 'execinfo.h' declares three functions that obtain and
manipulate backtraces of the current thread.

 -- Function: int backtrace (void **BUFFER, int SIZE)

     Preliminary: | MT-Safe | AS-Unsafe init heap dlopen plugin lock |
     AC-Unsafe init mem lock fd | *Note POSIX Safety Concepts::.

     The 'backtrace' function obtains a backtrace for the current
     thread, as a list of pointers, and places the information into
     BUFFER.  The argument SIZE should be the number of 'void *'
     elements that will fit into BUFFER.  The return value is the actual
     number of entries of BUFFER that are obtained, and is at most SIZE.

     The pointers placed in BUFFER are actually return addresses
     obtained by inspecting the stack, one return address per stack
     frame.

     Note that certain compiler optimizations may interfere with
     obtaining a valid backtrace.  Function inlining causes the inlined
     function to not have a stack frame; tail call optimization replaces
     one stack frame with another; frame pointer elimination will stop
     'backtrace' from interpreting the stack contents correctly.

 -- Function: char ** backtrace_symbols (void *const *BUFFER, int SIZE)

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem lock |
     *Note POSIX Safety Concepts::.

     The 'backtrace_symbols' function translates the information
     obtained from the 'backtrace' function into an array of strings.
     The argument BUFFER should be a pointer to an array of addresses
     obtained via the 'backtrace' function, and SIZE is the number of
     entries in that array (the return value of 'backtrace').

     The return value is a pointer to an array of strings, which has
     SIZE entries just like the array BUFFER.  Each string contains a
     printable representation of the corresponding element of BUFFER.
     It includes the function name (if this can be determined), an
     offset into the function, and the actual return address (in
     hexadecimal).

     Currently, the function name and offset can only be obtained on
     systems that use the ELF binary format for programs and libraries.
     On other systems, only the hexadecimal return address will be
     present.  Also, you may need to pass additional flags to the linker
     to make the function names available to the program.  (For example,
     on systems using GNU ld, you must pass '-rdynamic'.)

     The return value of 'backtrace_symbols' is a pointer obtained via
     the 'malloc' function, and it is the responsibility of the caller
     to 'free' that pointer.  Note that only the return value need be
     freed, not the individual strings.

     The return value is 'NULL' if sufficient memory for the strings
     cannot be obtained.

 -- Function: void backtrace_symbols_fd (void *const *BUFFER, int SIZE,
          int FD)

     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe lock | *Note POSIX
     Safety Concepts::.

     The 'backtrace_symbols_fd' function performs the same translation
     as the function 'backtrace_symbols' function.  Instead of returning
     the strings to the caller, it writes the strings to the file
     descriptor FD, one per line.  It does not use the 'malloc'
     function, and can therefore be used in situations where that
     function might fail.

   The following program illustrates the use of these functions.  Note
that the array to contain the return addresses returned by 'backtrace'
is allocated on the stack.  Therefore code like this can be used in
situations where the memory handling via 'malloc' does not work anymore
(in which case the 'backtrace_symbols' has to be replaced by a
'backtrace_symbols_fd' call as well).  The number of return addresses is
normally not very large.  Even complicated programs rather seldom have a
nesting level of more than, say, 50 and with 200 possible entries
probably all programs should be covered.


     #include <execinfo.h>
     #include <stdio.h>
     #include <stdlib.h>

     /* Obtain a backtrace and print it to 'stdout'. */
     void
     print_trace (void)
     {
       void *array[10];
       size_t size;
       char **strings;
       size_t i;

       size = backtrace (array, 10);
       strings = backtrace_symbols (array, size);

       printf ("Obtained %zd stack frames.\n", size);

       for (i = 0; i < size; i++)
          printf ("%s\n", strings[i]);

       free (strings);
     }

     /* A dummy function to make the backtrace more interesting. */
     void
     dummy_function (void)
     {
       print_trace ();
     }

     int
     main (void)
     {
       dummy_function ();
       return 0;
     }

==============================================================================
File: libc.info,  Node: |Threads|,  Next: |Internal_Probes|,  Prev: |Debugging_Support|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Threads*

35 Threads
==========

This chapter describes functions used for managing threads.  The GNU C
Library provides two threading implementations: ISO C threads and POSIX
threads.

MENU

* |ISO_C_Threads|::	Threads based on the ISO C specification.
* |POSIX_Threads|::	Threads based on the POSIX specification.

==============================================================================
File: libc.info,  Node: |ISO_C_Threads|,  Next: |POSIX_Threads|,  Up: |Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *ISO_C_Threads*

35.1 ISO C Threads
------------------

This section describes the GNU C Library ISO C threads implementation.
To have a deeper understanding of this API, it is strongly recommended
to read ISO/IEC 9899:2011, section 7.26, in which ISO C threads were
originally specified.  All types and function prototypes are declared in
the header file 'threads.h'.

MENU

* |ISO_C_Threads_Return_Values|:: Symbolic constants that represent a
				function's return value.
* |ISO_C_Thread_Management|::	Support for basic threading.
* |Call_Once|::			Single-call functions and macros.
* |ISO_C_Mutexes|::		A low-level mechanism for mutual exclusion.
* |ISO_C_Condition_Variables|::	High-level objects for thread synchronization.
* |ISO_C_Thread_local_Storage|::	Functions to support thread-local storage.

==============================================================================
File: libc.info,  Node: |ISO_C_Threads_Return_Values|,  Next: |ISO_C_Thread_Management|,  Up: ISO C Threads
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *ISO_C_Threads_Return_Values*

35.1.1 Return Values
--------------------

The ISO C thread specification provides the following enumeration
constants for return values from functions in the API:

'thrd_timedout'

     A specified time was reached without acquiring the requested
     resource, usually a mutex or condition variable.

'thrd_success'

     The requested operation succeeded.

'thrd_busy'

     The requested operation failed because a requested resource is
     already in use.

'thrd_error'

     The requested operation failed.

'thrd_nomem'

     The requested operation failed because it was unable to allocate
     enough memory.

==============================================================================
File: libc.info,  Node: |ISO_C_Thread_Management|,  Next: |Call_Once|,  Prev: |ISO_C_Threads_Return_Values|,  Up: |ISO_C_Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *ISO_C_Thread_Management*

35.1.2 Creation and Control
---------------------------

The GNU C Library implements a set of functions that allow the user to
easily create and use threads.  Additional functionality is provided to
control the behavior of threads.

   The following data types are defined for managing threads:

 -- Data Type: thrd_t

     A unique object that identifies a thread.

 -- Data Type: thrd_start_t

     This data type is an 'int (*) (void *)' typedef that is passed to
     'thrd_create' when creating a new thread.  It should point to the
     first function that thread will run.

   The following functions are used for working with threads:

 -- Function: int thrd_create (thrd_t *THR, thrd_start_t FUNC, void
          *ARG)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_create' creates a new thread that will execute the function
     FUNC.  The object pointed to by ARG will be used as the argument to
     FUNC.  If successful, THR is set to the new thread identifier.

     This function may return 'thrd_success', 'thrd_nomem', or
     'thrd_error'.

 -- Function: thrd_t thrd_current (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns the identifier of the calling thread.

 -- Function: int thrd_equal (thrd_t LHS, thrd_t RHS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_equal' checks whether LHS and RHS refer to the same thread.
     If LHS and RHS are different threads, this function returns 0;
     otherwise, the return value is non-zero.

 -- Function: int thrd_sleep (const struct timespec *TIME_POINT, struct
          timespec *REMAINING)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_sleep' blocks the execution of the current thread for at
     least until the elapsed time pointed to by TIME_POINT has been
     reached.  This function does not take an absolute time, but a
     duration that the thread is required to be blocked.  *Note Time
     Basics::, and *note Elapsed Time::.

     The thread may wake early if a signal that is not ignored is
     received.  In such a case, if 'remaining' is not NULL, the
     remaining time duration is stored in the object pointed to by
     REMAINING.

     'thrd_sleep' returns 0 if it blocked for at least the amount of
     time in 'time_point', -1 if it was interrupted by a signal, or a
     negative number on failure.

 -- Function: void thrd_yield (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_yield' provides a hint to the implementation to reschedule
     the execution of the current thread, allowing other threads to run.

 -- Function: _Noreturn void thrd_exit (int RES)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_exit' terminates execution of the calling thread and sets its
     result code to RES.

     If this function is called from a single-threaded process, the call
     is equivalent to calling 'exit' with 'EXIT_SUCCESS' (*note Normal
     Termination::).  Also note that returning from a function that
     started a thread is equivalent to calling 'thrd_exit'.

 -- Function: int thrd_detach (thrd_t THR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_detach' detaches the thread identified by 'thr' from the
     current control thread.  The resources held by the detached thread
     will be freed automatically once the thread exits.  The parent
     thread will never be notified by any THR signal.

     Calling 'thrd_detach' on a thread that was previously detached or
     joined by another thread results in undefined behavior.

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: int thrd_join (thrd_t THR, int *RES)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'thrd_join' blocks the current thread until the thread identified
     by 'thr' finishes execution.  If 'res' is not NULL, the result code
     of the thread is put into the location pointed to by RES.  The
     termination of the thread "synchronizes-with" the completion of
     this function, meaning both threads have arrived at a common point
     in their execution.

     Calling 'thrd_join' on a thread that was previously detached or
     joined by another thread results in undefined behavior.

     This function returns either 'thrd_success' or 'thrd_error'.

==============================================================================
File: libc.info,  Node: |Call_Once|,  Next: |ISO_C_Mutexes|,  Prev: |ISO_C_Thread_Management|,  Up: |ISO_C_Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Call_Once*

35.1.3 Call Once
----------------

In order to guarantee single access to a function, the GNU C Library
implements a "call once function" to ensure a function is only called
once in the presence of multiple, potentially calling threads.

 -- Data Type: once_flag

     A complete object type capable of holding a flag used by
     'call_once'.

 -- Macro: ONCE_FLAG_INIT

     This value is used to initialize an object of type 'once_flag'.

 -- Function: void call_once (once_flag *FLAG, void (*FUNC) (void))

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'call_once' calls function FUNC exactly once, even if invoked from
     several threads.  The completion of the function FUNC
     synchronizes-with all previous or subsequent calls to 'call_once'
     with the same 'flag' variable.

==============================================================================
File: libc.info,  Node: |ISO_C_Mutexes|,  Next: |ISO_C_Condition_Variables|,  Prev: |Call_Once|,  Up: |ISO_C_Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *ISO_C_Mutexes*

35.1.4 Mutexes
--------------

To have better control of resources and how threads access them, the GNU
C Library implements a "mutex" object, which can help avoid race
conditions and other concurrency issues.  The term "mutex" refers to
mutual exclusion.

   The fundamental data type for a mutex is the 'mtx_t':

 -- Data Type: mtx_t

     The 'mtx_t' data type uniquely identifies a mutex object.

   The ISO C standard defines several types of mutexes.  They are
represented by the following symbolic constants:

'mtx_plain'

     A mutex that does not support timeout, or test and return.

'mtx_recursive'

     A mutex that supports recursive locking, which means that the
     owning thread can lock it more than once without causing deadlock.

'mtx_timed'

     A mutex that supports timeout.

   The following functions are used for working with mutexes:

 -- Function: int mtx_init (mtx_t *MUTEX, int TYPE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'mtx_init' creates a new mutex object with type TYPE.  The object
     pointed to by MUTEX is set to the identifier of the newly created
     mutex.

     Not all combinations of mutex types are valid for the 'type'
     argument.  Valid uses of mutex types for the 'type' argument are:

     'mtx_plain'
          A non-recursive mutex that does not support timeout.

     'mtx_timed'
          A non-recursive mutex that does support timeout.

     'mtx_plain | mtx_recursive'
          A recursive mutex that does not support timeout.

     'mtx_timed | mtx_recursive'
          A recursive mutex that does support timeout.

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: int mtx_lock (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     'mtx_lock' blocks the current thread until the mutex pointed to by
     MUTEX is locked.  The behavior is undefined if the current thread
     has already locked the mutex and the mutex is not recursive.

     Prior calls to 'mtx_unlock' on the same mutex synchronize-with this
     operation (if this operation succeeds), and all lock/unlock
     operations on any given mutex form a single total order (similar to
     the modification order of an atomic).

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: int mtx_timedlock (mtx_t *restrict MUTEX, const struct
          timespec *restrict TIME_POINT)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     'mtx_timedlock' blocks the current thread until the mutex pointed
     to by MUTEX is locked or until the calendar time pointed to by
     TIME_POINT has been reached.  Since this function takes an absolute
     time, if a duration is required, the calendar time must be
     calculated manually.  *Note Time Basics::, and *note Calendar
     Time::.

     If the current thread has already locked the mutex and the mutex is
     not recursive, or if the mutex does not support timeout, the
     behavior of this function is undefined.

     Prior calls to 'mtx_unlock' on the same mutex synchronize-with this
     operation (if this operation succeeds), and all lock/unlock
     operations on any given mutex form a single total order (similar to
     the modification order of an atomic).

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: int mtx_trylock (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     'mtx_trylock' tries to lock the mutex pointed to by MUTEX without
     blocking.  It returns immediately if the mutex is already locked.

     Prior calls to 'mtx_unlock' on the same mutex synchronize-with this
     operation (if this operation succeeds), and all lock/unlock
     operations on any given mutex form a single total order (similar to
     the modification order of an atomic).

     This function returns 'thrd_success' if the lock was obtained,
     'thrd_busy' if the mutex is already locked, and 'thrd_error' on
     failure.

 -- Function: int mtx_unlock (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'mtx_unlock' unlocks the mutex pointed to by MUTEX.  The behavior
     is undefined if the mutex is not locked by the calling thread.

     This function synchronizes-with subsequent 'mtx_lock',
     'mtx_trylock', and 'mtx_timedlock' calls on the same mutex.  All
     lock/unlock operations on any given mutex form a single total order
     (similar to the modification order of an atomic).

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: void mtx_destroy (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'mtx_destroy' destroys the mutex pointed to by MUTEX.  If there are
     any threads waiting on the mutex, the behavior is undefined.

==============================================================================
File: libc.info,  Node: |ISO_C_Condition_Variables|,  Next: |ISO_C_Thread_local_Storage|,  Prev: |ISO_C_Mutexes|,  Up: |ISO_C_Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *ISO_C_Condition_Variables*

35.1.5 Condition Variables
--------------------------

Mutexes are not the only synchronization mechanisms available.  For some
more complex tasks, the GNU C Library also implements "condition
variables", which allow the programmer to think at a higher level when
solving complex synchronization problems.  They are used to synchronize
threads waiting on a certain condition to happen.

   The fundamental data type for condition variables is the 'cnd_t':

 -- Data Type: cnd_t

     The 'cnd_t' uniquely identifies a condition variable object.

   The following functions are used for working with condition
variables:

 -- Function: int cnd_init (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'cnd_init' initializes a new condition variable, identified by
     COND.

     This function may return 'thrd_success', 'thrd_nomem', or
     'thrd_error'.

 -- Function: int cnd_signal (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'cnd_signal' unblocks one thread that is currently waiting on the
     condition variable pointed to by COND.  If a thread is successfully
     unblocked, this function returns 'thrd_success'.  If no threads are
     blocked, this function does nothing and returns 'thrd_success'.
     Otherwise, this function returns 'thrd_error'.

 -- Function: int cnd_broadcast (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'cnd_broadcast' unblocks all the threads that are currently waiting
     on the condition variable pointed to by COND.  This function
     returns 'thrd_success' on success.  If no threads are blocked, this
     function does nothing and returns 'thrd_success'.  Otherwise, this
     function returns 'thrd_error'.

 -- Function: int cnd_wait (cnd_t *COND, mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     'cnd_wait' atomically unlocks the mutex pointed to by MUTEX and
     blocks on the condition variable pointed to by COND until the
     thread is signaled by 'cnd_signal' or 'cnd_broadcast'.  The mutex
     is locked again before the function returns.

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: int cnd_timedwait (cnd_t *restrict COND, mtx_t *restrict
          MUTEX, const struct timespec *restrict TIME_POINT)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     'cnd_timedwait' atomically unlocks the mutex pointed to by MUTEX
     and blocks on the condition variable pointed to by COND until the
     thread is signaled by 'cnd_signal' or 'cnd_broadcast', or until the
     calendar time pointed to by TIME_POINT has been reached.  The mutex
     is locked again before the function returns.

     As for 'mtx_timedlock', since this function takes an absolute time,
     if a duration is required, the calendar time must be calculated
     manually.  *Note Time Basics::, and *note Calendar Time::.

     This function may return 'thrd_success', 'thrd_nomem', or
     'thrd_error'.

 -- Function: void cnd_destroy (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'cnd_destroy' destroys the condition variable pointed to by COND.
     If there are threads waiting on COND, the behavior is undefined.

==============================================================================
File: libc.info,  Node: |ISO_C_Thread_local_Storage|,  Prev: |ISO_C_Condition_Variables|,  Up: |ISO_C_Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *ISO_C_Thread_local_Storage*

35.1.6 Thread-local Storage
---------------------------

The GNU C Library implements functions to provide "thread-local
storage", a mechanism by which variables can be defined to have unique
per-thread storage, lifetimes that match the thread lifetime, and
destructors that cleanup the unique per-thread storage.

   Several data types and macros exist for working with thread-local
storage:

 -- Data Type: tss_t

     The 'tss_t' data type identifies a thread-specific storage object.
     Even if shared, every thread will have its own instance of the
     variable, with different values.

 -- Data Type: tss_dtor_t

     The 'tss_dtor_t' is a function pointer of type 'void (*) (void *)',
     to be used as a thread-specific storage destructor.  The function
     will be called when the current thread calls 'thrd_exit' (but never
     when calling 'tss_delete' or 'exit').

 -- Macro: thread_local

     'thread_local' is used to mark a variable with thread storage
     duration, which means it is created when the thread starts and
     cleaned up when the thread ends.

     _Note:_ For C++, C++11 or later is required to use the
     'thread_local' keyword.

 -- Macro: TSS_DTOR_ITERATIONS

     'TSS_DTOR_ITERATIONS' is an integer constant expression
     representing the maximum number of iterations over all thread-local
     destructors at the time of thread termination.  This value provides
     a bounded limit to the destruction of thread-local storage; e.g.,
     consider a destructor that creates more thread-local storage.

   The following functions are used to manage thread-local storage:

 -- Function: int tss_create (tss_t *TSS_KEY, tss_dtor_t DESTRUCTOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'tss_create' creates a new thread-specific storage key and stores
     it in the object pointed to by TSS_KEY.  Although the same key
     value may be used by different threads, the values bound to the key
     by 'tss_set' are maintained on a per-thread basis and persist for
     the life of the calling thread.

     If 'destructor' is not NULL, a destructor function will be set, and
     called when the thread finishes its execution by calling
     'thrd_exit'.

     This function returns 'thrd_success' if 'tss_key' is successfully
     set to a unique value for the thread; otherwise, 'thrd_error' is
     returned and the value of 'tss_key' is undefined.

 -- Function: int tss_set (tss_t TSS_KEY, void *VAL)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'tss_set' sets the value of the thread-specific storage identified
     by TSS_KEY for the current thread to VAL.  Different threads may
     set different values to the same key.

     This function returns either 'thrd_success' or 'thrd_error'.

 -- Function: void * tss_get (tss_t TSS_KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'tss_get' returns the value identified by TSS_KEY held in
     thread-specific storage for the current thread.  Different threads
     may get different values identified by the same key.  On failure,
     'tss_get' returns zero.

 -- Function: void tss_delete (tss_t TSS_KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     'tss_delete' destroys the thread-specific storage identified by
     TSS_KEY.

==============================================================================
File: libc.info,  Node: |POSIX_Threads|,  Prev: ISO C Threads,  Up: |Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *POSIX_Threads*

35.2 POSIX Threads
------------------

This section describes the GNU C Library POSIX Threads implementation.

MENU

* |Thread_specific_Data|::          Support for creating and
				  managing thread-specific data
* |Non_POSIX_Extensions|::          Additional functions to extend
				  POSIX Thread functionality

==============================================================================
File: libc.info,  Node: |Thread_specific_Data|,  Next: |Non_POSIX_Extensions|,  Up: POSIX Threads
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Thread_specific_Data*

35.2.1 Thread-specific Data
---------------------------

The GNU C Library implements functions to allow users to create and
manage data specific to a thread.  Such data may be destroyed at thread
exit, if a destructor is provided.  The following functions are defined:

 -- Function: int pthread_key_create (pthread_key_t *KEY, void
          (DESTRUCTOR)(void))

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Create a thread-specific data key for the calling thread,
     referenced by KEY.

     Objects declared with the C++11 'thread_local' keyword are
     destroyed before thread-specific data, so they should not be used
     in thread-specific data destructors or even as members of the
     thread-specific data, since the latter is passed as an argument to
     the destructor function.

 -- Function: int pthread_key_delete (pthread_key_t KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Destroy the thread-specific data KEY in the calling thread.  The
     destructor for the thread-specific data is not called during
     destruction, nor is it called during thread exit.

 -- Function: void *pthread_getspecific (pthread_key_t KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Return the thread-specific data associated with KEY in the calling
     thread.

 -- Function: int pthread_setspecific (pthread_key_t KEY, const void
          *VALUE)

     Preliminary: | MT-Safe | AS-Unsafe corrupt heap | AC-Unsafe corrupt
     mem | *Note POSIX Safety Concepts::.

     Associate the thread-specific VALUE with KEY in the calling thread.

==============================================================================
File: libc.info,  Node: |Non_POSIX_Extensions|,  Prev: |Thread_specific_Data|,  Up: |POSIX_Threads|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Non_POSIX_Extensions*

35.2.2 Non-POSIX Extensions
---------------------------

In addition to implementing the POSIX API for threads, the GNU C Library
provides additional functions and interfaces to provide functionality
not specified in the standard.

MENU

* |Default_Thread_Attributes|::             Setting default attributes for
					  threads in a process.

==============================================================================
File: libc.info,  Node: |Default_Thread_Attributes|,  Up: |Non_POSIX_Extensions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Default_Thread_Attributes*

35.2.2.1 Setting Process-wide defaults for thread attributes
------------------------------------------------------------

The GNU C Library provides non-standard API functions to set and get the
default attributes used in the creation of threads in a process.

 -- Function: int pthread_getattr_default_np (pthread_attr_t *ATTR)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     Get the default attribute values and set ATTR to match.  This
     function returns 0 on success and a non-zero error code on failure.

 -- Function: int pthread_setattr_default_np (pthread_attr_t *ATTR)

     Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe lock mem |
     *Note POSIX Safety Concepts::.

     Set the default attribute values to match the values in ATTR.  The
     function returns 0 on success and a non-zero error code on failure.
     The following error codes are defined for this function:

     'EINVAL'
          At least one of the values in ATTR does not qualify as valid
          for the attributes or the stack address is set in the
          attribute.
     'ENOMEM'
          The system does not have sufficient memory.

==============================================================================
File: libc.info,  Node: |Internal_Probes|,  Next: |Tunables|,  Prev: |Threads|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Internal_Probes*

36 Internal probes
==================

In order to aid in debugging and monitoring internal behavior, the GNU C
Library exposes nearly-zero-overhead SystemTap probes marked with the
'libc' provider.

   These probes are not part of the GNU C Library stable ABI, and they
are subject to change or removal across releases.  Our only promise with
regard to them is that, if we find a need to remove or modify the
arguments of a probe, the modified probe will have a different name, so
that program monitors relying on the old probe will not get unexpected
arguments.

MENU

* |Memory_Allocation_Probes|::  Probes in the memory allocation subsystem
* |Mathematical_Function_Probes|::  Probes in mathematical functions
* |Non_local_Goto_Probes|::  Probes in setjmp and longjmp

==============================================================================
File: libc.info,  Node: |Memory_Allocation_Probes|,  Next: |Mathematical_Function_Probes|,  Up: |Internal_Probes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Memory_Allocation_Probes*

36.1 Memory Allocation Probes
-----------------------------

These probes are designed to signal relatively unusual situations within
the virtual memory subsystem of the GNU C Library.

 -- Probe: memory_sbrk_more (void *$ARG1, size_t $ARG2)
     This probe is triggered after the main arena is extended by calling
     'sbrk'.  Argument $ARG1 is the additional size requested to 'sbrk',
     and $ARG2 is the pointer that marks the end of the 'sbrk' area,
     returned in response to the request.

 -- Probe: memory_sbrk_less (void *$ARG1, size_t $ARG2)
     This probe is triggered after the size of the main arena is
     decreased by calling 'sbrk'.  Argument $ARG1 is the size released
     by 'sbrk' (the positive value, rather than the negative value
     passed to 'sbrk'), and $ARG2 is the pointer that marks the end of
     the 'sbrk' area, returned in response to the request.

 -- Probe: memory_heap_new (void *$ARG1, size_t $ARG2)
     This probe is triggered after a new heap is 'mmap'ed.  Argument
     $ARG1 is a pointer to the base of the memory area, where the
     'heap_info' data structure is held, and $ARG2 is the size of the
     heap.

 -- Probe: memory_heap_free (void *$ARG1, size_t $ARG2)
     This probe is triggered _before_ (unlike the other sbrk and heap
     probes) a heap is completely removed via 'munmap'.  Argument $ARG1
     is a pointer to the heap, and $ARG2 is the size of the heap.

 -- Probe: memory_heap_more (void *$ARG1, size_t $ARG2)
     This probe is triggered after a trailing portion of an 'mmap'ed
     heap is extended.  Argument $ARG1 is a pointer to the heap, and
     $ARG2 is the new size of the heap.

 -- Probe: memory_heap_less (void *$ARG1, size_t $ARG2)
     This probe is triggered after a trailing portion of an 'mmap'ed
     heap is released.  Argument $ARG1 is a pointer to the heap, and
     $ARG2 is the new size of the heap.

 -- Probe: memory_malloc_retry (size_t $ARG1)
 -- Probe: memory_realloc_retry (size_t $ARG1, void *$ARG2)
 -- Probe: memory_memalign_retry (size_t $ARG1, size_t $ARG2)
 -- Probe: memory_calloc_retry (size_t $ARG1)
     These probes are triggered when the corresponding functions fail to
     obtain the requested amount of memory from the arena in use, before
     they call 'arena_get_retry' to select an alternate arena in which
     to retry the allocation.  Argument $ARG1 is the amount of memory
     requested by the user; in the 'calloc' case, that is the total size
     computed from both function arguments.  In the 'realloc' case,
     $ARG2 is the pointer to the memory area being resized.  In the
     'memalign' case, $ARG2 is the alignment to be used for the request,
     which may be stricter than the value passed to the 'memalign'
     function.  A 'memalign' probe is also used by functions
     'posix_memalign, valloc' and 'pvalloc'.

     Note that the argument order does _not_ match that of the
     corresponding two-argument functions, so that in all of these
     probes the user-requested allocation size is in $ARG1.

 -- Probe: memory_arena_retry (size_t $ARG1, void *$ARG2)
     This probe is triggered within 'arena_get_retry' (the function
     called to select the alternate arena in which to retry an
     allocation that failed on the first attempt), before the selection
     of an alternate arena.  This probe is redundant, but much easier to
     use when it's not important to determine which of the various
     memory allocation functions is failing to allocate on the first
     try.  Argument $ARG1 is the same as in the function-specific
     probes, except for extra room for padding introduced by functions
     that have to ensure stricter alignment.  Argument $ARG2 is the
     arena in which allocation failed.

 -- Probe: memory_arena_new (void *$ARG1, size_t $ARG2)
     This probe is triggered when 'malloc' allocates and initializes an
     additional arena (not the main arena), but before the arena is
     assigned to the running thread or inserted into the internal linked
     list of arenas.  The arena's 'malloc_state' internal data structure
     is located at $ARG1, within a newly-allocated heap big enough to
     hold at least $ARG2 bytes.

 -- Probe: memory_arena_reuse (void *$ARG1, void *$ARG2)
     This probe is triggered when 'malloc' has just selected an existing
     arena to reuse, and (temporarily) reserved it for exclusive use.
     Argument $ARG1 is a pointer to the newly-selected arena, and $ARG2
     is a pointer to the arena previously used by that thread.

     This occurs within 'reused_arena', right after the mutex mentioned
     in probe 'memory_arena_reuse_wait' is acquired; argument $ARG1 will
     point to the same arena.  In this configuration, this will usually
     only occur once per thread.  The exception is when a thread first
     selected the main arena, but a subsequent allocation from it fails:
     then, and only then, may we switch to another arena to retry that
     allocation, and for further allocations within that thread.

 -- Probe: memory_arena_reuse_wait (void *$ARG1, void *$ARG2, void
          *$ARG3)
     This probe is triggered when 'malloc' is about to wait for an arena
     to become available for reuse.  Argument $ARG1 holds a pointer to
     the mutex the thread is going to wait on, $ARG2 is a pointer to a
     newly-chosen arena to be reused, and $ARG3 is a pointer to the
     arena previously used by that thread.

     This occurs within 'reused_arena', when a thread first tries to
     allocate memory or needs a retry after a failure to allocate from
     the main arena, there isn't any free arena, the maximum number of
     arenas has been reached, and an existing arena was chosen for
     reuse, but its mutex could not be immediately acquired.  The mutex
     in $ARG1 is the mutex of the selected arena.

 -- Probe: memory_arena_reuse_free_list (void *$ARG1)
     This probe is triggered when 'malloc' has chosen an arena that is
     in the free list for use by a thread, within the 'get_free_list'
     function.  The argument $ARG1 holds a pointer to the selected
     arena.

 -- Probe: memory_mallopt (int $ARG1, int $ARG2)
     This probe is triggered when function 'mallopt' is called to change
     'malloc' internal configuration parameters, before any change to
     the parameters is made.  The arguments $ARG1 and $ARG2 are the ones
     passed to the 'mallopt' function.

 -- Probe: memory_mallopt_mxfast (int $ARG1, int $ARG2)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_MXFAST', and the requested
     value is in an acceptable range.  Argument $ARG1 is the requested
     value, and $ARG2 is the previous value of this 'malloc' parameter.

 -- Probe: memory_mallopt_trim_threshold (int $ARG1, int $ARG2, int
          $ARG3)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_TRIM_THRESHOLD'.  Argument
     $ARG1 is the requested value, $ARG2 is the previous value of this
     'malloc' parameter, and $ARG3 is nonzero if dynamic threshold
     adjustment was already disabled.

 -- Probe: memory_mallopt_top_pad (int $ARG1, int $ARG2, int $ARG3)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_TOP_PAD'.  Argument $ARG1 is
     the requested value, $ARG2 is the previous value of this 'malloc'
     parameter, and $ARG3 is nonzero if dynamic threshold adjustment was
     already disabled.

 -- Probe: memory_mallopt_mmap_threshold (int $ARG1, int $ARG2, int
          $ARG3)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_MMAP_THRESHOLD', and the
     requested value is in an acceptable range.  Argument $ARG1 is the
     requested value, $ARG2 is the previous value of this 'malloc'
     parameter, and $ARG3 is nonzero if dynamic threshold adjustment was
     already disabled.

 -- Probe: memory_mallopt_mmap_max (int $ARG1, int $ARG2, int $ARG3)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_MMAP_MAX'.  Argument $ARG1
     is the requested value, $ARG2 is the previous value of this
     'malloc' parameter, and $ARG3 is nonzero if dynamic threshold
     adjustment was already disabled.

 -- Probe: memory_mallopt_perturb (int $ARG1, int $ARG2)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_PERTURB'.  Argument $ARG1 is
     the requested value, and $ARG2 is the previous value of this
     'malloc' parameter.

 -- Probe: memory_mallopt_arena_test (int $ARG1, int $ARG2)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_ARENA_TEST', and the
     requested value is in an acceptable range.  Argument $ARG1 is the
     requested value, and $ARG2 is the previous value of this 'malloc'
     parameter.

 -- Probe: memory_mallopt_arena_max (int $ARG1, int $ARG2)
     This probe is triggered shortly after the 'memory_mallopt' probe,
     when the parameter to be changed is 'M_ARENA_MAX', and the
     requested value is in an acceptable range.  Argument $ARG1 is the
     requested value, and $ARG2 is the previous value of this 'malloc'
     parameter.

 -- Probe: memory_mallopt_free_dyn_thresholds (int $ARG1, int $ARG2)
     This probe is triggered when function 'free' decides to adjust the
     dynamic brk/mmap thresholds.  Argument $ARG1 and $ARG2 are the
     adjusted mmap and trim thresholds, respectively.

 -- Probe: memory_tunable_tcache_max_bytes (int $ARG1, int $ARG2)
     This probe is triggered when the 'glibc.malloc.tcache_max' tunable
     is set.  Argument $ARG1 is the requested value, and $ARG2 is the
     previous value of this tunable.

 -- Probe: memory_tunable_tcache_count (int $ARG1, int $ARG2)
     This probe is triggered when the 'glibc.malloc.tcache_count'
     tunable is set.  Argument $ARG1 is the requested value, and $ARG2
     is the previous value of this tunable.

 -- Probe: memory_tunable_tcache_unsorted_limit (int $ARG1, int $ARG2)
     This probe is triggered when the
     'glibc.malloc.tcache_unsorted_limit' tunable is set.  Argument
     $ARG1 is the requested value, and $ARG2 is the previous value of
     this tunable.

 -- Probe: memory_tcache_double_free (void *$ARG1, int $ARG2)
     This probe is triggered when 'free' determines that the memory
     being freed has probably already been freed, and resides in the
     per-thread cache.  Note that there is an extremely unlikely chance
     that this probe will trigger due to random payload data remaining
     in the allocated memory matching the key used to detect double
     frees.  This probe actually indicates that an expensive linear
     search of the tcache, looking for a double free, has happened.
     Argument $ARG1 is the memory location as passed to 'free', Argument
     $ARG2 is the tcache bin it resides in.

==============================================================================
File: libc.info,  Node: |Mathematical_Function_Probes|,  Next: |Non_local_Goto_Probes|,  Prev: |Memory_Allocation_Probes|,  Up: |Internal_Probes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Mathematical_Function_Probes*

36.2 Mathematical Function Probes
---------------------------------

Some mathematical functions fall back to multiple precision arithmetic
for some inputs to get last bit precision for their return values.  This
multiple precision fallback is much slower than the default algorithms
and may have a significant impact on application performance.  The
systemtap probe markers described in this section may help you determine
if your application calls mathematical functions with inputs that may
result in multiple-precision arithmetic.

   Unless explicitly mentioned otherwise, a precision of 1 implies 24
bits of precision in the mantissa of the multiple precision number.
Hence, a precision level of 32 implies 768 bits of precision in the
mantissa.

 -- Probe: slowatan2 (int $ARG1, double $ARG2, double $ARG3, double
          $ARG4)
     This probe is triggered when the 'atan2' function is called with an
     input that results in multiple precision computation.  Argument
     $ARG1 is the precision with which computation succeeded.  Arguments
     $ARG2 and $ARG3 are inputs to the 'atan2' function and $ARG4 is the
     computed result.

 -- Probe: slowatan2_inexact (int $ARG1, double $ARG2, double $ARG3,
          double $ARG4)
     This probe is triggered when the 'atan' function is called with an
     input that results in multiple precision computation and none of
     the multiple precision computations result in an accurate result.
     Argument $ARG1 is the maximum precision with which computations
     were performed.  Arguments $ARG2 and $ARG3 are inputs to the
     'atan2' function and $ARG4 is the computed result.

 -- Probe: slowatan (int $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the 'atan' function is called with an
     input that results in multiple precision computation.  Argument
     $ARG1 is the precision with which computation succeeded.  Argument
     $ARG2 is the input to the 'atan' function and $ARG3 is the computed
     result.

 -- Probe: slowatan_inexact (int $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the 'atan' function is called with an
     input that results in multiple precision computation and none of
     the multiple precision computations result in an accurate result.
     Argument $ARG1 is the maximum precision with which computations
     were performed.  Argument $ARG2 is the input to the 'atan' function
     and $ARG3 is the computed result.

 -- Probe: slowtan (double $ARG1, double $ARG2)
     This probe is triggered when the 'tan' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowasin (double $ARG1, double $ARG2)
     This probe is triggered when the 'asin' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowacos (double $ARG1, double $ARG2)
     This probe is triggered when the 'acos' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowsin (double $ARG1, double $ARG2)
     This probe is triggered when the 'sin' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowcos (double $ARG1, double $ARG2)
     This probe is triggered when the 'cos' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowsin_dx (double $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the 'sin' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function, $ARG2 is the
     error bound of $ARG1 and $ARG3 is the computed result.

 -- Probe: slowcos_dx (double $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the 'cos' function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function, $ARG2 is the
     error bound of $ARG1 and $ARG3 is the computed result.

==============================================================================
File: libc.info,  Node: |Non_local_Goto_Probes|,  Prev: |Mathematical_Function_Probes|,  Up: |Internal_Probes|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Non_local_Goto_Probes*

36.3 Non-local Goto Probes
--------------------------

These probes are used to signal calls to 'setjmp', 'sigsetjmp',
'longjmp' or 'siglongjmp'.

 -- Probe: setjmp (void *$ARG1, int $ARG2, void *$ARG3)
     This probe is triggered whenever 'setjmp' or 'sigsetjmp' is called.
     Argument $ARG1 is a pointer to the 'jmp_buf' passed as the first
     argument of 'setjmp' or 'sigsetjmp', $ARG2 is the second argument
     of 'sigsetjmp' or zero if this is a call to 'setjmp' and $ARG3 is a
     pointer to the return address that will be stored in the 'jmp_buf'.

 -- Probe: longjmp (void *$ARG1, int $ARG2, void *$ARG3)
     This probe is triggered whenever 'longjmp' or 'siglongjmp' is
     called.  Argument $ARG1 is a pointer to the 'jmp_buf' passed as the
     first argument of 'longjmp' or 'siglongjmp', $ARG2 is the return
     value passed as the second argument of 'longjmp' or 'siglongjmp'
     and $ARG3 is a pointer to the return address 'longjmp' or
     'siglongjmp' will return to.

     The 'longjmp' probe is triggered at a point where the registers
     have not yet been restored to the values in the 'jmp_buf' and
     unwinding will show a call stack including the caller of 'longjmp'
     or 'siglongjmp'.

 -- Probe: longjmp_target (void *$ARG1, int $ARG2, void *$ARG3)
     This probe is triggered under the same conditions and with the same
     arguments as the 'longjmp' probe.

     The 'longjmp_target' probe is triggered at a point where the
     registers have been restored to the values in the 'jmp_buf' and
     unwinding will show a call stack including the caller of 'setjmp'
     or 'sigsetjmp'.

==============================================================================
File: libc.info,  Node: |Tunables|,  Next: |Language_Features|,  Prev: |Internal_Probes|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Tunables*

37 Tunables
===========

"Tunables" are a feature in the GNU C Library that allows application
authors and distribution maintainers to alter the runtime library
behavior to match their workload.  These are implemented as a set of
switches that may be modified in different ways.  The current default
method to do this is via the 'GLIBC_TUNABLES' environment variable by
setting it to a string of colon-separated NAME=VALUE pairs.  For
example, the following example enables malloc checking and sets the
malloc trim threshold to 128 bytes:

     GLIBC_TUNABLES=glibc.malloc.trim_threshold=128:glibc.malloc.check=3
     export GLIBC_TUNABLES

   Tunables are not part of the GNU C Library stable ABI, and they are
subject to change or removal across releases.  Additionally, the method
to modify tunable values may change between releases and across
distributions.  It is possible to implement multiple 'frontends' for the
tunables allowing distributions to choose their preferred method at
build time.

   Finally, the set of tunables available may vary between distributions
as the tunables feature allows distributions to add their own tunables
under their own namespace.

MENU

* |Tunable_names|::  The structure of a tunable name
* |Memory_Allocation_Tunables|::  Tunables in the memory allocation subsystem
* |Elision_Tunables|::  Tunables in elision subsystem
* |Hardware_Capability_Tunables|::  Tunables that modify the hardware
				  capabilities seen by the GNU C Library

==============================================================================
File: libc.info,  Node: |Tunable_names|,  Next: |Memory_Allocation_Tunables|,  Up: |Tunables|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Tunable_names*

37.1 Tunable names
------------------

A tunable name is split into three components, a top namespace, a
tunable namespace and the tunable name.  The top namespace for tunables
implemented in the GNU C Library is 'glibc'.  Distributions that choose
to add custom tunables in their maintained versions of the GNU C Library
may choose to do so under their own top namespace.

   The tunable namespace is a logical grouping of tunables in a single
module.  This currently holds no special significance, although that may
change in the future.

   The tunable name is the actual name of the tunable.  It is possible
that different tunable namespaces may have tunables within them that
have the same name, likewise for top namespaces.  Hence, we only support
identification of tunables by their full name, i.e.  with the top
namespace, tunable namespace and tunable name, separated by periods.

==============================================================================
File: libc.info,  Node: |Memory_Allocation_Tunables|,  Next: |Elision_Tunables|,  Prev: |Tunable_names|,  Up: |Tunables|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Memory_Allocation_Tunables*

37.2 Memory Allocation Tunables
-------------------------------

 -- Tunable namespace: glibc.malloc
     Memory allocation behavior can be modified by setting any of the
     following tunables in the 'malloc' namespace:

 -- Tunable: glibc.malloc.check
     This tunable supersedes the 'MALLOC_CHECK_' environment variable
     and is identical in features.

     Setting this tunable to a non-zero value enables a special (less
     efficient) memory allocator for the malloc family of functions that
     is designed to be tolerant against simple errors such as double
     calls of free with the same argument, or overruns of a single byte
     (off-by-one bugs).  Not all such errors can be protected against,
     however, and memory leaks can result.  Any detected heap corruption
     results in immediate termination of the process.

     Like 'MALLOC_CHECK_', 'glibc.malloc.check' has a problem in that it
     diverges from normal program behavior by writing to 'stderr', which
     could by exploited in SUID and SGID binaries.  Therefore,
     'glibc.malloc.check' is disabled by default for SUID and SGID
     binaries.  This can be enabled again by the system administrator by
     adding a file '/etc/suid-debug'; the content of the file could be
     anything or even empty.

 -- Tunable: glibc.malloc.top_pad
     This tunable supersedes the 'MALLOC_TOP_PAD_' environment variable
     and is identical in features.

     This tunable determines the amount of extra memory in bytes to
     obtain from the system when any of the arenas need to be extended.
     It also specifies the number of bytes to retain when shrinking any
     of the arenas.  This provides the necessary hysteresis in heap size
     such that excessive amounts of system calls can be avoided.

     The default value of this tunable is '0'.

 -- Tunable: glibc.malloc.perturb
     This tunable supersedes the 'MALLOC_PERTURB_' environment variable
     and is identical in features.

     If set to a non-zero value, memory blocks are initialized with
     values depending on some low order bits of this tunable when they
     are allocated (except when allocated by calloc) and freed.  This
     can be used to debug the use of uninitialized or freed heap memory.
     Note that this option does not guarantee that the freed block will
     have any specific values.  It only guarantees that the content the
     block had before it was freed will be overwritten.

     The default value of this tunable is '0'.

 -- Tunable: glibc.malloc.mmap_threshold
     This tunable supersedes the 'MALLOC_MMAP_THRESHOLD_' environment
     variable and is identical in features.

     When this tunable is set, all chunks larger than this value in
     bytes are allocated outside the normal heap, using the 'mmap'
     system call.  This way it is guaranteed that the memory for these
     chunks can be returned to the system on 'free'.  Note that requests
     smaller than this threshold might still be allocated via 'mmap'.

     If this tunable is not set, the default value is set to '131072'
     bytes and the threshold is adjusted dynamically to suit the
     allocation patterns of the program.  If the tunable is set, the
     dynamic adjustment is disabled and the value is set as static.

 -- Tunable: glibc.malloc.trim_threshold
     This tunable supersedes the 'MALLOC_TRIM_THRESHOLD_' environment
     variable and is identical in features.

     The value of this tunable is the minimum size (in bytes) of the
     top-most, releasable chunk in an arena that will trigger a system
     call in order to return memory to the system from that arena.

     If this tunable is not set, the default value is set as 128 KB and
     the threshold is adjusted dynamically to suit the allocation
     patterns of the program.  If the tunable is set, the dynamic
     adjustment is disabled and the value is set as static.

 -- Tunable: glibc.malloc.mmap_max
     This tunable supersedes the 'MALLOC_MMAP_MAX_' environment variable
     and is identical in features.

     The value of this tunable is maximum number of chunks to allocate
     with 'mmap'.  Setting this to zero disables all use of 'mmap'.

     The default value of this tunable is '65536'.

 -- Tunable: glibc.malloc.arena_test
     This tunable supersedes the 'MALLOC_ARENA_TEST' environment
     variable and is identical in features.

     The 'glibc.malloc.arena_test' tunable specifies the number of
     arenas that can be created before the test on the limit to the
     number of arenas is conducted.  The value is ignored if
     'glibc.malloc.arena_max' is set.

     The default value of this tunable is 2 for 32-bit systems and 8 for
     64-bit systems.

 -- Tunable: glibc.malloc.arena_max
     This tunable supersedes the 'MALLOC_ARENA_MAX' environment variable
     and is identical in features.

     This tunable sets the number of arenas to use in a process
     regardless of the number of cores in the system.

     The default value of this tunable is '0', meaning that the limit on
     the number of arenas is determined by the number of CPU cores
     online.  For 32-bit systems the limit is twice the number of cores
     online and on 64-bit systems, it is 8 times the number of cores
     online.

 -- Tunable: glibc.malloc.tcache_max
     The maximum size of a request (in bytes) which may be met via the
     per-thread cache.  The default (and maximum) value is 1032 bytes on
     64-bit systems and 516 bytes on 32-bit systems.

 -- Tunable: glibc.malloc.tcache_count
     The maximum number of chunks of each size to cache.  The default is
     7.  There is no upper limit, other than available system memory.
     If set to zero, the per-thread cache is effectively disabled.

     The approximate maximum overhead of the per-thread cache is thus
     equal to the number of bins times the chunk count in each bin times
     the size of each chunk.  With defaults, the approximate maximum
     overhead of the per-thread cache is approximately 236 KB on 64-bit
     systems and 118 KB on 32-bit systems.

 -- Tunable: glibc.malloc.tcache_unsorted_limit
     When the user requests memory and the request cannot be met via the
     per-thread cache, the arenas are used to meet the request.  At this
     time, additional chunks will be moved from existing arena lists to
     pre-fill the corresponding cache.  While copies from the fastbins,
     smallbins, and regular bins are bounded and predictable due to the
     bin sizes, copies from the unsorted bin are not bounded, and incur
     additional time penalties as they need to be sorted as they're
     scanned.  To make scanning the unsorted list more predictable and
     bounded, the user may set this tunable to limit the number of
     chunks that are scanned from the unsorted list while searching for
     chunks to pre-fill the per-thread cache with.  The default, or when
     set to zero, is no limit.

==============================================================================
File: libc.info,  Node: |Elision_Tunables|,  Next: |Hardware_Capability_Tunables|,  Prev: |Memory_Allocation_Tunables|,  Up: |Tunables|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Elision_Tunables*

37.3 Elision Tunables
---------------------

 -- Tunable namespace: glibc.elision
     Contended locks are usually slow and can lead to performance and
     scalability issues in multithread code.  Lock elision will use
     memory transactions to under certain conditions, to elide locks and
     improve performance.  Elision behavior can be modified by setting
     the following tunables in the 'elision' namespace:

 -- Tunable: glibc.elision.enable
     The 'glibc.elision.enable' tunable enables lock elision if the
     feature is supported by the hardware.  If elision is not supported
     by the hardware this tunable has no effect.

     Elision tunables are supported for 64-bit Intel, IBM POWER, and z
     System architectures.

 -- Tunable: glibc.elision.skip_lock_busy
     The 'glibc.elision.skip_lock_busy' tunable sets how many times to
     use a non-transactional lock after a transactional failure has
     occurred because the lock is already acquired.  Expressed in number
     of lock acquisition attempts.

     The default value of this tunable is '3'.

 -- Tunable: glibc.elision.skip_lock_internal_abort
     The 'glibc.elision.skip_lock_internal_abort' tunable sets how many
     times the thread should avoid using elision if a transaction
     aborted for any reason other than a different thread's memory
     accesses.  Expressed in number of lock acquisition attempts.

     The default value of this tunable is '3'.

 -- Tunable: glibc.elision.skip_lock_after_retries
     The 'glibc.elision.skip_lock_after_retries' tunable sets how many
     times to try to elide a lock with transactions, that only failed
     due to a different thread's memory accesses, before falling back to
     regular lock.  Expressed in number of lock elision attempts.

     This tunable is supported only on IBM POWER, and z System
     architectures.

     The default value of this tunable is '3'.

 -- Tunable: glibc.elision.tries
     The 'glibc.elision.tries' sets how many times to retry elision if
     there is chance for the transaction to finish execution e.g., it
     wasn't aborted due to the lock being already acquired.  If elision
     is not supported by the hardware this tunable is set to '0' to
     avoid retries.

     The default value of this tunable is '3'.

 -- Tunable: glibc.elision.skip_trylock_internal_abort
     The 'glibc.elision.skip_trylock_internal_abort' tunable sets how
     many times the thread should avoid trying the lock if a transaction
     aborted due to reasons other than a different thread's memory
     accesses.  Expressed in number of try lock attempts.

     The default value of this tunable is '3'.

==============================================================================
File: libc.info,  Node: |Hardware_Capability_Tunables|,  Prev: |Elision_Tunables|,  Up: |Tunables|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Hardware_Capability_Tunables*

37.4 Hardware Capability Tunables
---------------------------------

 -- Tunable namespace: glibc.tune
     Behavior of the GNU C Library can be tuned to assume specific
     hardware capabilities by setting the following tunables in the
     'tune' namespace:

 -- Tunable: glibc.tune.hwcap_mask
     This tunable supersedes the 'LD_HWCAP_MASK' environment variable
     and is identical in features.

     The 'AT_HWCAP' key in the Auxiliary Vector specifies instruction
     set extensions available in the processor at runtime for some
     architectures.  The 'glibc.tune.hwcap_mask' tunable allows the user
     to mask out those capabilities at runtime, thus disabling use of
     those extensions.

 -- Tunable: glibc.tune.hwcaps
     The 'glibc.tune.hwcaps=-xxx,yyy,-zzz...' tunable allows the user to
     enable CPU/ARCH feature 'yyy', disable CPU/ARCH feature 'xxx' and
     'zzz' where the feature name is case-sensitive and has to match the
     ones in 'sysdeps/x86/cpu-features.h'.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.tune.cached_memopt
     The 'glibc.tune.cached_memopt=[0|1]' tunable allows the user to
     enable optimizations recommended for cacheable memory.  If set to
     '1', the GNU C Library assumes that the process memory image
     consists of cacheable (non-device) memory only.  The default, '0',
     indicates that the process may use device memory.

     This tunable is specific to powerpc, powerpc64 and powerpc64le.

 -- Tunable: glibc.tune.cpu
     The 'glibc.tune.cpu=xxx' tunable allows the user to tell the GNU C
     Library to assume that the CPU is 'xxx' where xxx may have one of
     these values: 'generic', 'falkor', 'thunderxt88', 'thunderx2t99',
     'thunderx2t99p1'.

     This tunable is specific to aarch64.

 -- Tunable: glibc.tune.x86_data_cache_size
     The 'glibc.tune.x86_data_cache_size' tunable allows the user to set
     data cache size in bytes for use in memory and string routines.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.tune.x86_shared_cache_size
     The 'glibc.tune.x86_shared_cache_size' tunable allows the user to
     set shared cache size in bytes for use in memory and string
     routines.

 -- Tunable: glibc.tune.x86_non_temporal_threshold
     The 'glibc.tune.x86_non_temporal_threshold' tunable allows the user
     to set threshold in bytes for non temporal store.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.tune.x86_ibt
     The 'glibc.tune.x86_ibt' tunable allows the user to control how
     indirect branch tracking (IBT) should be enabled.  Accepted values
     are 'on', 'off', and 'permissive'.  'on' always turns on IBT
     regardless of whether IBT is enabled in the executable and its
     dependent shared libraries.  'off' always turns off IBT regardless
     of whether IBT is enabled in the executable and its dependent
     shared libraries.  'permissive' is the same as the default which
     disables IBT on non-CET executables and shared libraries.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.tune.x86_shstk
     The 'glibc.tune.x86_shstk' tunable allows the user to control how
     the shadow stack (SHSTK) should be enabled.  Accepted values are
     'on', 'off', and 'permissive'.  'on' always turns on SHSTK
     regardless of whether SHSTK is enabled in the executable and its
     dependent shared libraries.  'off' always turns off SHSTK
     regardless of whether SHSTK is enabled in the executable and its
     dependent shared libraries.  'permissive' changes how dlopen works
     on non-CET shared libraries.  By default, when SHSTK is enabled,
     dlopening a non-CET shared library returns an error.  With
     'permissive', it turns off SHSTK instead.

     This tunable is specific to i386 and x86-64.

==============================================================================
File: libc.info,  Node: |Language_Features|,  Next: |Library_Summary|,  Prev: |Tunables|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Language_Features*

Appendix A C Language Facilities in the Library
===============================================

Some of the facilities implemented by the C library really should be
thought of as parts of the C language itself.  These facilities ought to
be documented in the C Language Manual, not in the library manual; but
since we don't have the language manual yet, and documentation for these
features has been written, we are publishing it here.

MENU

* |Consistency_Checking|::        Using 'assert' to abort if
				 something "impossible" happens.
* |Variadic_Functions|::          Defining functions with varying numbers
                                 of args.
* |Null_Pointer_Constant|::       The macro 'NULL'.
* |Important_Data_Types|::        Data types for object sizes.
* |Data_Type_Measurements|::      Parameters of data type representations.

==============================================================================
File: libc.info,  Node: |Consistency_Checking|,  Next: |Variadic_Functions|,  Up: |Language_Features|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Consistency_Checking*

A.1 Explicitly Checking Internal Consistency
--------------------------------------------

When you're writing a program, it's often a good idea to put in checks
at strategic places for "impossible" errors or violations of basic
assumptions.  These kinds of checks are helpful in debugging problems
with the interfaces between different parts of the program, for example.

   The 'assert' macro, defined in the header file 'assert.h', provides a
convenient way to abort the program while printing a message about where
in the program the error was detected.

   Once you think your program is debugged, you can disable the error
checks performed by the 'assert' macro by recompiling with the macro
'NDEBUG' defined.  This means you don't actually have to change the
program source code to disable these checks.

   But disabling these consistency checks is undesirable unless they
make the program significantly slower.  All else being equal, more error
checking is good no matter who is running the program.  A wise user
would rather have a program crash, visibly, than have it return nonsense
without indicating anything might be wrong.

 -- Macro: void assert (int EXPRESSION)

     Preliminary: | MT-Safe | AS-Unsafe heap corrupt | AC-Unsafe mem
     lock corrupt | *Note POSIX Safety Concepts::.

     Verify the programmer's belief that EXPRESSION is nonzero at this
     point in the program.

     If 'NDEBUG' is not defined, 'assert' tests the value of EXPRESSION.
     If it is false (zero), 'assert' aborts the program (*note Aborting
     a Program::) after printing a message of the form:

          FILE:LINENUM: FUNCTION: Assertion `EXPRESSION' failed.

     on the standard error stream 'stderr' (*note Standard Streams::).
     The filename and line number are taken from the C preprocessor
     macros '__FILE__' and '__LINE__' and specify where the call to
     'assert' was made.  When using the GNU C compiler, the name of the
     function which calls 'assert' is taken from the built-in variable
     '__PRETTY_FUNCTION__'; with older compilers, the function name and
     following colon are omitted.

     If the preprocessor macro 'NDEBUG' is defined before 'assert.h' is
     included, the 'assert' macro is defined to do absolutely nothing.

     Warning: Even the argument expression EXPRESSION is not evaluated
     if 'NDEBUG' is in effect.  So never use 'assert' with arguments
     that involve side effects.  For example, 'assert (++i > 0);' is a
     bad idea, because 'i' will not be incremented if 'NDEBUG' is
     defined.

   Sometimes the "impossible" condition you want to check for is an
error return from an operating system function.  Then it is useful to
display not only where the program crashes, but also what error was
returned.  The 'assert_perror' macro makes this easy.

 -- Macro: void assert_perror (int ERRNUM)

     Preliminary: | MT-Safe | AS-Unsafe heap corrupt | AC-Unsafe mem
     lock corrupt | *Note POSIX Safety Concepts::.

     Similar to 'assert', but verifies that ERRNUM is zero.

     If 'NDEBUG' is not defined, 'assert_perror' tests the value of
     ERRNUM.  If it is nonzero, 'assert_perror' aborts the program after
     printing a message of the form:

          FILE:LINENUM: FUNCTION: ERROR TEXT

     on the standard error stream.  The file name, line number, and
     function name are as for 'assert'.  The error text is the result of
     'strerror (ERRNUM)'.  *Note Error Messages::.

     Like 'assert', if 'NDEBUG' is defined before 'assert.h' is
     included, the 'assert_perror' macro does absolutely nothing.  It
     does not evaluate the argument, so ERRNUM should not have any side
     effects.  It is best for ERRNUM to be just a simple variable
     reference; often it will be 'errno'.

     This macro is a GNU extension.

   *Usage note:* The 'assert' facility is designed for detecting
_internal inconsistency_; it is not suitable for reporting invalid input
or improper usage by the _user_ of the program.

   The information in the diagnostic messages printed by the 'assert'
and 'assert_perror' macro is intended to help you, the programmer, track
down the cause of a bug, but is not really useful for telling a user of
your program why his or her input was invalid or why a command could not
be carried out.  What's more, your program should not abort when given
invalid input, as 'assert' would do--it should exit with nonzero status
(*note Exit Status::) after printing its error messages, or perhaps read
another command or move on to the next input file.

   *Note Error Messages::, for information on printing error messages
for problems that _do not_ represent bugs in the program.

==============================================================================
File: libc.info,  Node: |Variadic_Functions|,  Next: |Null_Pointer_Constant|,  Prev: |Consistency_Checking|,  Up: |Language_Features|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Variadic_Functions*

A.2 Variadic Functions
----------------------

ISO C defines a syntax for declaring a function to take a variable
number or type of arguments.  (Such functions are referred to as
"varargs functions" or "variadic functions".)  However, the language
itself provides no mechanism for such functions to access their
non-required arguments; instead, you use the variable arguments macros
defined in 'stdarg.h'.

   This section describes how to declare variadic functions, how to
write them, and how to call them properly.

   *Compatibility Note:* Many older C dialects provide a similar, but
incompatible, mechanism for defining functions with variable numbers of
arguments, using 'varargs.h'.

MENU

* |Why_Variadic|::                Reasons for making functions take
                                 variable arguments.
* |How_Variadic|::                How to define and call variadic functions.
* |Variadic_Example|::            A complete example.

==============================================================================
File: libc.info,  Node: |Why_Variadic|,  Next: |How_Variadic|,  Up: |Variadic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Why_Variadic*

A.2.1 Why Variadic Functions are Used
-------------------------------------

Ordinary C functions take a fixed number of arguments.  When you define
a function, you specify the data type for each argument.  Every call to
the function should supply the expected number of arguments, with types
that can be converted to the specified ones.  Thus, if the function
'foo' is declared with 'int foo (int, char *);' then you must call it
with two arguments, a number (any kind will do) and a string pointer.

   But some functions perform operations that can meaningfully accept an
unlimited number of arguments.

   In some cases a function can handle any number of values by operating
on all of them as a block.  For example, consider a function that
allocates a one-dimensional array with 'malloc' to hold a specified set
of values.  This operation makes sense for any number of values, as long
as the length of the array corresponds to that number.  Without
facilities for variable arguments, you would have to define a separate
function for each possible array size.

   The library function 'printf' (*note Formatted Output::) is an
example of another class of function where variable arguments are
useful.  This function prints its arguments (which can vary in type as
well as number) under the control of a format template string.

   These are good reasons to define a "variadic" function which can
handle as many arguments as the caller chooses to pass.

   Some functions such as 'open' take a fixed set of arguments, but
occasionally ignore the last few.  Strict adherence to ISO C requires
these functions to be defined as variadic; in practice, however, the GNU
C compiler and most other C compilers let you define such a function to
take a fixed set of arguments--the most it can ever use--and then only
_declare_ the function as variadic (or not declare its arguments at
all!).

==============================================================================
File: libc.info,  Node: |How_Variadic|,  Next: |Variadic_Example|,  Prev: |Why_Variadic|,  Up: |Variadic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *How_Variadic*

A.2.2 How Variadic Functions are Defined and Used
-------------------------------------------------

Defining and using a variadic function involves three steps:

   * _Define_ the function as variadic, using an ellipsis ('...') in the
     argument list, and using special macros to access the variable
     arguments.  *Note Receiving Arguments::.

   * _Declare_ the function as variadic, using a prototype with an
     ellipsis ('...'), in all the files which call it.  *Note Variadic
     Prototypes::.

   * _Call_ the function by writing the fixed arguments followed by the
     additional variable arguments.  *Note Calling Variadics::.

MENU

* |Variadic_Prototypes|::  How to make a prototype for a function
			  with variable arguments.
* |Receiving_Arguments|::  Steps you must follow to access the
			  optional argument values.
* |How_Many_Arguments|::   How to decide whether there are more arguments.
* |Calling_Variadics|::    Things you need to know about calling
			  variable arguments functions.
* |Argument_Macros|::      Detailed specification of the macros
        		  for accessing variable arguments.

==============================================================================
File: libc.info,  Node: |Variadic_Prototypes|,  Next: |Receiving_Arguments|,  Up: |How_Variadic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Variadic_Prototypes*

A.2.2.1 Syntax for Variable Arguments
-------------------------------------

A function that accepts a variable number of arguments must be declared
with a prototype that says so.  You write the fixed arguments as usual,
and then tack on '...' to indicate the possibility of additional
arguments.  The syntax of ISO C requires at least one fixed argument
before the '...'.  For example,

     int
     func (const char *a, int b, ...)
     {
       ...
     }

defines a function 'func' which returns an 'int' and takes two required
arguments, a 'const char *' and an 'int'.  These are followed by any
number of anonymous arguments.

   *Portability note:* For some C compilers, the last required argument
must not be declared 'register' in the function definition.
Furthermore, this argument's type must be "self-promoting": that is, the
default promotions must not change its type.  This rules out array and
function types, as well as 'float', 'char' (whether signed or not) and
'short int' (whether signed or not).  This is actually an ISO C
requirement.

==============================================================================
File: libc.info,  Node: |Receiving_Arguments|,  Next: |How_Many_Arguments|,  Prev: |Variadic_Prototypes|,  Up: |How_Variadic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Receiving_Arguments*

A.2.2.2 Receiving the Argument Values
-------------------------------------

Ordinary fixed arguments have individual names, and you can use these
names to access their values.  But optional arguments have no
names--nothing but '...'.  How can you access them?

   The only way to access them is sequentially, in the order they were
written, and you must use special macros from 'stdarg.h' in the
following three step process:

  1. You initialize an argument pointer variable of type 'va_list' using
     'va_start'.  The argument pointer when initialized points to the
     first optional argument.

  2. You access the optional arguments by successive calls to 'va_arg'.
     The first call to 'va_arg' gives you the first optional argument,
     the next call gives you the second, and so on.

     You can stop at any time if you wish to ignore any remaining
     optional arguments.  It is perfectly all right for a function to
     access fewer arguments than were supplied in the call, but you will
     get garbage values if you try to access too many arguments.

  3. You indicate that you are finished with the argument pointer
     variable by calling 'va_end'.

     (In practice, with most C compilers, calling 'va_end' does nothing.
     This is always true in the GNU C compiler.  But you might as well
     call 'va_end' just in case your program is someday compiled with a
     peculiar compiler.)

   *Note Argument Macros::, for the full definitions of 'va_start',
'va_arg' and 'va_end'.

   Steps 1 and 3 must be performed in the function that accepts the
optional arguments.  However, you can pass the 'va_list' variable as an
argument to another function and perform all or part of step 2 there.

   You can perform the entire sequence of three steps multiple times
within a single function invocation.  If you want to ignore the optional
arguments, you can do these steps zero times.

   You can have more than one argument pointer variable if you like.
You can initialize each variable with 'va_start' when you wish, and then
you can fetch arguments with each argument pointer as you wish.  Each
argument pointer variable will sequence through the same set of argument
values, but at its own pace.

   *Portability note:* With some compilers, once you pass an argument
pointer value to a subroutine, you must not keep using the same argument
pointer value after that subroutine returns.  For full portability, you
should just pass it to 'va_end'.  This is actually an ISO C requirement,
but most ANSI C compilers work happily regardless.

==============================================================================
File: libc.info,  Node: |How_Many_Arguments|,  Next: |Calling_Variadics|,  Prev: |Receiving_Arguments|,  Up: |How_Variadic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *How_Many_Arguments*

A.2.2.3 How Many Arguments Were Supplied
----------------------------------------

There is no general way for a function to determine the number and type
of the optional arguments it was called with.  So whoever designs the
function typically designs a convention for the caller to specify the
number and type of arguments.  It is up to you to define an appropriate
calling convention for each variadic function, and write all calls
accordingly.

   One kind of calling convention is to pass the number of optional
arguments as one of the fixed arguments.  This convention works provided
all of the optional arguments are of the same type.

   A similar alternative is to have one of the required arguments be a
bit mask, with a bit for each possible purpose for which an optional
argument might be supplied.  You would test the bits in a predefined
sequence; if the bit is set, fetch the value of the next argument,
otherwise use a default value.

   A required argument can be used as a pattern to specify both the
number and types of the optional arguments.  The format string argument
to 'printf' is one example of this (*note Formatted Output Functions::).

   Another possibility is to pass an "end marker" value as the last
optional argument.  For example, for a function that manipulates an
arbitrary number of pointer arguments, a null pointer might indicate the
end of the argument list.  (This assumes that a null pointer isn't
otherwise meaningful to the function.)  The 'execl' function works in
just this way; see *note Executing a File::.

==============================================================================
File: libc.info,  Node: |Calling_Variadics|,  Next: |Argument_Macros|,  Prev: |How_Many_Arguments|,  Up: |How_Variadic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Calling_Variadics*

A.2.2.4 Calling Variadic Functions
----------------------------------

You don't have to do anything special to call a variadic function.  Just
put the arguments (required arguments, followed by optional ones) inside
parentheses, separated by commas, as usual.  But you must declare the
function with a prototype and know how the argument values are
converted.

   In principle, functions that are _defined_ to be variadic must also
be _declared_ to be variadic using a function prototype whenever you
call them.  (*Note Variadic Prototypes::, for how.)  This is because
some C compilers use a different calling convention to pass the same set
of argument values to a function depending on whether that function
takes variable arguments or fixed arguments.

   In practice, the GNU C compiler always passes a given set of argument
types in the same way regardless of whether they are optional or
required.  So, as long as the argument types are self-promoting, you can
safely omit declaring them.  Usually it is a good idea to declare the
argument types for variadic functions, and indeed for all functions.
But there are a few functions which it is extremely convenient not to
have to declare as variadic--for example, 'open' and 'printf'.

   Since the prototype doesn't specify types for optional arguments, in
a call to a variadic function the "default argument promotions" are
performed on the optional argument values.  This means the objects of
type 'char' or 'short int' (whether signed or not) are promoted to
either 'int' or 'unsigned int', as appropriate; and that objects of type
'float' are promoted to type 'double'.  So, if the caller passes a
'char' as an optional argument, it is promoted to an 'int', and the
function can access it with 'va_arg (AP, int)'.

   Conversion of the required arguments is controlled by the function
prototype in the usual way: the argument expression is converted to the
declared argument type as if it were being assigned to a variable of
that type.

==============================================================================
File: libc.info,  Node: |Argument_Macros|,  Prev: |Calling_Variadics|,  Up: |How_Variadic|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Argument_Macros*

A.2.2.5 Argument Access Macros
------------------------------

Here are descriptions of the macros used to retrieve variable arguments.
These macros are defined in the header file 'stdarg.h'.

 -- Data Type: va_list

     The type 'va_list' is used for argument pointer variables.

 -- Macro: void va_start (va_list AP, LAST-REQUIRED)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro initializes the argument pointer variable AP to point to
     the first of the optional arguments of the current function;
     LAST-REQUIRED must be the last required argument to the function.

 -- Macro: TYPE va_arg (va_list AP, TYPE)

     Preliminary: | MT-Safe race:ap | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The 'va_arg' macro returns the value of the next optional argument,
     and modifies the value of AP to point to the subsequent argument.
     Thus, successive uses of 'va_arg' return successive optional
     arguments.

     The type of the value returned by 'va_arg' is TYPE as specified in
     the call.  TYPE must be a self-promoting type (not 'char' or 'short
     int' or 'float') that matches the type of the actual argument.

 -- Macro: void va_end (va_list AP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This ends the use of AP.  After a 'va_end' call, further 'va_arg'
     calls with the same AP may not work.  You should invoke 'va_end'
     before returning from the function in which 'va_start' was invoked
     with the same AP argument.

     In the GNU C Library, 'va_end' does nothing, and you need not ever
     use it except for reasons of portability.

   Sometimes it is necessary to parse the list of parameters more than
once or one wants to remember a certain position in the parameter list.
To do this, one will have to make a copy of the current value of the
argument.  But 'va_list' is an opaque type and one cannot necessarily
assign the value of one variable of type 'va_list' to another variable
of the same type.

 -- Macro: void va_copy (va_list DEST, va_list SRC)
 -- Macro: void __va_copy (va_list DEST, va_list SRC)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The 'va_copy' macro allows copying of objects of type 'va_list'
     even if this is not an integral type.  The argument pointer in DEST
     is initialized to point to the same argument as the pointer in SRC.

     'va_copy' was added in ISO C99.  When building for strict
     conformance to ISO C90 ('gcc -std=c90'), it is not available.  GCC
     provides '__va_copy', as an extension, in any standards mode;
     before GCC 3.0, it was the only macro for this functionality.

     These macros are no longer provided by the GNU C Library, but
     rather by the compiler.

   If you want to use 'va_copy' and be portable to pre-C99 systems, you
should always be prepared for the possibility that this macro will not
be available.  On architectures where a simple assignment is invalid,
hopefully 'va_copy' _will_ be available, so one should always write
something like this if concerned about pre-C99 portability:

     {
       va_list ap, save;
       ...
     #ifdef va_copy
       va_copy (save, ap);
     #else
       save = ap;
     #endif
       ...
     }

==============================================================================
File: libc.info,  Node: |Variadic_Example|,  Prev: How Variadic,  Up: |Variadic_Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Variadic_Example*

A.2.3 Example of a Variadic Function
------------------------------------

Here is a complete sample function that accepts a variable number of
arguments.  The first argument to the function is the count of remaining
arguments, which are added up and the result returned.  While trivial,
this function is sufficient to illustrate how to use the variable
arguments facility.


     #include <stdarg.h>
     #include <stdio.h>

     int
     add_em_up (int count,...)
     {
       va_list ap;
       int i, sum;

       va_start (ap, count);         /* Initialize the argument list. */

       sum = 0;
       for (i = 0; i < count; i++)
         sum += va_arg (ap, int);    /* Get the next argument value. */

       va_end (ap);                  /* Clean up. */
       return sum;
     }

     int
     main (void)
     {
       /* This call prints 16. */
       printf ("%d\n", add_em_up (3, 5, 5, 6));

       /* This call prints 55. */
       printf ("%d\n", add_em_up (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

       return 0;
     }

==============================================================================
File: libc.info,  Node: |Null_Pointer_Constant|,  Next: |Important_Data_Types|,  Prev: |Variadic_Functions|,  Up: |Language_Features|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Null_Pointer_Constant*

A.3 Null Pointer Constant
-------------------------

The null pointer constant is guaranteed not to point to any real object.
You can assign it to any pointer variable since it has type 'void *'.
The preferred way to write a null pointer constant is with 'NULL'.

 -- Macro: void * NULL

     This is a null pointer constant.

   You can also use '0' or '(void *)0' as a null pointer constant, but
using 'NULL' is cleaner because it makes the purpose of the constant
more evident.

   If you use the null pointer constant as a function argument, then for
complete portability you should make sure that the function has a
prototype declaration.  Otherwise, if the target machine has two
different pointer representations, the compiler won't know which
representation to use for that argument.  You can avoid the problem by
explicitly casting the constant to the proper pointer type, but we
recommend instead adding a prototype for the function you are calling.

==============================================================================
File: libc.info,  Node: |Important_Data_Types|,  Next: |Data_Type_Measurements|,  Prev: |Null_Pointer_Constant|,  Up: |Language_Features|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Important_Data_Types*

A.4 Important Data Types
------------------------

The result of subtracting two pointers in C is always an integer, but
the precise data type varies from C compiler to C compiler.  Likewise,
the data type of the result of 'sizeof' also varies between compilers.
ISO C defines standard aliases for these two types, so you can refer to
them in a portable fashion.  They are defined in the header file
'stddef.h'.

 -- Data Type: ptrdiff_t

     This is the signed integer type of the result of subtracting two
     pointers.  For example, with the declaration 'char *p1, *p2;', the
     expression 'p2 - p1' is of type 'ptrdiff_t'.  This will probably be
     one of the standard signed integer types ('short int', 'int' or
     'long int'), but might be a nonstandard type that exists only for
     this purpose.

 -- Data Type: size_t

     This is an unsigned integer type used to represent the sizes of
     objects.  The result of the 'sizeof' operator is of this type, and
     functions such as 'malloc' (*note Unconstrained Allocation::) and
     'memcpy' (*note Copying Strings and Arrays::) accept arguments of
     this type to specify object sizes.  On systems using the GNU C
     Library, this will be 'unsigned int' or 'unsigned long int'.

     *Usage Note:* 'size_t' is the preferred way to declare any
     arguments or variables that hold the size of an object.

   *Compatibility Note:* Implementations of C before the advent of ISO C
generally used 'unsigned int' for representing object sizes and 'int'
for pointer subtraction results.  They did not necessarily define either
'size_t' or 'ptrdiff_t'.  Unix systems did define 'size_t', in
'sys/types.h', but the definition was usually a signed type.

==============================================================================
File: libc.info,  Node: |Data_Type_Measurements|,  Prev: |Important_Data_Types|,  Up: |Language_Features|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Data_Type_Measurements*

A.5 Data Type Measurements
--------------------------

Most of the time, if you choose the proper C data type for each object
in your program, you need not be concerned with just how it is
represented or how many bits it uses.  When you do need such
information, the C language itself does not provide a way to get it.
The header files 'limits.h' and 'float.h' contain macros which give you
this information in full detail.

MENU

* |Width_of_Type|::           How many bits does an integer type hold?
* |Range_of_Type|::           What are the largest and smallest values
			     that an integer type can hold?
* |Floating_Type_Macros|::    Parameters that measure the floating point types.
* |Structure_Measurement|::   Getting measurements on structure types.

==============================================================================
File: libc.info,  Node: |Width_of_Type|,  Next: |Range_of_Type|,  Up: |Data_Type_Measurements|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Width_of_Type*

A.5.1 Width of an Integer Type
------------------------------

TS 18661-1:2014 defines macros for the width of integer types (the
number of value and sign bits).  One benefit of these macros is they can
be used in '#if' preprocessor directives, whereas 'sizeof' cannot.  The
following macros are defined in 'limits.h'.

'CHAR_WIDTH'
'SCHAR_WIDTH'
'UCHAR_WIDTH'
'SHRT_WIDTH'
'USHRT_WIDTH'
'INT_WIDTH'
'UINT_WIDTH'
'LONG_WIDTH'
'ULONG_WIDTH'
'LLONG_WIDTH'
'ULLONG_WIDTH'

     These are the widths of the types 'char', 'signed char', 'unsigned
     char', 'short int', 'unsigned short int', 'int', 'unsigned int',
     'long int', 'unsigned long int', 'long long int' and 'unsigned long
     long int', respectively.

   Further such macros are defined in 'stdint.h'.  Apart from those for
types specified by width (*note Integers::), the following are defined:

'INTPTR_WIDTH'
'UINTPTR_WIDTH'
'PTRDIFF_WIDTH'
'SIG_ATOMIC_WIDTH'
'SIZE_WIDTH'
'WCHAR_WIDTH'
'WINT_WIDTH'

     These are the widths of the types 'intptr_t', 'uintptr_t',
     'ptrdiff_t', 'sig_atomic_t', 'size_t', 'wchar_t' and 'wint_t',
     respectively.

   A common reason that a program needs to know how many bits are in an
integer type is for using an array of 'unsigned long int' as a bit
vector.  You can access the bit at index N with:

     vector[N / ULONG_WIDTH] & (1UL << (N % ULONG_WIDTH))

   Before 'ULONG_WIDTH' was a part of the C language, 'CHAR_BIT' was
used to compute the number of bits in an integer data type.

 -- Macro: int CHAR_BIT

     This is the number of bits in a 'char'.  POSIX.1-2001 requires this
     to be 8.

   The number of bits in any data type TYPE can be computed like this:

     sizeof (TYPE) * CHAR_BIT

   That expression includes padding bits as well as value and sign bits.
On all systems supported by the GNU C Library, standard integer types
other than '_Bool' do not have any padding bits.

   *Portability Note:* One cannot actually easily compute the number of
usable bits in a portable manner.

==============================================================================
File: libc.info,  Node: |Range_of_Type|,  Next: |Floating_Type_Macros|,  Prev: |Width_of_Type|,  Up: |Data_Type_Measurements|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Range_of_Type*

A.5.2 Range of an Integer Type
------------------------------

Suppose you need to store an integer value which can range from zero to
one million.  Which is the smallest type you can use?  There is no
general rule; it depends on the C compiler and target machine.  You can
use the 'MIN' and 'MAX' macros in 'limits.h' to determine which type
will work.

   Each signed integer type has a pair of macros which give the smallest
and largest values that it can hold.  Each unsigned integer type has one
such macro, for the maximum value; the minimum value is, of course,
zero.

   The values of these macros are all integer constant expressions.  The
'MAX' and 'MIN' macros for 'char' and 'short int' types have values of
type 'int'.  The 'MAX' and 'MIN' macros for the other types have values
of the same type described by the macro--thus, 'ULONG_MAX' has type
'unsigned long int'.

'SCHAR_MIN'

     This is the minimum value that can be represented by a
     'signed char'.

'SCHAR_MAX'
'UCHAR_MAX'

     These are the maximum values that can be represented by a
     'signed char' and 'unsigned char', respectively.

'CHAR_MIN'

     This is the minimum value that can be represented by a 'char'.
     It's equal to 'SCHAR_MIN' if 'char' is signed, or zero otherwise.

'CHAR_MAX'

     This is the maximum value that can be represented by a 'char'.
     It's equal to 'SCHAR_MAX' if 'char' is signed, or 'UCHAR_MAX'
     otherwise.

'SHRT_MIN'

     This is the minimum value that can be represented by a
     'signed short int'.  On most machines that the GNU C Library runs
     on, 'short' integers are 16-bit quantities.

'SHRT_MAX'
'USHRT_MAX'

     These are the maximum values that can be represented by a
     'signed short int' and 'unsigned short int', respectively.

'INT_MIN'

     This is the minimum value that can be represented by a
     'signed int'.  On most machines that the GNU C Library runs on, an
     'int' is a 32-bit quantity.

'INT_MAX'
'UINT_MAX'

     These are the maximum values that can be represented by,
     respectively, the type 'signed int' and the type 'unsigned int'.

'LONG_MIN'

     This is the minimum value that can be represented by a
     'signed long int'.  On most machines that the GNU C Library runs
     on, 'long' integers are 32-bit quantities, the same size as 'int'.

'LONG_MAX'
'ULONG_MAX'

     These are the maximum values that can be represented by a
     'signed long int' and 'unsigned long int', respectively.

'LLONG_MIN'

     This is the minimum value that can be represented by a
     'signed long long int'.  On most machines that the GNU C Library
     runs on, 'long long' integers are 64-bit quantities.

'LLONG_MAX'
'ULLONG_MAX'

     These are the maximum values that can be represented by a 'signed
     long long int' and 'unsigned long long int', respectively.

'LONG_LONG_MIN'
'LONG_LONG_MAX'
'ULONG_LONG_MAX'

     These are obsolete names for 'LLONG_MIN', 'LLONG_MAX', and
     'ULLONG_MAX'.  They are only available if '_GNU_SOURCE' is defined
     (*note Feature Test Macros::).  In GCC versions prior to 3.0, these
     were the only names available.

'WCHAR_MAX'

     This is the maximum value that can be represented by a 'wchar_t'.
     *Note Extended Char Intro::.

   The header file 'limits.h' also defines some additional constants
that parameterize various operating system and file system limits.
These constants are described in *note System Configuration::.

==============================================================================
File: libc.info,  Node: |Floating_Type_Macros|,  Next: |Structure_Measurement|,  Prev: |Range_of_Type|,  Up: |Data_Type_Measurements|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Floating_Type_Macros*

A.5.3 Floating Type Macros
--------------------------

The specific representation of floating point numbers varies from
machine to machine.  Because floating point numbers are represented
internally as approximate quantities, algorithms for manipulating
floating point data often need to take account of the precise details of
the machine's floating point representation.

   Some of the functions in the C library itself need this information;
for example, the algorithms for printing and reading floating point
numbers (*note I/O on Streams::) and for calculating trigonometric and
irrational functions (*note Mathematics::) use it to avoid round-off
error and loss of accuracy.  User programs that implement numerical
analysis techniques also often need this information in order to
minimize or compute error bounds.

   The header file 'float.h' describes the format used by your machine.

MENU

* |Floating_Point_Concepts|::     Definitions of terminology.
* |Floating_Point_Parameters|::   Details of specific macros.
* |IEEE_Floating_Point|::         The measurements for one common
                                 representation.

==============================================================================
File: libc.info,  Node: |Floating_Point_Concepts|,  Next: |Floating_Point_Parameters|,  Up: Floating Type Macros
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Floating_Point_Concepts*

A.5.3.1 Floating Point Representation Concepts
----------------------------------------------

This section introduces the terminology for describing floating point
representations.

   You are probably already familiar with most of these concepts in
terms of scientific or exponential notation for floating point numbers.
For example, the number '123456.0' could be expressed in exponential
notation as '1.23456e+05', a shorthand notation indicating that the
mantissa '1.23456' is multiplied by the base '10' raised to power '5'.

   More formally, the internal representation of a floating point number
can be characterized in terms of the following parameters:

   * The "sign" is either '-1' or '1'.
   vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
