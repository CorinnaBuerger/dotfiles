          =>abc
          m4_unquote(m4_join([],[a],[b]))c
          =>3
          m4_define([a],[A])m4_define([b],[B])m4_define([c],[C])dnl
          m4_define([AB],[4])m4_define([BC],[5])m4_define([ABC],[6])dnl
          m4_do([a],[b])c
          =>ABC
          m4_unquote(m4_join([],[a],[b]))c
          =>3

 -- Macro: m4_dquote (ARG, ...)
     Return the arguments as a quoted list of quoted arguments.
     Conveniently, if there is just one ARG, this effectively adds a
     level of quoting.

 -- Macro: m4_dquote_elt (ARG, ...)
     Return the arguments as a series of double-quoted arguments.
     Whereas `m4_dquote' returns a single argument, `m4_dquote_elt'
     returns as many arguments as it was passed.

 -- Macro: m4_echo (ARG, ...)
     Return the arguments, with the same level of quoting.  Other than
     discarding whitespace after unquoted commas, this macro is a no-op.

 -- Macro: m4_expand (ARG)
     Return the expansion of ARG as a quoted string.  Whereas
     `m4_quote' is designed to collect expanded text into a single
     argument, `m4_expand' is designed to perform one level of expansion
     on quoted text.  One distinction is in the treatment of whitespace
     following a comma in the original ARG.  Any time multiple
     arguments are collected into one with `m4_quote', the M4 argument
     collection rules discard the whitespace.  However, with
     `m4_expand', whitespace is preserved, even after the expansion of
     macros contained in ARG.  Additionally, `m4_expand' is able to
     expand text that would involve an unterminated comment, whereas
     expanding that same text as the argument to `m4_quote' runs into
     difficulty in finding the end of the argument.  Since manipulating
     diversions during argument collection is inherently unsafe,
     `m4_expand' issues an error if ARG attempts to change the current
     diversion (*note Diversion support::).

          m4_define([active], [ACT, IVE])dnl
          m4_define([active2], [[ACT, IVE]])dnl
          m4_quote(active, active)
          =>ACT,IVE,ACT,IVE
          m4_expand([active, active])
          =>ACT, IVE, ACT, IVE
          m4_quote(active2, active2)
          =>ACT, IVE,ACT, IVE
          m4_expand([active2, active2])
          =>ACT, IVE, ACT, IVE
          m4_expand([# m4_echo])
          =># m4_echo
          m4_quote(# m4_echo)
          )
          =># m4_echo)
          =>

     Note that `m4_expand' cannot handle an ARG that expands to literal
     unbalanced quotes, but that quadrigraphs can be used when
     unbalanced output is necessary.  Likewise, unbalanced parentheses
     should be supplied with double quoting or a quadrigraph.

          m4_define([pattern], [[!@<:@]])dnl
          m4_define([bar], [BAR])dnl
          m4_expand([case $foo in
            m4_defn([pattern])@:}@ bar ;;
            *[)] blah ;;
          esac])
          =>case $foo in
          =>  [![]) BAR ;;
          =>  *) blah ;;
          =>esac

 -- Macro: m4_ignore (...)
     This macro was introduced in Autoconf 2.62.  Expands to nothing,
     ignoring all of its arguments.  By itself, this isn't very useful.
     However, it can be used to conditionally ignore an arbitrary
     number of arguments, by deciding which macro name to apply to a
     list of arguments.
          dnl foo outputs a message only if [debug] is defined.
          m4_define([foo],
          [m4_ifdef([debug],[AC_MSG_NOTICE],[m4_ignore])([debug message])])

     Note that for earlier versions of Autoconf, the macro `__gnu__' can
     serve the same purpose, although it is less readable.

 -- Macro: m4_make_list (ARG, ...)
     This macro exists to aid debugging of M4sugar algorithms.  Its net
     effect is similar to `m4_dquote'--it produces a quoted list of
     quoted arguments, for each ARG.  The difference is that this
     version uses a comma-newline separator instead of just comma, to
     improve readability of the list; with the result that it is less
     efficient than `m4_dquote'.
          m4_define([zero],[0])m4_define([one],[1])m4_define([two],[2])dnl
          m4_dquote(zero, [one], [[two]])
          =>[0],[one],[[two]]
          m4_make_list(zero, [one], [[two]])
          =>[0],
          =>[one],
          =>[[two]]
          m4_foreach([number], m4_dquote(zero, [one], [[two]]), [ number])
          => 0 1 two
          m4_foreach([number], m4_make_list(zero, [one], [[two]]), [ number])
          => 0 1 two

 -- Macro: m4_quote (ARG, ...)
     Return the arguments as a single entity, i.e., wrap them into a
     pair of quotes.  This effectively collapses multiple arguments
     into one, although it loses whitespace after unquoted commas in
     the process.

 -- Macro: m4_reverse (ARG, ...)
     Outputs each argument with the same level of quoting, but in
     reverse order, and with space following each comma for readability.

          m4_define([active], [ACT,IVE])
          =>
          m4_reverse(active, [active])
          =>active, IVE, ACT

 -- Macro: m4_unquote (ARG, ...)
     This macro was introduced in Autoconf 2.62.  Expand each argument,
     separated by commas.  For a single ARG, this effectively removes a
     layer of quoting, and `m4_unquote([ARG])' is more efficient than
     the equivalent `m4_do([ARG])'.  For multiple arguments, this
     results in an unquoted list of expansions.  This is commonly used
     with `m4_split', in order to convert a single quoted list into a
     series of quoted elements.

   The following example aims at emphasizing the difference between
several scenarios: not using these macros, using `m4_defn', using
`m4_quote', using `m4_dquote', and using `m4_expand'.

     $ cat example.m4
     dnl Overquote, so that quotes are visible.
     m4_define([show], [$[]1 = [$1], $[]@ = [$@]])
     m4_define([a], [A])
     m4_define([mkargs], [1, 2[,] 3])
     m4_define([arg1], [[$1]])
     m4_divert([0])dnl
     show(a, b)
     show([a, b])
     show(m4_quote(a, b))
     show(m4_dquote(a, b))
     show(m4_expand([a, b]))

     arg1(mkargs)
     arg1([mkargs])
     arg1(m4_defn([mkargs]))
     arg1(m4_quote(mkargs))
     arg1(m4_dquote(mkargs))
     arg1(m4_expand([mkargs]))
     $ autom4te -l m4sugar example.m4
     $1 = A, $@ = [A],[b]
     $1 = a, b, $@ = [a, b]
     $1 = A,b, $@ = [A,b]
     $1 = [A],[b], $@ = [[A],[b]]
     $1 = A, b, $@ = [A, b]

     1
     mkargs
     1, 2[,] 3
     1,2, 3
     [1],[2, 3]
     1, 2, 3

==============================================================================
File: autoconf.info,  Node: |Text_processing_Macros|,  Next: |Number_processing_Macros|,  Prev: |Evaluation_Macros|,  Up: |Programming_in_M4sugar|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Text_processing_Macros*

8.3.7 String manipulation in M4
-------------------------------

The following macros may be used to manipulate strings in M4.  Many of
the macros in this section intentionally result in quoted strings as
output, rather than subjecting the arguments to further expansions.  As
a result, if you are manipulating text that contains active M4
characters, the arguments are passed with single quoting rather than
double.

 -- Macro: m4_append (MACRO-NAME, STRING, [SEPARATOR])
 -- Macro: m4_append_uniq (MACRO-NAME, STRING, [SEPARATOR] [IF-UNIQ],
          [IF-DUPLICATE])
     Redefine MACRO-NAME to its former contents with SEPARATOR and
     STRING added at the end.  If MACRO-NAME was undefined before (but
     not if it was defined but empty), then no SEPARATOR is added.  As
     of Autoconf 2.62, neither STRING nor SEPARATOR are expanded during
     this macro; instead, they are expanded when MACRO-NAME is invoked.

     `m4_append' can be used to grow strings, and `m4_append_uniq' to
     grow strings without duplicating substrings.  Additionally,
     `m4_append_uniq' takes two optional parameters as of Autoconf 2.62;
     IF-UNIQ is expanded if STRING was appended, and IF-DUPLICATE is
     expanded if STRING was already present.  Also, `m4_append_uniq'
     warns if SEPARATOR is not empty, but occurs within STRING, since
     that can lead to duplicates.

     Note that `m4_append' can scale linearly in the length of the final
     string, depending on the quality of the underlying M4
     implementation, while `m4_append_uniq' has an inherent quadratic
     scaling factor.  If an algorithm can tolerate duplicates in the
     final string, use the former for speed.  If duplicates must be
     avoided, consider using `m4_set_add' instead (*note Set
     manipulation Macros::).

          m4_define([active], [ACTIVE])dnl
          m4_append([sentence], [This is an])dnl
          m4_append([sentence], [ active ])dnl
          m4_append([sentence], [symbol.])dnl
          sentence
          =>This is an ACTIVE symbol.
          m4_undefine([active])dnl
          =>This is an active symbol.
          m4_append_uniq([list], [one], [, ], [new], [existing])
          =>new
          m4_append_uniq([list], [one], [, ], [new], [existing])
          =>existing
          m4_append_uniq([list], [two], [, ], [new], [existing])
          =>new
          m4_append_uniq([list], [three], [, ], [new], [existing])
          =>new
          m4_append_uniq([list], [two], [, ], [new], [existing])
          =>existing
          list
          =>one, two, three
          m4_dquote(list)
          =>[one],[two],[three]
          m4_append([list2], [one], [[, ]])dnl
          m4_append_uniq([list2], [two], [[, ]])dnl
          m4_append([list2], [three], [[, ]])dnl
          list2
          =>one, two, three
          m4_dquote(list2)
          =>[one, two, three]

 -- Macro: m4_append_uniq_w (MACRO-NAME, STRINGS)
     This macro was introduced in Autoconf 2.62.  It is similar to
     `m4_append_uniq', but treats STRINGS as a whitespace separated
     list of words to append, and only appends unique words.
     MACRO-NAME is updated with a single space between new words.
          m4_append_uniq_w([numbers], [1 1 2])dnl
          m4_append_uniq_w([numbers], [ 2 3 ])dnl
          numbers
          =>1 2 3

 -- Macro: m4_chomp (STRING)
 -- Macro: m4_chomp_all (STRING)
     Output STRING in quotes, but without a trailing newline.  The
     macro `m4_chomp' is slightly faster, and removes at most one
     newline; the macro `m4_chomp_all' removes all consecutive trailing
     newlines.  Unlike `m4_flatten', embedded newlines are left intact,
     and backslash does not influence the result.

 -- Macro: m4_combine ([SEPARATOR], PREFIX-LIST, [INFIX], SUFFIX-1,
          [SUFFIX-2], ...)
     This macro produces a quoted string containing the pairwise
     combination of every element of the quoted, comma-separated
     PREFIX-LIST, and every element from the SUFFIX arguments.  Each
     pairwise combination is joined with INFIX in the middle, and
     successive pairs are joined by SEPARATOR.  No expansion occurs on
     any of the arguments.  No output occurs if either the PREFIX or
     SUFFIX list is empty, but the lists can contain empty elements.
          m4_define([a], [oops])dnl
          m4_combine([, ], [[a], [b], [c]], [-], [1], [2], [3])
          =>a-1, a-2, a-3, b-1, b-2, b-3, c-1, c-2, c-3
          m4_combine([, ], [[a], [b]], [-])
          =>
          m4_combine([, ], [[a], [b]], [-], [])
          =>a-, b-
          m4_combine([, ], [], [-], [1], [2])
          =>
          m4_combine([, ], [[]], [-], [1], [2])
          =>-1, -2

 -- Macro: m4_escape (STRING)
     Convert all instances of `[', `]', `#', and `$' within STRING into
     their respective quadrigraphs.  The result is still a quoted
     string.

 -- Macro: m4_flatten (STRING)
     Flatten STRING into a single line.  Delete all backslash-newline
     pairs, and replace all remaining newlines with a space.  The
     result is still a quoted string.

 -- Macro: m4_join ([SEPARATOR], ARGS...)
 -- Macro: m4_joinall ([SEPARATOR], ARGS...)
     Concatenate each ARG, separated by SEPARATOR.  `joinall' uses
     every argument, while `join' omits empty arguments so that there
     are no back-to-back separators in the output.  The result is a
     quoted string.
          m4_define([active], [ACTIVE])dnl
          m4_join([|], [one], [], [active], [two])
          =>one|active|two
          m4_joinall([|], [one], [], [active], [two])
          =>one||active|two

     Note that if all you intend to do is join ARGS with commas between
     them, to form a quoted list suitable for `m4_foreach', it is more
     efficient to use `m4_dquote'.

 -- Macro: m4_newline ([TEXT])
     This macro was introduced in Autoconf 2.62, and expands to a
     newline, followed by any TEXT.  It is primarily useful for
     maintaining macro formatting, and ensuring that M4 does not
     discard leading whitespace during argument collection.

 -- Macro: m4_normalize (STRING)
     Remove leading and trailing spaces and tabs, sequences of
     backslash-then-newline, and replace multiple spaces, tabs, and
     newlines with a single space.  This is a combination of
     `m4_flatten' and `m4_strip'.  To determine if STRING consists only
     of bytes that would be removed by `m4_normalize', you can use
     `m4_ifblank'.

 -- Macro: m4_re_escape (STRING)
     Backslash-escape all characters in STRING that are active in
     regexps.

 -- Macro: m4_split (STRING, [REGEXP = `[\t ]+'])
     Split STRING into an M4 list of elements quoted by `[' and `]',
     while keeping white space at the beginning and at the end.  If
     REGEXP is given, use it instead of `[\t ]+' for splitting.  If
     STRING is empty, the result is an empty list.

 -- Macro: m4_strip (STRING)
     Strip whitespace from STRING.  Sequences of spaces and tabs are
     reduced to a single space, then leading and trailing spaces are
     removed.  The result is still a quoted string.  Note that this
     does not interfere with newlines; if you want newlines stripped as
     well, consider `m4_flatten', or do it all at once with
     `m4_normalize'.  To quickly test if STRING has only whitespace,
     use `m4_ifblank'.

 -- Macro: m4_text_box (MESSAGE, [FRAME = `-'])
     Add a text box around MESSAGE, using FRAME as the border character
     above and below the message.  The FRAME argument must be a single
     byte, and does not support quadrigraphs.  The frame correctly
     accounts for the subsequent expansion of MESSAGE.  For example:
          m4_define([macro], [abc])dnl
          m4_text_box([macro])
          =>## --- ##
          =>## abc ##
          =>## --- ##

     The MESSAGE must contain balanced quotes and parentheses, although
     quadrigraphs can be used to work around this.

 -- Macro: m4_text_wrap (STRING, [PREFIX], [PREFIX1 = `PREFIX'], [WIDTH
          = `79'])
     Break STRING into a series of whitespace-separated words, then
     output those words separated by spaces, and wrapping lines any
     time the output would exceed WIDTH columns.  If given, PREFIX1
     begins the first line, and PREFIX begins all wrapped lines.  If
     PREFIX1 is longer than PREFIX, then the first line consists of
     just PREFIX1.  If PREFIX is longer than PREFIX1, padding is
     inserted so that the first word of STRING begins at the same
     indentation as all wrapped lines.  Note that using literal tab
     characters in any of the arguments will interfere with the
     calculation of width.  No expansions occur on PREFIX, PREFIX1, or
     the words of STRING, although quadrigraphs are recognized.

     For some examples:
          m4_text_wrap([Short string */], [   ], [/* ], [20])
          =>/* Short string */
          m4_text_wrap([Much longer string */], [   ], [/* ], [20])
          =>/* Much longer
          =>   string */
          m4_text_wrap([Short doc.], [          ], [  --short ], [30])
          =>  --short Short doc.
          m4_text_wrap([Short doc.], [          ], [  --too-wide ], [30])
          =>  --too-wide
          =>          Short doc.
          m4_text_wrap([Super long documentation.], [     ],
                       [  --too-wide ], 30)
          =>  --too-wide
          =>     Super long
          =>     documentation.

 -- Macro: m4_tolower (STRING)
 -- Macro: m4_toupper (STRING)
     Return STRING with letters converted to upper or lower case,
     respectively.

==============================================================================
File: autoconf.info,  Node: |Number_processing_Macros|,  Next: |Set_manipulation_Macros|,  Prev: |Text_processing_Macros|,  Up: |Programming_in_M4sugar|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Number_processing_Macros*

8.3.8 Arithmetic computation in M4
----------------------------------

The following macros facilitate integer arithmetic operations.  Where a
parameter is documented as taking an arithmetic expression, you can use
anything that can be parsed by `m4_eval'.

 -- Macro: m4_cmp (EXPR-1, EXPR-2)
     Compare the arithmetic expressions EXPR-1 and EXPR-2, and expand
     to `-1' if EXPR-1 is smaller, `0' if they are equal, and `1' if
     EXPR-1 is larger.

 -- Macro: m4_list_cmp (LIST-1, LIST-2)
     Compare the two M4 lists consisting of comma-separated arithmetic
     expressions, left to right.  Expand to `-1' for the first element
     pairing where the value from LIST-1 is smaller, `1' where the
     value from LIST-2 is smaller, or `0' if both lists have the same
     values.  If one list is shorter than the other, the remaining
     elements of the longer list are compared against zero.
          m4_list_cmp([1, 0],       [1])
          =>0
          m4_list_cmp([1, [1 * 0]], [1, 0])
          =>0
          m4_list_cmp([1, 2],       [1, 0])
          =>1
          m4_list_cmp([1, [1+1], 3],[1, 2])
          =>1
          m4_list_cmp([1, 2, -3],   [1, 2])
          =>-1
          m4_list_cmp([1, 0],       [1, 2])
          =>-1
          m4_list_cmp([1],          [1, 2])
          =>-1

 -- Macro: m4_max (ARG, ...)
     This macro was introduced in Autoconf 2.62.  Expand to the decimal
     value of the maximum arithmetic expression among all the arguments.

 -- Macro: m4_min (ARG, ...)
     This macro was introduced in Autoconf 2.62.  Expand to the decimal
     value of the minimum arithmetic expression among all the arguments.

 -- Macro: m4_sign (EXPR)
     Expand to `-1' if the arithmetic expression EXPR is negative, `1'
     if it is positive, and `0' if it is zero.

 -- Macro: m4_version_compare (VERSION-1, VERSION-2)
     This macro was introduced in Autoconf 2.53, but had a number of
     usability limitations that were not lifted until Autoconf 2.62.
     Compare the version strings VERSION-1 and VERSION-2, and expand to
     `-1' if VERSION-1 is smaller, `0' if they are the same, or `1'
     VERSION-2 is smaller.  Version strings must be a list of elements
     separated by `.', `,' or `-', where each element is a number along
     with optional case-insensitive letters designating beta releases.
     The comparison stops at the leftmost element that contains a
     difference, although a 0 element compares equal to a missing
     element.

     It is permissible to include commit identifiers in VERSION, such
     as an abbreviated SHA1 of the commit, provided there is still a
     monotonically increasing prefix to allow for accurate version-based
     comparisons.  For example, this paragraph was written when the
     development snapshot of autoconf claimed to be at version
     `2.61a-248-dc51', or 248 commits after the 2.61a release, with an
     abbreviated commit identification of `dc51'.

          m4_version_compare([1.1], [2.0])
          =>-1
          m4_version_compare([2.0b], [2.0a])
          =>1
          m4_version_compare([1.1.1], [1.1.1a])
          =>-1
          m4_version_compare([1.2], [1.1.1a])
          =>1
          m4_version_compare([1.0], [1])
          =>0
          m4_version_compare([1.1pre], [1.1PRE])
          =>0
          m4_version_compare([1.1a], [1,10])
          =>-1
          m4_version_compare([2.61a], [2.61a-248-dc51])
          =>-1
          m4_version_compare([2.61b], [2.61a-248-dc51])
          =>1

 -- Macro: m4_version_prereq (VERSION, [IF-NEW-ENOUGH], [IF-OLD =
          `m4_fatal'])
     Compares VERSION against the version of Autoconf currently
     running.  If the running version is at VERSION or newer, expand
     IF-NEW-ENOUGH, but if VERSION is larger than the version currently
     executing, expand IF-OLD, which defaults to printing an error
     message and exiting m4sugar with status 63.  When given only one
     argument, this behaves like `AC_PREREQ' (*note Versioning::).
     Remember that the autoconf philosophy favors feature checks over
     version checks.

==============================================================================
File: autoconf.info,  Node: |Set_manipulation_Macros|,  Next: |Forbidden_Patterns|,  Prev: |Number_processing_Macros|,  Up: |Programming_in_M4sugar|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Set_manipulation_Macros*

8.3.9 Set manipulation in M4
----------------------------

Sometimes, it is necessary to track a set of data, where the order does
not matter and where there are no duplicates in the set.  The following
macros facilitate set manipulations.  Each set is an opaque object,
which can only be accessed via these basic operations.  The underlying
implementation guarantees linear scaling for set creation, which is more
efficient than using the quadratic `m4_append_uniq'.  Both set names
and values can be arbitrary strings, except for unbalanced quotes.
This implementation ties up memory for removed elements until the next
operation that must traverse all the elements of a set; and although
that may slow down some operations until the memory for removed elements
is pruned, it still guarantees linear performance.

 -- Macro: m4_set_add (SET, VALUE, [IF-UNIQ], [IF-DUP])
     Adds the string VALUE as a member of set SET.  Expand IF-UNIQ if
     the element was added, or IF-DUP if it was previously in the set.
     Operates in amortized constant time, so that set creation scales
     linearly.

 -- Macro: m4_set_add_all (SET, VALUE...)
     Adds each VALUE to the set SET.  This is slightly more efficient
     than repeatedly invoking `m4_set_add'.

 -- Macro: m4_set_contains (SET, VALUE, [IF-PRESENT], [IF-ABSENT])
     Expands IF-PRESENT if the string VALUE is a member of SET,
     otherwise IF-ABSENT.

          m4_set_contains([a], [1], [yes], [no])
          =>no
          m4_set_add([a], [1], [added], [dup])
          =>added
          m4_set_add([a], [1], [added], [dup])
          =>dup
          m4_set_contains([a], [1], [yes], [no])
          =>yes
          m4_set_remove([a], [1], [removed], [missing])
          =>removed
          m4_set_contains([a], [1], [yes], [no])
          =>no
          m4_set_remove([a], [1], [removed], [missing])
          =>missing

 -- Macro: m4_set_contents (SET, [SEP])
 -- Macro: m4_set_dump (SET, [SEP])
     Expands to a single string consisting of all the members of the set
     SET, each separated by SEP, which is not expanded.
     `m4_set_contents' leaves the elements in SET but reclaims any
     memory occupied by removed elements, while `m4_set_dump' is a
     faster one-shot action that also deletes the set.  No provision is
     made for disambiguating members that contain a non-empty SEP as a
     substring; use `m4_set_empty' to distinguish between an empty set
     and the set containing only the empty string.  The order of the
     output is unspecified; in the current implementation, part of the
     speed of `m4_set_dump' results from using a different output order
     than `m4_set_contents'.  These macros scale linearly in the size
     of the set before memory pruning, and `m4_set_contents([SET],
     [SEP])' is faster than `m4_joinall([SEP]m4_set_listc([SET]))'.

          m4_set_add_all([a], [1], [2], [3])
          =>
          m4_set_contents([a], [-])
          =>1-2-3
          m4_joinall([-]m4_set_listc([a]))
          =>1-2-3
          m4_set_dump([a], [-])
          =>3-2-1
          m4_set_contents([a])
          =>
          m4_set_add([a], [])
          =>
          m4_set_contents([a], [-])
          =>

 -- Macro: m4_set_delete (SET)
     Delete all elements and memory associated with SET.  This is
     linear in the set size, and faster than removing one element at a
     time.

 -- Macro: m4_set_difference (SETA, SETB)
 -- Macro: m4_set_intersection (SETA, SETB)
 -- Macro: m4_set_union (SETA, SETB)
     Compute the relation between SETA and SETB, and output the result
     as a list of quoted arguments without duplicates and with a
     leading comma.  Set difference selects the elements in SETA but
     not SETB, intersection selects only elements in both sets, and
     union selects elements in either set.  These actions are linear in
     the sum of the set sizes.  The leading comma is necessary to
     distinguish between no elements and the empty string as the only
     element.

          m4_set_add_all([a], [1], [2], [3])
          =>
          m4_set_add_all([b], [3], [], [4])
          =>
          m4_set_difference([a], [b])
          =>,1,2
          m4_set_difference([b], [a])
          =>,,4
          m4_set_intersection([a], [b])
          =>,3
          m4_set_union([a], [b])
          =>,1,2,3,,4

 -- Macro: m4_set_empty (SET, [IF-EMPTY], [IF-ELEMENTS])
     Expand IF-EMPTY if the set SET has no elements, otherwise expand
     IF-ELEMENTS.  This macro operates in constant time.  Using this
     macro can help disambiguate output from `m4_set_contents' or
     `m4_set_list'.

 -- Macro: m4_set_foreach (SET, VARIABLE, ACTION)
     For each element in the set SET, expand ACTION with the macro
     VARIABLE defined as the set element.  Behavior is unspecified if
     ACTION recursively lists the contents of SET (although listing
     other sets is acceptable), or if it modifies the set in any way
     other than removing the element currently contained in VARIABLE.
     This macro is faster than the corresponding `m4_foreach([VARIABLE],
     m4_indir([m4_dquote]m4_set_listc([SET])), [ACTION])', although
     `m4_set_map' might be faster still.

          m4_set_add_all([a]m4_for([i], [1], [5], [], [,i]))
          =>
          m4_set_contents([a])
          =>12345
          m4_set_foreach([a], [i],
            [m4_if(m4_eval(i&1), [0], [m4_set_remove([a], i, [i])])])
          =>24
          m4_set_contents([a])
          =>135

 -- Macro: m4_set_list (SET)
 -- Macro: m4_set_listc (SET)
     Produce a list of arguments, where each argument is a quoted
     element from the set SET.  The variant `m4_set_listc' is
     unambiguous, by adding a leading comma if there are any set
     elements, whereas the variant `m4_set_list' cannot distinguish
     between an empty set and a set containing only the empty string.
     These can be directly used in macros that take multiple arguments,
     such as `m4_join' or `m4_set_add_all', or wrapped by `m4_dquote'
     for macros that take a quoted list, such as `m4_map' or
     `m4_foreach'.  Any memory occupied by removed elements is
     reclaimed during these macros.

          m4_set_add_all([a], [1], [2], [3])
          =>
          m4_set_list([a])
          =>1,2,3
          m4_set_list([b])
          =>
          m4_set_listc([b])
          =>
          m4_count(m4_set_list([b]))
          =>1
          m4_set_empty([b], [0], [m4_count(m4_set_list([b]))])
          =>0
          m4_set_add([b], [])
          =>
          m4_set_list([b])
          =>
          m4_set_listc([b])
          =>,
          m4_count(m4_set_list([b]))
          =>1
          m4_set_empty([b], [0], [m4_count(m4_set_list([b]))])
          =>1

 -- Macro: m4_set_map (SET, ACTION)
     For each element in the set SET, expand ACTION with a single
     argument of the set element.  Behavior is unspecified if ACTION
     recursively lists the contents of SET (although listing other sets
     is acceptable), or if it modifies the set in any way other than
     removing the element passed as an argument.  This macro is faster
     than either corresponding counterpart of
     `m4_map_args([ACTION]m4_set_listc([SET]))' or
     `m4_set_foreach([SET], [var], [ACTION(m4_defn([var]))])'.  It is
     possible to use `m4_curry' if more than one argument is needed for
     ACTION, although it is more efficient to use `m4_set_map_sep' in
     that case.

 -- Macro: m4_set_map_sep (SET, [PRE], [POST], [SEP])
     For each element in the set SET, expand `PRE[element]POST',
     additionally expanding SEP between elements.  Behavior is
     unspecified if the expansion recursively lists the contents of SET
     (although listing other sets is acceptable), or if it modifies the
     set in any way other than removing the element visited by the
     expansion.  This macro provides the most efficient means for
     non-destructively visiting the elements of a set; in particular,
     `m4_set_map([SET], [ACTION])' is equivalent to
     `m4_set_map_sep([SET], [ACTION(], [)])'.

 -- Macro: m4_set_remove (SET, VALUE, [IF-PRESENT], [IF-ABSENT])
     If VALUE is an element in the set SET, then remove it and expand
     IF-PRESENT.  Otherwise expand IF-ABSENT.  This macro operates in
     constant time so that multiple removals will scale linearly rather
     than quadratically; but when used outside of `m4_set_foreach' or
     `m4_set_map', it leaves memory occupied until the set is later
     compacted by `m4_set_contents' or `m4_set_list'.  Several other
     set operations are then less efficient between the time of element
     removal and subsequent memory compaction, but still maintain their
     guaranteed scaling performance.

 -- Macro: m4_set_size (SET)
     Expand to the size of the set SET.  This implementation operates
     in constant time, and is thus more efficient than
     `m4_eval(m4_count(m4_set_listc([set])) - 1)'.

==============================================================================
File: autoconf.info,  Node: |Forbidden_Patterns|,  Prev: |Set_manipulation_Macros|,  Up: |Programming_in_M4sugar|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Forbidden_Patterns*

8.3.10 Forbidden Patterns
-------------------------

M4sugar provides a means to define suspicious patterns, patterns
describing tokens which should not be found in the output.  For
instance, if an Autoconf `configure' script includes tokens such as
`AC_DEFINE', or `dnl', then most probably something went wrong
(typically a macro was not evaluated because of overquotation).

   M4sugar forbids all the tokens matching `^_?m4_' and `^dnl$'.
Additional layers, such as M4sh and Autoconf, add additional forbidden
patterns to the list.

 -- Macro: m4_pattern_forbid (PATTERN)
     Declare that no token matching PATTERN must be found in the output.
     Comments are not checked; this can be a problem if, for instance,
     you have some macro left unexpanded after an `#include'.  No
     consensus is currently found in the Autoconf community, as some
     people consider it should be valid to name macros in comments
     (which doesn't make sense to the authors of this documentation:
     input, such as macros, should be documented by `dnl' comments;
     reserving `#'-comments to document the output).

   Of course, you might encounter exceptions to these generic rules, for
instance you might have to refer to `$m4_flags'.

 -- Macro: m4_pattern_allow (PATTERN)
     Any token matching PATTERN is allowed, including if it matches an
     `m4_pattern_forbid' pattern.

==============================================================================
File: autoconf.info,  Node: |Debugging_via_autom4te|,  Prev: Programming in M4sugar,  Up: |Programming_in_M4|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Debugging_via_autom4te*

8.4 Debugging via autom4te
==========----------------

At times, it is desirable to see what was happening inside m4, to see
why output was not matching expectations.  However, post-processing done
by `autom4te' means that directly using the m4 builtin `m4_traceon' is
likely to interfere with operation.  Also, frequent diversion changes
and the concept of forbidden tokens make it difficult to use `m4_defn'
to generate inline comments in the final output.

   There are a couple of tools to help with this.  One is the use of the
`--trace' option provided by `autom4te' (as well as each of the
programs that wrap `autom4te', such as `autoconf'), in order to inspect
when a macro is called and with which arguments.  For example, when
this paragraph was written, the autoconf version could be found by:

     $ autoconf --trace=AC_INIT
     configure.ac:23:AC_INIT:GNU Autoconf:2.63b.95-3963:bug-autoconf@gnu.org
     $ autoconf --trace='AC_INIT:version is $2'
     version is 2.63b.95-3963

   Another trick is to print out the expansion of various m4
expressions to standard error or to an independent file, with no
further m4 expansion, and without interfering with diversion changes or
the post-processing done to standard output.  `m4_errprintn' shows a
given expression on standard error.  For example, if you want to see
the expansion of an autoconf primitive or of one of your autoconf
macros, you can do it like this:

     $ cat <<\EOF > configure.ac
     AC_INIT
     m4_errprintn([The definition of AC_DEFINE_UNQUOTED:])
     m4_errprintn(m4_defn([AC_DEFINE_UNQUOTED]))
     AC_OUTPUT
     EOF
     $ autoconf
     error-->The definition of AC_DEFINE_UNQUOTED:
     error-->_AC_DEFINE_Q([], $@)

==============================================================================
File: autoconf.info,  Node: |Programming_in_M4sh|,  Next: |Writing_Autoconf_Macros|,  Prev: |Programming_in_M4|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Programming_in_M4sh*

9 Programming in M4sh
**********===========

M4sh, pronounced "mash", is aiming at producing portable Bourne shell
scripts.  This name was coined by Lars J. Aas, who notes that,
according to the Webster's Revised Unabridged Dictionary (1913):

     Mash \Mash\, n.  [Akin to G. meisch, maisch, meische, maische,
     mash, wash, and prob. to AS. miscian to mix.  See "Mix".]

       1. A mass of mixed ingredients reduced to a soft pulpy state by
          beating or pressure...

       2. A mixture of meal or bran and water fed to animals.

       3. A mess; trouble.  [Obs.] -Beau. & Fl.

   M4sh reserves the M4 macro namespace `^_AS_' for internal use, and
the namespace `^AS_' for M4sh macros.  It also reserves the shell and
environment variable namespace `^as_', and the here-document delimiter
namespace `^_AS[A-Z]' in the output file.  You should not define your
own macros or output shell code that conflicts with these namespaces.

MENU

* |Common_Shell_Constructs|::     Portability layer for common shell constructs
* |Polymorphic_Variables|::       Support for indirect variable names
* |Initialization_Macros|::       Macros to establish a sane shell environment
* |File_Descriptor_Macros|::      File descriptor macros for input and output

==============================================================================
File: autoconf.info,  Node: |Common_Shell_Constructs|,  Next: |Polymorphic_Variables|,  Up: |Programming_in_M4sh|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Common_Shell_Constructs*

9.1 Common Shell Constructs
==========-----------------

M4sh provides portable alternatives for some common shell constructs
that unfortunately are not portable in practice.

 -- Macro: AS_BOX (TEXT, [CHAR = `-'])
     Expand into shell code that will output TEXT surrounded by a box
     with CHAR in the top and bottom border.  TEXT should not contain a
     newline, but may contain shell expansions valid for unquoted
     here-documents.  CHAR defaults to `-', but can be any character
     except `/', `'', `"', `\', `&', or ``'.  This is useful for
     outputting a comment box into log files to separate distinct
     phases of script operation.

 -- Macro: AS_CASE (WORD, [PATTERN1], [IF-MATCHED1], ..., [DEFAULT])
     Expand into a shell `case' statement, where WORD is matched
     against one or more patterns.  IF-MATCHED is run if the
     corresponding pattern matched WORD, else DEFAULT is run.  Avoids
     several portability issues (*note Limitations of Shell Builtins:
     case.).

 -- Macro: AS_DIRNAME (FILE-NAME)
     Output the directory portion of FILE-NAME.  For example, if
     `$file' is `/one/two/three', the command
     `dir=`AS_DIRNAME(["$file"])`' sets `dir' to `/one/two'.

     This interface may be improved in the future to avoid forks and
     losing trailing newlines.

 -- Macro: AS_ECHO (WORD)
     Emits WORD to the standard output, followed by a newline.  WORD
     must be a single shell word (typically a quoted string).  The
     bytes of WORD are output as-is, even if it starts with "-" or
     contains "\".  Redirections can be placed outside the macro
     invocation.  This is much more portable than using `echo' (*note
     Limitations of Shell Builtins: echo.).

 -- Macro: AS_ECHO_N (WORD)
     Emits WORD to the standard output, without a following newline.
     WORD must be a single shell word (typically a quoted string) and,
     for portability, should not include more than one newline.  The
     bytes of WORD are output as-is, even if it starts with "-" or
     contains "\".  Redirections can be placed outside the macro
     invocation.

 -- Macro: AS_ESCAPE (STRING, [CHARS = ``\"$'])
     Expands to STRING, with any characters in CHARS escaped with a
     backslash (`\').  CHARS should be at most four bytes long, and
     only contain characters from the set ``\"$'; however, characters
     may be safely listed more than once in CHARS for the sake of
     syntax highlighting editors.  The current implementation expands
     STRING after adding escapes; if STRING contains macro calls that
     in turn expand to text needing shell quoting, you can use
     `AS_ESCAPE(m4_dquote(m4_expand([string])))'.

     The default for CHARS (`\"$`') is the set of characters needing
     escapes when STRING will be used literally within double quotes.
     One common variant is the set of characters to protect when STRING
     will be used literally within back-ticks or an unquoted
     here-document (`\$`').  Another common variant is `""', which can
     be used to form a double-quoted string containing the same
     expansions that would have occurred if STRING were expanded in an
     unquoted here-document; however, when using this variant, care
     must be taken that STRING does not use double quotes within
     complex variable expansions (such as `${foo-`echo "hi"`}') that
     would be broken with improper escapes.

     This macro is often used with `AS_ECHO'.  For an example, observe
     the output generated by the shell code generated from this snippet:

          foo=bar
          AS_ECHO(["AS_ESCAPE(["$foo" = ])AS_ESCAPE(["$foo"], [""])"])
          =>"$foo" = "bar"
          m4_define([macro], [a, [\b]])
          AS_ECHO(["AS_ESCAPE([[macro]])"])
          =>macro
          AS_ECHO(["AS_ESCAPE([macro])"])
          =>a, b
          AS_ECHO(["AS_ESCAPE(m4_dquote(m4_expand([macro])))"])
          =>a, \b

     To escape a string that will be placed within single quotes, use:

          m4_bpatsubst([[STRING]], ['], ['\\''])

 -- Macro: AS_EXECUTABLE_P (FILE)
     Emit code to probe whether FILE is a regular file with executable
     permissions (and not a directory with search permissions).  The
     caller is responsible for quoting FILE.

 -- Macro: AS_EXIT ([STATUS = `$?'])
     Emit code to exit the shell with STATUS, defaulting to `$?'.  This
     macro works around shells that see the exit status of the command
     prior to `exit' inside a `trap 0' handler (*note Limitations of
     Shell Builtins: trap.).

 -- Macro: AS_IF (TEST1, [RUN-IF-TRUE1], ..., [RUN-IF-FALSE])
     Run shell code TEST1.  If TEST1 exits with a zero status then run
     shell code RUN-IF-TRUE1, else examine further tests.  If no test
     exits with a zero status, run shell code RUN-IF-FALSE, with
     simplifications if either RUN-IF-TRUE1 or RUN-IF-FALSE is empty.
     For example,

          AS_IF([test "x$foo" = xyes], [HANDLE_FOO([yes])],
                [test "x$foo" != xno], [HANDLE_FOO([maybe])],
                [echo foo not specified])

     ensures any required macros of `HANDLE_FOO' are expanded before
     the first test.

 -- Macro: AS_MKDIR_P (FILE-NAME)
     Make the directory FILE-NAME, including intervening directories as
     necessary.  This is equivalent to `mkdir -p -- FILE-NAME', except
     that it is portable to older versions of `mkdir' that lack support
     for the `-p' option or for the `--' delimiter (*note Limitations
     of Usual Tools: mkdir.).  Also, `AS_MKDIR_P' succeeds if FILE-NAME
     is a symbolic link to an existing directory, even though Posix is
     unclear whether `mkdir -p' should succeed in that case.  If
     creation of FILE-NAME fails, exit the script.

     Also see the `AC_PROG_MKDIR_P' macro (*note Particular Programs::).

 -- Macro: AS_SET_STATUS (STATUS)
     Emit shell code to set the value of `$?' to STATUS, as efficiently
     as possible.  However, this is not guaranteed to abort a shell
     running with `set -e' (*note Limitations of Shell Builtins: set.).
     This should also be used at the end of a complex shell function
     instead of `return' (*note Shell Functions::) to avoid a DJGPP
     shell bug.

 -- Macro: AS_TR_CPP (EXPRESSION)
     Transform EXPRESSION into a valid right-hand side for a C
     `#define'.  For example:

          # This outputs "#define HAVE_CHAR_P 1".
          # Notice the m4 quoting around #, to prevent an m4 comment
          type="char *"
          echo "[#]define AS_TR_CPP([HAVE_$type]) 1"

 -- Macro: AS_TR_SH (EXPRESSION)
     Transform EXPRESSION into shell code that generates a valid shell
     variable name.  The result is literal when possible at m4 time,
     but must be used with `eval' if EXPRESSION causes shell
     indirections.  For example:

          # This outputs "Have it!".
          header="sys/some file.h"
          eval AS_TR_SH([HAVE_$header])=yes
          if test "x$HAVE_sys_some_file_h" = xyes; then echo "Have it!"; fi

 -- Macro: AS_SET_CATFILE (VAR, DIR, FILE)
     Set the polymorphic shell variable VAR to DIR/FILE, but optimizing
     the common cases (DIR or FILE is `.', FILE is absolute, etc.).

 -- Macro: AS_UNSET (VAR)
     Unsets the shell variable VAR, working around bugs in older shells
     (*note Limitations of Shell Builtins: unset.).  VAR can be a
     literal or indirect variable name.

 -- Macro: AS_VERSION_COMPARE (VERSION-1, VERSION-2, [ACTION-IF-LESS],
          [ACTION-IF-EQUAL], [ACTION-IF-GREATER])
     Compare two strings VERSION-1 and VERSION-2, possibly containing
     shell variables, as version strings, and expand ACTION-IF-LESS,
     ACTION-IF-EQUAL, or ACTION-IF-GREATER depending upon the result.
     The algorithm to compare is similar to the one used by strverscmp
     in glibc (*note String/Array Comparison: (libc)String/Array
     Comparison.).

==============================================================================
File: autoconf.info,  Node: |Polymorphic_Variables|,  Next: |Initialization_Macros|,  Prev: |Common_Shell_Constructs|,  Up: |Programming_in_M4sh|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Polymorphic_Variables*

9.2 Support for indirect variable names
==========-----------------------------

Often, it is convenient to write a macro that will emit shell code
operating on a shell variable.  The simplest case is when the variable
name is known.  But a more powerful idiom is writing shell code that can
work through an indirection, where another variable or command
substitution produces the name of the variable to actually manipulate.
M4sh supports the notion of polymorphic shell variables, making it easy
to write a macro that can deal with either literal or indirect variable
names and output shell code appropriate for both use cases.  Behavior is
undefined if expansion of an indirect variable does not result in a
literal variable name.

 -- Macro: AS_LITERAL_IF (EXPRESSION, [IF-LITERAL], [IF-NOT],
          [IF-SIMPLE-REF = `IF-NOT'])
 -- Macro: AS_LITERAL_WORD_IF (EXPRESSION, [IF-LITERAL], [IF-NOT],
          [IF-SIMPLE-REF = `IF-NOT'])
     If the expansion of EXPRESSION is definitely a shell literal,
     expand IF-LITERAL.  If the expansion of EXPRESSION looks like it
     might contain shell indirections (such as `$var' or ``expr`'),
     then IF-NOT is expanded.  Sometimes, it is possible to output
     optimized code if EXPRESSION consists only of shell variable
     expansions (such as `${var}'), in which case IF-SIMPLE-REF can be
     provided; but defaulting to IF-NOT should always be safe.
     `AS_LITERAL_WORD_IF' only expands IF-LITERAL if EXPRESSION looks
     like a single shell word, containing no whitespace; while
     `AS_LITERAL_IF' allows whitespace in EXPRESSION.

     In order to reduce the time spent recognizing whether an
     EXPRESSION qualifies as a literal or a simple indirection, the
     implementation is somewhat conservative: EXPRESSION must be a
     single shell word (possibly after stripping whitespace),
     consisting only of bytes that would have the same meaning whether
     unquoted or enclosed in double quotes (for example, `a.b' results
     in IF-LITERAL, even though it is not a valid shell variable name;
     while both `'a'' and `[$]' result in IF-NOT, because they behave
     differently than `"'a'"' and `"[$]"').  This macro can be used in
     contexts for recognizing portable file names (such as in the
     implementation of `AC_LIBSOURCE'), or coupled with some
     transliterations for forming valid variable names (such as in the
     implementation of `AS_TR_SH', which uses an additional
     `m4_translit' to convert `.' to `_').

     This example shows how to read the contents of the shell variable
     `bar', exercising all three arguments to `AS_LITERAL_IF'.  It
     results in a script that will output the line `hello' three times.

          AC_DEFUN([MY_ACTION],
          [AS_LITERAL_IF([$1],
            [echo "$$1"],
            [AS_VAR_COPY([var], [$1])
             echo "$var"],
            [eval 'echo "$'"$1"\"])])
          foo=bar bar=hello
          MY_ACTION([bar])
          MY_ACTION([`echo bar`])
          MY_ACTION([$foo])

 -- Macro: AS_VAR_APPEND (VAR, TEXT)
     Emit shell code to append the shell expansion of TEXT to the end
     of the current contents of the polymorphic shell variable VAR,
     taking advantage of shells that provide the `+=' extension for more
     efficient scaling.

     For situations where the final contents of VAR are relatively
     short (less than 256 bytes), it is more efficient to use the
     simpler code sequence of `VAR=${VAR}TEXT' (or its polymorphic
     equivalent of `AS_VAR_COPY([t], [VAR])' and `AS_VAR_SET([VAR],
     ["$t"TEXT])').  But in the case when the script will be repeatedly
     appending text into `var', issues of scaling start to become
     apparent.  A naive implementation requires execution time linear
     to the length of the current contents of VAR as well as the length
     of TEXT for a single append, for an overall quadratic scaling with
     multiple appends.  This macro takes advantage of shells which
     provide the extension `VAR+=TEXT', which can provide amortized
     constant time for a single append, for an overall linear scaling
     with multiple appends.  Note that unlike `AS_VAR_SET', this macro
     requires that TEXT be quoted properly to avoid field splitting and
     file name expansion.

 -- Macro: AS_VAR_ARITH (VAR, EXPRESSION)
     Emit shell code to compute the arithmetic expansion of EXPRESSION,
     assigning the result as the contents of the polymorphic shell
     variable VAR.  The code takes advantage of shells that provide
     `$(())' for fewer forks, but uses `expr' as a fallback.
     Therefore, the syntax for a valid EXPRESSION is rather limited:
     all operators must occur as separate shell arguments and with
     proper quoting, there is no portable equality operator, all
     variables containing numeric values must be expanded prior to the
     computation, all numeric values must be provided in decimal
     without leading zeroes, and the first shell argument should not be
     a negative number.  In the following example, this snippet will
     print `(2+3)*4 == 20'.

          bar=3
          AS_VAR_ARITH([foo], [\( 2 + $bar \) \* 4])
          echo "(2+$bar)*4 == $foo"

 -- Macro: AS_VAR_COPY (DEST, SOURCE)
     Emit shell code to assign the contents of the polymorphic shell
     variable SOURCE to the polymorphic shell variable DEST.  For
     example, executing this M4sh snippet will output `bar hi':

          foo=bar bar=hi
          AS_VAR_COPY([a], [foo])
          AS_VAR_COPY([b], [$foo])
          echo "$a $b"

     When it is necessary to access the contents of an indirect variable
     inside a shell double-quoted context, the recommended idiom is to
     first copy the contents into a temporary literal shell variable.

          for header in stdint_h inttypes_h ; do
            AS_VAR_COPY([var], [ac_cv_header_$header])
            echo "$header detected: $var"
          done

 -- Macro: AS_VAR_IF (VAR, [WORD], [IF-EQUAL], [IF-NOT-EQUAL])
     Output a shell conditional statement.  If the contents of the
     polymorphic shell variable VAR match the string WORD, execute
     IF-EQUAL; otherwise execute IF-NOT-EQUAL.  WORD must be a single
     shell word (typically a quoted string).  Avoids shell bugs if an
     interrupt signal arrives while a command substitution in VAR is
     being expanded.

 -- Macro: AS_VAR_PUSHDEF (M4-NAME, VALUE)
 -- Macro: AS_VAR_POPDEF (M4-NAME)
     A common M4sh idiom involves composing shell variable names from
     an m4 argument (for example, writing a macro that uses a cache
     variable).  VALUE can be an arbitrary string, which will be
     transliterated into a valid shell name by `AS_TR_SH'.  In order to
     access the composed variable name based on VALUE, it is easier to
     declare a temporary m4 macro M4-NAME with `AS_VAR_PUSHDEF', then
     use that macro as the argument to subsequent `AS_VAR' macros as a
     polymorphic variable name, and finally free the temporary macro
     with `AS_VAR_POPDEF'.  These macros are often followed with `dnl',
     to avoid excess newlines in the output.

     Here is an involved example, that shows the power of writing
     macros that can handle composed shell variable names:

          m4_define([MY_CHECK_HEADER],
          [AS_VAR_PUSHDEF([my_Header], [ac_cv_header_$1])dnl
          AS_VAR_IF([my_Header], [yes], [echo "header $1 detected"])dnl
          AS_VAR_POPDEF([my_Header])dnl
          ])
          MY_CHECK_HEADER([stdint.h])
          for header in inttypes.h stdlib.h ; do
            MY_CHECK_HEADER([$header])
          done

     In the above example, `MY_CHECK_HEADER' can operate on polymorphic
     variable names.  In the first invocation, the m4 argument is
     `stdint.h', which transliterates into a literal `stdint_h'.  As a
     result, the temporary macro `my_Header' expands to the literal
     shell name `ac_cv_header_stdint_h'.  In the second invocation, the
     m4 argument to `MY_CHECK_HEADER' is `$header', and the temporary
     macro `my_Header' expands to the indirect shell name
     `$as_my_Header'.  During the shell execution of the for loop, when
     `$header' contains `inttypes.h', then `$as_my_Header' contains
     `ac_cv_header_inttypes_h'.  If this script is then run on a
     platform where all three headers have been previously detected, the
     output of the script will include:

          header stdint.h detected
          header inttypes.h detected
          header stdlib.h detected

 -- Macro: AS_VAR_SET (VAR, [VALUE])
     Emit shell code to assign the contents of the polymorphic shell
     variable VAR to the shell expansion of VALUE.  VALUE is not
     subject to field splitting or file name expansion, so if command
     substitution is used, it may be done with ``""`' rather than using
     an intermediate variable (*note Shell Substitutions::).  However,
     VALUE does undergo rescanning for additional macro names; behavior
     is unspecified if late expansion results in any shell
     meta-characters.

 -- Macro: AS_VAR_SET_IF (VAR, [IF-SET], [IF-UNDEF])
     Emit a shell conditional statement, which executes IF-SET if the
     polymorphic shell variable `var' is set to any value, and IF-UNDEF
     otherwise.

 -- Macro: AS_VAR_TEST_SET (VAR)
     Emit a shell statement that results in a successful exit status
     only if the polymorphic shell variable `var' is set.

==============================================================================
File: autoconf.info,  Node: |Initialization_Macros|,  Next: |File_Descriptor_Macros|,  Prev: |Polymorphic_Variables|,  Up: |Programming_in_M4sh|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Initialization_Macros*

9.3 Initialization Macros
==========---------------

 -- Macro: AS_BOURNE_COMPATIBLE
     Set up the shell to be more compatible with the Bourne shell as
     standardized by Posix, if possible.  This may involve setting
     environment variables, or setting options, or similar
     implementation-specific actions.  This macro is deprecated, since
     `AS_INIT' already invokes it.

 -- Macro: AS_INIT
     Initialize the M4sh environment.  This macro calls `m4_init', then
     outputs the `#! /bin/sh' line, a notice about where the output was
     generated from, and code to sanitize the environment for the rest
     of the script.  Among other initializations, this sets `SHELL' to
     the shell chosen to run the script (*note CONFIG_SHELL::), and
     `LC_ALL' to ensure the C locale.  Finally, it changes the current
     diversion to `BODY'.  `AS_INIT' is called automatically by
     `AC_INIT' and `AT_INIT', so shell code in `configure',
     `config.status', and `testsuite' all benefit from a sanitized
     shell environment.

 -- Macro: AS_INIT_GENERATED (FILE, [COMMENT])
     Emit shell code to start the creation of a subsidiary shell script
     in FILE, including changing FILE to be executable.  This macro
     populates the child script with information learned from the parent
     (thus, the emitted code is equivalent in effect, but more
     efficient, than the code output by `AS_INIT',
     `AS_BOURNE_COMPATIBLE', and `AS_SHELL_SANITIZE').  If present,
     COMMENT is output near the beginning of the child, prior to the
     shell initialization code, and is subject to parameter expansion,
     command substitution, and backslash quote removal.  The parent
     script should check the exit status after this macro, in case FILE
     could not be properly created (for example, if the disk was full).
     If successfully created, the parent script can then proceed to
     append additional M4sh constructs into the child script.

     Note that the child script starts life without a log file open, so
     if the parent script uses logging (*note AS_MESSAGE_LOG_FD::), you
     must temporarily disable any attempts to use the log file until
     after emitting code to open a log within the child.  On the other
     hand, if the parent script has `AS_MESSAGE_FD' redirected
     somewhere besides `1', then the child script already has code that
     copies stdout to that descriptor.  Currently, the suggested idiom
     for writing a M4sh shell script from within another script is:

          AS_INIT_GENERATED([FILE], [[# My child script.
          ]]) || { AS_ECHO(["Failed to create child script"]); AS_EXIT; }
          m4_pushdef([AS_MESSAGE_LOG_FD])dnl
          cat >> "FILE" <<\__EOF__
          # Code to initialize AS_MESSAGE_LOG_FD
          m4_popdef([AS_MESSAGE_LOG_FD])dnl
          # Additional code
          __EOF__

     This, however, may change in the future as the M4sh interface is
     stabilized further.

     Also, be aware that use of `LINENO' within the child script may
     report line numbers relative to their location in the parent
     script, even when using `AS_LINENO_PREPARE', if the parent script
     was unable to locate a shell with working `LINENO' support.

 -- Macro: AS_LINENO_PREPARE
     Find a shell that supports the special variable `LINENO', which
     contains the number of the currently executing line.  This macro is
     automatically invoked by `AC_INIT' in configure scripts.

 -- Macro: AS_ME_PREPARE
     Set up variable `as_me' to be the basename of the currently
     executing script.  This macro is automatically invoked by
     `AC_INIT' in configure scripts.

 -- Macro: AS_TMPDIR (PREFIX, [DIR = `${TMPDIR:=/tmp}'])
     Create, as safely as possible, a temporary sub-directory within
     DIR with a name starting with PREFIX.  PREFIX should be 2-4
     characters, to make it slightly easier to identify the owner of
     the directory.  If DIR is omitted, then the value of `TMPDIR' will
     be used (defaulting to `/tmp').  On success, the name of the newly
     created directory is stored in the shell variable `tmp'.  On
     error, the script is aborted.

     Typically, this macro is coupled with some exit traps to delete
     the created directory and its contents on exit or interrupt.
     However, there is a slight window between when the directory is
     created and when the name is actually known to the shell, so an
     interrupt at the right moment might leave the temporary directory
     behind.  Hence it is important to use a PREFIX that makes it
     easier to determine if a leftover temporary directory from an
     interrupted script is safe to delete.

     The use of the output variable `$tmp' rather than something in the
     `as_' namespace is historical; it has the unfortunate consequence
     that reusing this otherwise common name for any other purpose
     inside your script has the potential to break any cleanup traps
     designed to remove the temporary directory.

 -- Macro: AS_SHELL_SANITIZE
     Initialize the shell suitably for `configure' scripts.  This has
     the effect of `AS_BOURNE_COMPATIBLE', and sets some other
     environment variables for predictable results from configuration
     tests.  For example, it sets `LC_ALL' to change to the default C
     locale.  *Note Special Shell Variables::.  This macro is
     deprecated, since `AS_INIT' already invokes it.

==============================================================================
File: autoconf.info,  Node: |File_Descriptor_Macros|,  Prev: |Initialization_Macros|,  Up: |Programming_in_M4sh|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *File_Descriptor_Macros*

9.4 File Descriptor Macros
==========----------------

The following macros define file descriptors used to output messages
(or input values) from `configure' scripts.  For example:

     echo "$wombats found" >&AS_MESSAGE_LOG_FD
     echo 'Enter desired kangaroo count:' >&AS_MESSAGE_FD
     read kangaroos <&AS_ORIGINAL_STDIN_FD`

However doing so is seldom needed, because Autoconf provides higher
level macros as described below.

 -- Macro: AS_MESSAGE_FD
     The file descriptor for `checking for...'  messages and results.
     By default, `AS_INIT' sets this to `1' for standalone M4sh
     clients.  However, `AC_INIT' shuffles things around to another file
     descriptor, in order to allow the `-q' option of `configure' to
     choose whether messages should go to the script's standard output
     or be discarded.

     If you want to display some messages, consider using one of the
     printing macros (*note Printing Messages::) instead.  Copies of
     messages output via these macros are also recorded in `config.log'.

 -- Macro: AS_MESSAGE_LOG_FD
     This must either be empty, or expand to a file descriptor for log
     messages.  By default, `AS_INIT' sets this macro to the empty
     string for standalone M4sh clients, thus disabling logging.
     However, `AC_INIT' shuffles things around so that both `configure'
     and `config.status' use `config.log' for log messages.  Macros
     that run tools, like `AC_COMPILE_IFELSE' (*note Running the
     Compiler::), redirect all output to this descriptor.  You may want
     to do so if you develop such a low-level macro.

 -- Macro: AS_ORIGINAL_STDIN_FD
     This must expand to a file descriptor for the original standard
     input.  By default, `AS_INIT' sets this macro to `0' for standalone
     M4sh clients.  However, `AC_INIT' shuffles things around for
     safety.

     When `configure' runs, it may accidentally execute an interactive
     command that has the same name as the non-interactive meant to be
     used or checked.  If the standard input was the terminal, such
     interactive programs would cause `configure' to stop, pending some
     user input.  Therefore `configure' redirects its standard input
     from `/dev/null' during its initialization.  This is not normally
     a problem, since `configure' normally does not need user input.

     In the extreme case where your `configure' script really needs to
     obtain some values from the original standard input, you can read
     them explicitly from `AS_ORIGINAL_STDIN_FD'.

==============================================================================
File: autoconf.info,  Node: |Writing_Autoconf_Macros|,  Next: |Portable_Shell|,  Prev: |Programming_in_M4sh|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Writing_Autoconf_Macros*

10 Writing Autoconf Macros
**********================

When you write a feature test that could be applicable to more than one
software package, the best thing to do is encapsulate it in a new macro.
Here are some instructions and guidelines for writing Autoconf macros.

MENU

* |Macro_Definitions|::           Basic format of an Autoconf macro
* |Macro_Names|::                 What to call your new macros
* |Reporting_Messages|::          Notifying `autoconf' users
* |Dependencies_Between_Macros|::  What to do when macros depend on other macros
* |Obsoleting_Macros|::           Warning about old ways of doing things
* |Coding_Style|::                Writing Autoconf macros a` la Autoconf

==============================================================================
File: autoconf.info,  Node: |Macro_Definitions|,  Next: |Macro_Names|,  Up: |Writing_Autoconf_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Macro_Definitions*

10.1 Macro Definitions
==========------------

 -- Macro: AC_DEFUN (NAME, [BODY])
     Autoconf macros are defined using the `AC_DEFUN' macro, which is
     similar to the M4 builtin `m4_define' macro; this creates a macro
     named NAME and with BODY as its expansion.  In addition to
     defining a macro, `AC_DEFUN' adds to it some code that is used to
     constrain the order in which macros are called, while avoiding
     redundant output (*note Prerequisite Macros::).

   An Autoconf macro definition looks like this:

     AC_DEFUN(MACRO-NAME, MACRO-BODY)

   You can refer to any arguments passed to the macro as `$1', `$2',
etc.  *Note How to define new macros: (m4.info)Definitions, for more
complete information on writing M4 macros.

   Most macros fall in one of two general categories.  The first
category includes macros which take arguments, in order to generate
output parameterized by those arguments.  Macros in this category are
designed to be directly expanded, often multiple times, and should not
be used as the argument to `AC_REQUIRE'.  The other category includes
macros which are shorthand for a fixed block of text, and therefore do
not take arguments.  For this category of macros, directly expanding
the macro multiple times results in redundant output, so it is more
common to use the macro as the argument to `AC_REQUIRE', or to declare
the macro with `AC_DEFUN_ONCE' (*note One-Shot Macros::).

   Be sure to properly quote both the MACRO-BODY _and_ the MACRO-NAME
to avoid any problems if the macro happens to have been previously
defined.

   Each macro should have a header comment that gives its prototype,
and a brief description.  When arguments have default values, display
them in the prototype.  For example:

     # AC_MSG_ERROR(ERROR, [EXIT-STATUS = 1])
     # --------------------------------------
     m4_define([AC_MSG_ERROR],
       [{ AS_MESSAGE([error: $1], [2])
          exit m4_default([$2], [1]); }])

   Comments about the macro should be left in the header comment.  Most
other comments make their way into `configure', so just keep using `#'
to introduce comments.

   If you have some special comments about pure M4 code, comments that
make no sense in `configure' and in the header comment, then use the
builtin `dnl': it causes M4 to discard the text through the next
newline.

   Keep in mind that `dnl' is rarely needed to introduce comments;
`dnl' is more useful to get rid of the newlines following macros that
produce no output, such as `AC_REQUIRE'.

   Public third-party macros need to use `AC_DEFUN', and not
`m4_define', in order to be found by `aclocal' (*note Extending
aclocal: (automake)Extending aclocal.).  Additionally, if it is ever
determined that a macro should be made obsolete, it is easy to convert
from `AC_DEFUN' to `AU_DEFUN' in order to have `autoupdate' assist the
user in choosing a better alternative, but there is no corresponding
way to make `m4_define' issue an upgrade notice (*note AU_DEFUN::).

   There is another subtle, but important, difference between using
`m4_define' and `AC_DEFUN': only the former is unaffected by
`AC_REQUIRE'.  When writing a file, it is always safe to replace a
block of text with a `m4_define' macro that will expand to the same
text.  But replacing a block of text with an `AC_DEFUN' macro with the
same content does not necessarily give the same results, because it
changes the location where any embedded but unsatisfied `AC_REQUIRE'
invocations within the block will be expanded.  For an example of this,
see *note Expanded Before Required::.

==============================================================================
File: autoconf.info,  Node: |Macro_Names|,  Next: |Reporting_Messages|,  Prev: |Macro_Definitions|,  Up: |Writing_Autoconf_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Macro_Names*

10.2 Macro Names
==========------

All of the public Autoconf macros have all-uppercase names in the
namespace `^AC_' to prevent them from accidentally conflicting with
other text; Autoconf also reserves the namespace `^_AC_' for internal
macros.  All shell variables that they use for internal purposes have
mostly-lowercase names starting with `ac_'.  Autoconf also uses
here-document delimiters in the namespace `^_AC[A-Z]'.  During
`configure', files produced by Autoconf make heavy use of the file
system namespace `^conf'.

   Since Autoconf is built on top of M4sugar (*note Programming in
M4sugar::) and M4sh (*note Programming in M4sh::), you must also be
aware of those namespaces (`^_?\(m4\|AS\)_').  And since `configure.ac'
is also designed to be scanned by Autoheader, Autoscan, Autoupdate, and
Automake, you should be aware of the `^_?A[HNUM]_' namespaces.  In
general, you _should not use_ the namespace of a package that does not
own the macro or shell code you are writing.

   To ensure that your macros don't conflict with present or future
Autoconf macros, you should prefix your own macro names and any shell
variables they use with some other sequence.  Possibilities include your
initials, or an abbreviation for the name of your organization or
software package.  Historically, people have not always followed the
rule of using a namespace appropriate for their package, and this has
made it difficult for determining the origin of a macro (and where to
report bugs about that macro), as well as difficult for the true
namespace owner to add new macros without interference from pre-existing
uses of third-party macros.  Perhaps the best example of this confusion
is the `AM_GNU_GETTEXT' macro, which belongs, not to Automake, but to
Gettext.

   Most of the Autoconf macros' names follow a structured naming
convention that indicates the kind of feature check by the name.  The
macro names consist of several words, separated by underscores, going
from most general to most specific.  The names of their cache variables
use the same convention (*note Cache Variable Names::, for more
information on them).

   The first word of the name after the namespace initials (such as
`AC_') usually tells the category of the feature being tested.  Here
are the categories used in Autoconf for specific test macros, the kind
of macro that you are more likely to write.  They are also used for
cache variables, in all-lowercase.  Use them where applicable; where
they're not, invent your own categories.

`C'
     C language builtin features.

`DECL'
     Declarations of C variables in header files.

`FUNC'
     Functions in libraries.

`GROUP'
     Posix group owners of files.

`HEADER'
     Header files.

`LIB'
     C libraries.

`PROG'
     The base names of programs.

`MEMBER'
     Members of aggregates.

`SYS'
     Operating system features.

`TYPE'
     C builtin or declared types.

`VAR'
     C variables in libraries.

   After the category comes the name of the particular feature being
tested.  Any further words in the macro name indicate particular aspects
of the feature.  For example, `AC_PROG_CC_STDC' checks whether the C
compiler supports ISO Standard C.

   An internal macro should have a name that starts with an underscore;
Autoconf internals should therefore start with `_AC_'.  Additionally, a
macro that is an internal subroutine of another macro should have a
name that starts with an underscore and the name of that other macro,
followed by one or more words saying what the internal macro does.  For
example, `AC_PATH_X' has internal macros `_AC_PATH_X_XMKMF' and
`_AC_PATH_X_DIRECT'.

==============================================================================
File: autoconf.info,  Node: |Reporting_Messages|,  Next: |Dependencies_Between_Macros|,  Prev: |Macro_Names|,  Up: |Writing_Autoconf_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Reporting_Messages*

10.3 Reporting Messages
==========-------------

When macros statically diagnose abnormal situations, benign or fatal, it
is possible to make `autoconf' detect the problem, and refuse to create
`configure' in the case of an error.  The macros in this section are
considered obsolescent, and new code should use M4sugar macros for this
purpose, see *note Diagnostic Macros::.

   On the other hand, it is possible to want to detect errors when
`configure' is run, which are dependent on the environment of the user
rather than the maintainer.  For dynamic diagnostics, see *note
Printing Messages::.

 -- Macro: AC_DIAGNOSE (CATEGORY, MESSAGE)
     Report MESSAGE as a warning (or as an error if requested by the
     user) if warnings of the CATEGORY are turned on.  This macro is
     obsolescent; you are encouraged to use:
          m4_warn([CATEGORY], [MESSAGE])
     instead.  *Note m4_warn::, for more details, including valid
     CATEGORY names.

 -- Macro: AC_WARNING (MESSAGE)
     Report MESSAGE as a syntax warning.  This macro is obsolescent;
     you are encouraged to use:
          m4_warn([syntax], [MESSAGE])
     instead.  *Note m4_warn::, for more details, as well as better
     finer-grained categories of warnings (not all problems have to do
     with syntax).

 -- Macro: AC_FATAL (MESSAGE)
     Report a severe error MESSAGE, and have `autoconf' die.  This
     macro is obsolescent; you are encouraged to use:
          m4_fatal([MESSAGE])
     instead.  *Note m4_fatal::, for more details.

   When the user runs `autoconf -W error', warnings from `m4_warn'
(including those issued through `AC_DIAGNOSE' and `AC_WARNING') are
reported as errors, see *note autoconf Invocation::.

==============================================================================
File: autoconf.info,  Node: |Dependencies_Between_Macros|,  Next: |Obsoleting_Macros|,  Prev: |Reporting_Messages|,  Up: |Writing_Autoconf_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Dependencies_Between_Macros*

10.4 Dependencies Between Macros
==========----------------------

Some Autoconf macros depend on other macros having been called first in
order to work correctly.  Autoconf provides a way to ensure that certain
macros are called if needed and a way to warn the user if macros are
called in an order that might cause incorrect operation.

MENU

* |Prerequisite_Macros|::         Ensuring required information
* |Suggested_Ordering|::          Warning about possible ordering problems
* |One_Shot_Macros|::             Ensuring a macro is called only once

==============================================================================
File: autoconf.info,  Node: |Prerequisite_Macros|,  Next: |Suggested_Ordering|,  Up: |Dependencies_Between_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Prerequisite_Macros*

10.4.1 Prerequisite Macros
--------------------------

A macro that you write might need to use values that have previously
been computed by other macros.  For example, `AC_DECL_YYTEXT' examines
the output of `flex' or `lex', so it depends on `AC_PROG_LEX' having
been called first to set the shell variable `LEX'.

   Rather than forcing the user of the macros to keep track of the
dependencies between them, you can use the `AC_REQUIRE' macro to do it
automatically.  `AC_REQUIRE' can ensure that a macro is only called if
it is needed, and only called once.

 -- Macro: AC_REQUIRE (MACRO-NAME)
     If the M4 macro MACRO-NAME has not already been called, call it
     (without any arguments).  Make sure to quote MACRO-NAME with
     square brackets.  MACRO-NAME must have been defined using
     `AC_DEFUN' or else contain a call to `AC_PROVIDE' to indicate that
     it has been called.

     `AC_REQUIRE' must be used inside a macro defined by `AC_DEFUN'; it
     must not be called from the top level.  Also, it does not make
     sense to require a macro that takes parameters.

   `AC_REQUIRE' is often misunderstood.  It really implements
dependencies between macros in the sense that if one macro depends upon
another, the latter is expanded _before_ the body of the former.  To be
more precise, the required macro is expanded before the outermost
defined macro in the current expansion stack.  In particular,
`AC_REQUIRE([FOO])' is not replaced with the body of `FOO'.  For
instance, this definition of macros:

     AC_DEFUN([TRAVOLTA],
     [test "$body_temperature_in_celsius" -gt "38" &&
       dance_floor=occupied])
     AC_DEFUN([NEWTON_JOHN],
     [test "x$hair_style" = xcurly &&
       dance_floor=occupied])

     AC_DEFUN([RESERVE_DANCE_FLOOR],
     [if date | grep '^Sat.*pm' >/dev/null 2>&1; then
       AC_REQUIRE([TRAVOLTA])
       AC_REQUIRE([NEWTON_JOHN])
     fi])

with this `configure.ac'

     AC_INIT([Dance Manager], [1.0], [bug-dance@example.org])
     RESERVE_DANCE_FLOOR
     if test "x$dance_floor" = xoccupied; then
       AC_MSG_ERROR([cannot pick up here, let's move])
     fi

does not leave you with a better chance to meet a kindred soul at other
times than Saturday night since it expands into:

     test "$body_temperature_in_Celsius" -gt "38" &&
       dance_floor=occupied
     test "x$hair_style" = xcurly &&
       dance_floor=occupied
     fi
     if date | grep '^Sat.*pm' >/dev/null 2>&1; then


     fi

   This behavior was chosen on purpose: (i) it prevents messages in
required macros from interrupting the messages in the requiring macros;
(ii) it avoids bad surprises when shell conditionals are used, as in:

     if ...; then
       AC_REQUIRE([SOME_CHECK])
     fi
     ...
     SOME_CHECK

   However, this implementation can lead to another class of problems.
Consider the case where an outer macro first expands, then indirectly
requires, an inner macro:

     AC_DEFUN([TESTA], [[echo in A
     if test -n "$SEEN_A" ; then echo duplicate ; fi
     SEEN_A=:]])
     AC_DEFUN([TESTB], [AC_REQUIRE([TESTA])[echo in B
     if test -z "$SEEN_A" ; then echo bug ; fi]])
     AC_DEFUN([TESTC], [AC_REQUIRE([TESTB])[echo in C]])
     AC_DEFUN([OUTER], [[echo in OUTER]
     TESTA
     TESTC])
     OUTER

Prior to Autoconf 2.64, the implementation of `AC_REQUIRE' recognized
that `TESTB' needed to be hoisted prior to the expansion of `OUTER',
but because `TESTA' had already been directly expanded, it failed to
hoist `TESTA'.  Therefore, the expansion of `TESTB' occurs prior to its
prerequisites, leading to the following output:

     in B
     bug
     in OUTER
     in A
     in C

Newer Autoconf is smart enough to recognize this situation, and hoists
`TESTA' even though it has already been expanded, but issues a syntax
warning in the process.  This is because the hoisted expansion of
`TESTA' defeats the purpose of using `AC_REQUIRE' to avoid redundant
code, and causes its own set of problems if the hoisted macro is not
idempotent:

     in A
     in B
     in OUTER
     in A
     duplicate
     in C

   The bug is not in Autoconf, but in the macro definitions.  If you
ever pass a particular macro name to `AC_REQUIRE', then you are implying
that the macro only needs to be expanded once.  But to enforce this,
either the macro must be declared with `AC_DEFUN_ONCE' (although this
only helps in Autoconf 2.64 or newer), or all uses of that macro should
be through `AC_REQUIRE'; directly expanding the macro defeats the point
of using `AC_REQUIRE' to eliminate redundant expansion.  In the
example, this rule of thumb was violated because `TESTB' requires
`TESTA' while `OUTER' directly expands it.  One way of fixing the bug
is to factor `TESTA' into two macros, the portion designed for direct
and repeated use (here, named `TESTA'), and the portion designed for
one-shot output and used only inside `AC_REQUIRE' (here, named
`TESTA_PREREQ').  Then, by fixing all clients to use the correct
calling convention according to their needs:

     AC_DEFUN([TESTA], [AC_REQUIRE([TESTA_PREREQ])[echo in A]])
     AC_DEFUN([TESTA_PREREQ], [[echo in A_PREREQ
     if test -n "$SEEN_A" ; then echo duplicate ; fi
     SEEN_A=:]])
     AC_DEFUN([TESTB], [AC_REQUIRE([TESTA_PREREQ])[echo in B
     if test -z "$SEEN_A" ; then echo bug ; fi]])
     AC_DEFUN([TESTC], [AC_REQUIRE([TESTB])[echo in C]])
     AC_DEFUN([OUTER], [[echo in OUTER]
     TESTA
     TESTC])
     OUTER

the resulting output will then obey all dependency rules and avoid any
syntax warnings, whether the script is built with old or new Autoconf
versions:

     in A_PREREQ
     in B
     in OUTER
     in A
     in C

   The helper macros `AS_IF' and `AS_CASE' may be used to enforce
expansion of required macros outside of shell conditional constructs.
You are furthermore encouraged, although not required, to put all
`AC_REQUIRE' calls at the beginning of a macro.  You can use `dnl' to
avoid the empty lines they leave.

==============================================================================
File: autoconf.info,  Node: |Suggested_Ordering|,  Next: |One_Shot_Macros|,  Prev: |Prerequisite_Macros|,  Up: |Dependencies_Between_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Suggested_Ordering*

10.4.2 Suggested Ordering
-------------------------

Some macros should be run before another macro if both are called, but
neither _requires_ that the other be called.  For example, a macro that
changes the behavior of the C compiler should be called before any
macros that run the C compiler.  Many of these dependencies are noted in
the documentation.

   Autoconf provides the `AC_BEFORE' macro to warn users when macros
with this kind of dependency appear out of order in a `configure.ac'
file.  The warning occurs when creating `configure' from
`configure.ac', not when running `configure'.

   For example, `AC_PROG_CPP' checks whether the C compiler can run the
C preprocessor when given the `-E' option.  It should therefore be
called after any macros that change which C compiler is being used,
such as `AC_PROG_CC'.  So `AC_PROG_CC' contains:

     AC_BEFORE([$0], [AC_PROG_CPP])dnl

This warns the user if a call to `AC_PROG_CPP' has already occurred
when `AC_PROG_CC' is called.

 -- Macro: AC_BEFORE (THIS-MACRO-NAME, CALLED-MACRO-NAME)
     Make M4 print a warning message to the standard error output if
     CALLED-MACRO-NAME has already been called.  THIS-MACRO-NAME should
     be the name of the macro that is calling `AC_BEFORE'.  The macro
     CALLED-MACRO-NAME must have been defined using `AC_DEFUN' or else
     contain a call to `AC_PROVIDE' to indicate that it has been called.

==============================================================================
File: autoconf.info,  Node: |One_Shot_Macros|,  Prev: |Suggested_Ordering|,  Up: |Dependencies_Between_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *One_Shot_Macros*

10.4.3 One-Shot Macros
----------------------

Some macros should be called only once, either because calling them
multiple time is unsafe, or because it is bad style.  For instance
Autoconf ensures that `AC_CANONICAL_BUILD' and cousins (*note
Canonicalizing::) are evaluated only once, because it makes no sense to
run these expensive checks more than once.  Such one-shot macros can be
defined using `AC_DEFUN_ONCE'.

 -- Macro: AC_DEFUN_ONCE (MACRO-NAME, MACRO-BODY)
     Declare macro MACRO-NAME like `AC_DEFUN' would (*note Macro
     Definitions::), but add additional logic that guarantees that only
     the first use of the macro (whether by direct expansion or
     `AC_REQUIRE') causes an expansion of MACRO-BODY; the expansion
     will occur before the start of any enclosing macro defined by
     `AC_DEFUN'.  Subsequent expansions are silently ignored.
     Generally, it does not make sense for MACRO-BODY to use parameters
     such as `$1'.

   Prior to Autoconf 2.64, a macro defined by `AC_DEFUN_ONCE' would
emit a warning if it was directly expanded a second time, so for
portability, it is better to use `AC_REQUIRE' than direct invocation of
MACRO-NAME inside a macro defined by `AC_DEFUN' (*note Prerequisite
Macros::).

==============================================================================
File: autoconf.info,  Node: |Obsoleting_Macros|,  Next: |Coding_Style|,  Prev: |Dependencies_Between_Macros|,  Up: |Writing_Autoconf_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Obsoleting_Macros*

10.5 Obsoleting Macros
==========------------

Configuration and portability technology has evolved over the years.
Often better ways of solving a particular problem are developed, or
ad-hoc approaches are systematized.  This process has occurred in many
parts of Autoconf.  One result is that some of the macros are now
considered "obsolete"; they still work, but are no longer considered
the best thing to do, hence they should be replaced with more modern
macros.  Ideally, `autoupdate' should replace the old macro calls with
their modern implementation.

   Autoconf provides a simple means to obsolete a macro.

 -- Macro: AU_DEFUN (OLD-MACRO, IMPLEMENTATION, [MESSAGE])
     Define OLD-MACRO as IMPLEMENTATION.  The only difference with
     `AC_DEFUN' is that the user is warned that OLD-MACRO is now
     obsolete.

     If she then uses `autoupdate', the call to OLD-MACRO is replaced
     by the modern IMPLEMENTATION.  MESSAGE should include information
     on what to do after running `autoupdate'; `autoupdate' prints it
     as a warning, and includes it in the updated `configure.ac' file.

     The details of this macro are hairy: if `autoconf' encounters an
     `AU_DEFUN'ed macro, all macros inside its second argument are
     expanded as usual.  However, when `autoupdate' is run, only M4 and
     M4sugar macros are expanded here, while all other macros are
     disabled and appear literally in the updated `configure.ac'.

 -- Macro: AU_ALIAS (OLD-NAME, NEW-NAME)
     Used if the OLD-NAME is to be replaced by a call to NEW-MACRO with
     the same parameters.  This happens for example if the macro was
     renamed.

==============================================================================
File: autoconf.info,  Node: |Coding_Style|,  Prev: |Obsoleting_Macros|,  Up: |Writing_Autoconf_Macros|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Coding_Style*

10.6 Coding Style
==========-------

The Autoconf macros follow a strict coding style.  You are encouraged to
follow this style, especially if you intend to distribute your macro,
either by contributing it to Autoconf itself or the Autoconf Macro
Archive (http://www.gnu.org/software/autoconf-archive/), or by other
means.

   The first requirement is to pay great attention to the quotation.
For more details, see *note Autoconf Language::, and *note M4
Quotation::.

   Do not try to invent new interfaces.  It is likely that there is a
macro in Autoconf that resembles the macro you are defining: try to
stick to this existing interface (order of arguments, default values,
etc.).  We _are_ conscious that some of these interfaces are not
perfect; nevertheless, when harmless, homogeneity should be preferred
over creativity.

   Be careful about clashes both between M4 symbols and between shell
variables.

   If you stick to the suggested M4 naming scheme (*note Macro Names::),
you are unlikely to generate conflicts.  Nevertheless, when you need to
set a special value, _avoid using a regular macro name_; rather, use an
"impossible" name.  For instance, up to version 2.13, the macro
`AC_SUBST' used to remember what SYMBOL macros were already defined by
setting `AC_SUBST_SYMBOL', which is a regular macro name.  But since
there is a macro named `AC_SUBST_FILE', it was just impossible to
`AC_SUBST(FILE)'!  In this case, `AC_SUBST(SYMBOL)' or
`_AC_SUBST(SYMBOL)' should have been used (yes, with the parentheses).

   No Autoconf macro should ever enter the user-variable name space;
i.e., except for the variables that are the actual result of running the
macro, all shell variables should start with `ac_'.  In addition, small
macros or any macro that is likely to be embedded in other macros
should be careful not to use obvious names.

   Do not use `dnl' to introduce comments: most of the comments you are
likely to write are either header comments which are not output anyway,
or comments that should make their way into `configure'.  There are
exceptional cases where you do want to comment special M4 constructs,
in which case `dnl' is right, but keep in mind that it is unlikely.

   M4 ignores the leading blanks and newlines before each argument.
Use this feature to indent in such a way that arguments are (more or
less) aligned with the opening parenthesis of the macro being called.
For instance, instead of

     AC_CACHE_CHECK(for EMX OS/2 environment,
     ac_cv_emxos2,
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(, [return __EMX__;])],
     [ac_cv_emxos2=yes], [ac_cv_emxos2=no])])

write

     AC_CACHE_CHECK([for EMX OS/2 environment], [ac_cv_emxos2],
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [return __EMX__;])],
                        [ac_cv_emxos2=yes],
                        [ac_cv_emxos2=no])])

or even

     AC_CACHE_CHECK([for EMX OS/2 environment],
                    [ac_cv_emxos2],
                    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],
                                                        [return __EMX__;])],
                                       [ac_cv_emxos2=yes],
                                       [ac_cv_emxos2=no])])

   When using `AC_RUN_IFELSE' or any macro that cannot work when
cross-compiling, provide a pessimistic value (typically `no').

   Feel free to use various tricks to prevent auxiliary tools, such as
syntax-highlighting editors, from behaving improperly.  For instance,
instead of:

     m4_bpatsubst([$1], [$"])

use

     m4_bpatsubst([$1], [$""])

so that Emacsen do not open an endless "string" at the first quote.
For the same reasons, avoid:

     test $[#] != 0

and use:

     test $[@%:@] != 0

Otherwise, the closing bracket would be hidden inside a `#'-comment,
breaking the bracket-matching highlighting from Emacsen.  Note the
preferred style to escape from M4: `$[1]', `$[@]', etc.  Do not escape
when it is unnecessary.  Common examples of useless quotation are
`[$]$1' (write `$$1'), `[$]var' (use `$var'), etc.  If you add
portability issues to the picture, you'll prefer `${1+"$[@]"}' to
`"[$]@"', and you'll prefer do something better than hacking Autoconf
`:-)'.

   When using `sed', don't use `-e' except for indenting purposes.
With the `s' and `y' commands, the preferred separator is `/' unless
`/' itself might appear in the pattern or replacement, in which case
you should use `|', or optionally `,' if you know the pattern and
replacement cannot contain a file name.  If none of these characters
will do, choose a printable character that cannot appear in the pattern
or replacement.  Characters from the set `"#$&'()*;<=>?`|~' are good
choices if the pattern or replacement might contain a file name, since
they have special meaning to the shell and are less likely to occur in
file names.

   *Note Macro Definitions::, for details on how to define a macro.  If
a macro doesn't use `AC_REQUIRE', is expected to never be the object of
an `AC_REQUIRE' directive, and macros required by other macros inside
arguments do not need to be expanded before this macro, then use
`m4_define'.  In case of doubt, use `AC_DEFUN'.  Also take into account
that public third-party macros need to use `AC_DEFUN' in order to be
found by `aclocal' (*note Extending aclocal: (automake)Extending
aclocal.).  All the `AC_REQUIRE' statements should be at the beginning
of the macro, and each statement should be followed by `dnl'.

   You should not rely on the number of arguments: instead of checking
whether an argument is missing, test that it is not empty.  It provides
both a simpler and a more predictable interface to the user, and saves
room for further arguments.

   Unless the macro is short, try to leave the closing `])' at the
beginning of a line, followed by a comment that repeats the name of the
macro being defined.  This introduces an additional newline in
`configure'; normally, that is not a problem, but if you want to remove
it you can use `[]dnl' on the last line.  You can similarly use `[]dnl'
after a macro call to remove its newline.  `[]dnl' is recommended
instead of `dnl' to ensure that M4 does not interpret the `dnl' as
being attached to the preceding text or macro output.  For example,
instead of:

     AC_DEFUN([AC_PATH_X],
     [AC_MSG_CHECKING([for X])
     AC_REQUIRE_CPP()
     # ...omitted...
       AC_MSG_RESULT([libraries $x_libraries, headers $x_includes])
     fi])

you would write:

     AC_DEFUN([AC_PATH_X],
     [AC_REQUIRE_CPP()[]dnl
     AC_MSG_CHECKING([for X])
     # ...omitted...
       AC_MSG_RESULT([libraries $x_libraries, headers $x_includes])
     fi[]dnl
     ])# AC_PATH_X

   If the macro is long, try to split it into logical chunks.
Typically, macros that check for a bug in a function and prepare its
`AC_LIBOBJ' replacement should have an auxiliary macro to perform this
setup.  Do not hesitate to introduce auxiliary macros to factor your
code.

   In order to highlight the recommended coding style, here is a macro
written the old way:

     dnl Check for EMX on OS/2.
     dnl _AC_EMXOS2
     AC_DEFUN(_AC_EMXOS2,
     [AC_CACHE_CHECK(for EMX OS/2 environment, ac_cv_emxos2,
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(, return __EMX__;)],
     ac_cv_emxos2=yes, ac_cv_emxos2=no)])
     test "x$ac_cv_emxos2" = xyes && EMXOS2=yes])

and the new way:

     # _AC_EMXOS2
     # ----------
     # Check for EMX on OS/2.
     m4_define([_AC_EMXOS2],
     [AC_CACHE_CHECK([for EMX OS/2 environment], [ac_cv_emxos2],
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [return __EMX__;])],
                        [ac_cv_emxos2=yes],
                        [ac_cv_emxos2=no])])
     test "x$ac_cv_emxos2" = xyes && EMXOS2=yes[]dnl
     ])# _AC_EMXOS2

==============================================================================
File: autoconf.info,  Node: |Portable_Shell|,  Next: |Portable_Make|,  Prev: |Writing_Autoconf_Macros|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Portable_Shell*

11 Portable Shell Programming
**********===================

When writing your own checks, there are some shell-script programming
techniques you should avoid in order to make your code portable.  The
Bourne shell and upward-compatible shells like the Korn shell and Bash
have evolved over the years, and many features added to the original
System7 shell are now supported on all interesting porting targets.
However, the following discussion between Russ Allbery and Robert Lipe
is worth reading:

Russ Allbery:

     The GNU assumption that `/bin/sh' is the one and only shell leads
     to a permanent deadlock.  Vendors don't want to break users'
     existing shell scripts, and there are some corner cases in the
     Bourne shell that are not completely compatible with a Posix
     shell.  Thus, vendors who have taken this route will _never_
     (OK..."never say never") replace the Bourne shell (as `/bin/sh')
     with a Posix shell.

Robert Lipe:

     This is exactly the problem.  While most (at least most System
     V's) do have a Bourne shell that accepts shell functions most
     vendor `/bin/sh' programs are not the Posix shell.

     So while most modern systems do have a shell _somewhere_ that
     meets the Posix standard, the challenge is to find it.

   For this reason, part of the job of M4sh (*note Programming in
M4sh::) is to find such a shell.  But to prevent trouble, if you're not
using M4sh you should not take advantage of features that were added
after Unix version 7, circa 1977 (*note Systemology::); you should not
use aliases, negated character classes, or even `unset'.  `#' comments,
while not in Unix version 7, were retrofitted in the original Bourne
shell and can be assumed to be part of the least common denominator.

   On the other hand, if you're using M4sh you can assume that the shell
has the features that were added in SVR2 (circa 1984), including shell
functions, `return', `unset', and I/O redirection for builtins.  For
more information, refer to `http://www.in-ulm.de/~mascheck/bourne/'.
However, some pitfalls have to be avoided for portable use of these
constructs; these will be documented in the rest of this chapter.  See
in particular *note Shell Functions:: and *note Limitations of Shell
Builtins: Limitations of Builtins.

   Some ancient systems have quite small limits on the length of the
`#!' line; for instance, 32 bytes (not including the newline) on SunOS
4.  However, these ancient systems are no longer of practical concern.

   The set of external programs you should run in a `configure' script
is fairly small.  *Note Utilities in Makefiles: (standards)Utilities in
Makefiles, for the list.  This restriction allows users to start out
with a fairly small set of programs and build the rest, avoiding too
many interdependencies between packages.

   Some of these external utilities have a portable subset of features;
see *note Limitations of Usual Tools::.

   There are other sources of documentation about shells.  The
specification for the Posix Shell Command Language
(http://www.opengroup.org/susv3/utilities/xcu_chap02.html), though more
generous than the restrictive shell subset described above, is fairly
portable nowadays.  Also please see the Shell FAQs
(http://www.faqs.org/faqs/unix-faq/shell/).

MENU

* |Shellology|::                  A zoology of shells
* |Invoking_the_Shell|::          Invoking the shell as a command
* |Here_Documents|::              Quirks and tricks
* |File_Descriptors|::            FDs and redirections
* |Signal_Handling|::             Shells, signals, and headaches
* |File_System_Conventions|::     File names
* |Shell_Pattern_Matching|::      Pattern matching
* |Shell_Substitutions|::         Variable and command expansions
* |Assignments|::                 Varying side effects of assignments
* |Parentheses|::                 Parentheses in shell scripts
* |Slashes|::                     Slashes in shell scripts
* |Special_Shell_Variables|::     Variables you should not change
* |Shell_Functions|::             What to look out for if you use them
* |Limitations_of_Builtins|::     Portable use of not so portable /bin/sh
* |Limitations_of_Usual_Tools|::  Portable use of portable tools

==============================================================================
File: autoconf.info,  Node: |Shellology|,  Next: |Invoking_the_Shell|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Shellology*

11.1 Shellology
==========-----

There are several families of shells, most prominently the Bourne family
and the C shell family which are deeply incompatible.  If you want to
write portable shell scripts, avoid members of the C shell family.  The
the Shell difference FAQ
(http://www.faqs.org/faqs/unix-faq/shell/shell-differences/) includes a
small history of Posix shells, and a comparison between several of them.

   Below we describe some of the members of the Bourne shell family.

Ash
     Ash is often used on GNU/Linux and BSD systems as a light-weight
     Bourne-compatible shell.  Ash 0.2 has some bugs that are fixed in
     the 0.3.x series, but portable shell scripts should work around
     them, since version 0.2 is still shipped with many GNU/Linux
     distributions.

     To be compatible with Ash 0.2:

        - don't use `$?' after expanding empty or unset variables, or
          at the start of an `eval':

               foo=
               false
               $foo
               echo "Do not use it: $?"
               false
               eval 'echo "Do not use it: $?"'

        - don't use command substitution within variable expansion:

               cat ${FOO=`bar`}

        - beware that single builtin substitutions are not performed by
          a subshell, hence their effect applies to the current shell!
          *Note Shell Substitutions::, item "Command Substitution".

Bash
     To detect whether you are running Bash, test whether
     `BASH_VERSION' is set.  To require Posix compatibility, run `set
     -o posix'.  *Note Bash Posix Mode: (bash)Bash POSIX Mode, for
     details.

Bash 2.05 and later
     Versions 2.05 and later of Bash use a different format for the
     output of the `set' builtin, designed to make evaluating its
     output easier.  However, this output is not compatible with earlier
     versions of Bash (or with many other shells, probably).  So if you
     use Bash 2.05 or higher to execute `configure', you'll need to use
     Bash 2.05 for all other build tasks as well.

Ksh
     The Korn shell is compatible with the Bourne family and it mostly
     conforms to Posix.  It has two major variants commonly called
     `ksh88' and `ksh93', named after the years of initial release.  It
     is usually called `ksh', but is called `sh' on some hosts if you
     set your path appropriately.

     Solaris systems have three variants: `/usr/bin/ksh' is `ksh88'; it
     is standard on Solaris 2.0 and later.  `/usr/xpg4/bin/sh' is a
     Posix-compliant variant of `ksh88'; it is standard on Solaris 9
     and later.  `/usr/dt/bin/dtksh' is `ksh93'.  Variants that are not
     standard may be parts of optional packages.  There is no extra
     charge for these packages, but they are not part of a minimal OS
     install and therefore some installations may not have it.

     Starting with Tru64 Version 4.0, the Korn shell `/usr/bin/ksh' is
     also available as `/usr/bin/posix/sh'.  If the environment
     variable `BIN_SH' is set to `xpg4', subsidiary invocations of the
     standard shell conform to Posix.

Pdksh
     A public-domain clone of the Korn shell called `pdksh' is widely
     available: it has most of the `ksh88' features along with a few of
     its own.  It usually sets `KSH_VERSION', except if invoked as
     `/bin/sh' on OpenBSD, and similarly to Bash you can require Posix
     compatibility by running `set -o posix'.  Unfortunately, with
     `pdksh' 5.2.14 (the latest stable version as of January 2007)
     Posix mode is buggy and causes `pdksh' to depart from Posix in at
     least one respect, see *note Shell Substitutions::.

Zsh
     To detect whether you are running `zsh', test whether
     `ZSH_VERSION' is set.  By default `zsh' is _not_ compatible with
     the Bourne shell: you must execute `emulate sh', and for `zsh'
     versions before 3.1.6-dev-18 you must also set `NULLCMD' to `:'.
     *Note Compatibility: (zsh)Compatibility, for details.

     The default Mac OS X `sh' was originally Zsh; it was changed to
     Bash in Mac OS X 10.2.

==============================================================================
File: autoconf.info,  Node: |Invoking_the_Shell|,  Next: |Here_Documents|,  Prev: |Shellology|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Invoking_the_Shell*

11.2 Invoking the Shell
==========-------------

The Korn shell (up to at least version M-12/28/93d) has a bug when
invoked on a file whose name does not contain a slash.  It first
searches for the file's name in `PATH', and if found it executes that
rather than the original file.  For example, assuming there is a binary
executable `/usr/bin/script' in your `PATH', the last command in the
following example fails because the Korn shell finds `/usr/bin/script'
and refuses to execute it as a shell script:

     $ touch xxyzzyz script
     $ ksh xxyzzyz
     $ ksh ./script
     $ ksh script
     ksh: script: cannot execute

   Bash 2.03 has a bug when invoked with the `-c' option: if the
option-argument ends in backslash-newline, Bash incorrectly reports a
syntax error.  The problem does not occur if a character follows the
backslash:

     $ $ bash -c 'echo foo \
     > '
     bash: -c: line 2: syntax error: unexpected end of file
     $ bash -c 'echo foo \
     >  '
     foo

*Note Backslash-Newline-Empty::, for how this can cause problems in
makefiles.

==============================================================================
File: autoconf.info,  Node: |Here_Documents|,  Next: |File_Descriptors|,  Prev: |Invoking_the_Shell|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Here_Documents*

11.3 Here-Documents
==========---------

Don't rely on `\' being preserved just because it has no special
meaning together with the next symbol.  In the native `sh' on OpenBSD
2.7 `\"' expands to `"' in here-documents with unquoted delimiter.  As
a general rule, if `\\' expands to `\' use `\\' to get `\'.

   With OpenBSD 2.7's `sh'

     $ cat <<EOF
     > \" \\
     > EOF
     " \

and with Bash:

     bash-2.04$ cat <<EOF
     > \" \\
     > EOF
     \" \

   Using command substitutions in a here-document that is fed to a shell
function is not portable.  For example, with Solaris 10 `/bin/sh':

     $ kitty () { cat; }
     $ kitty <<EOF
     > `echo ok`
     > EOF
     /tmp/sh199886: cannot open
     $ echo $?
     1

   Some shells mishandle large here-documents: for example, Solaris 10
`dtksh' and the UnixWare 7.1.1 Posix shell, which are derived from Korn
shell version M-12/28/93d, mishandle braced variable expansion that
crosses a 1024- or 4096-byte buffer boundary within a here-document.
Only the part of the variable name after the boundary is used.  For
example, `${variable}' could be replaced by the expansion of `${ble}'.
If the end of the variable name is aligned with the block boundary, the
shell reports an error, as if you used `${}'.  Instead of
`${variable-default}', the shell may expand `${riable-default}', or
even `${fault}'.  This bug can often be worked around by omitting the
braces: `$variable'.  The bug was fixed in `ksh93g' (1998-04-30) but as
of 2006 many operating systems were still shipping older versions with
the bug.

   Empty here-documents are not portable either; with the following
code, `zsh' up to at least version 4.3.10 creates a file with a single
newline, whereas other shells create an empty file:

     cat >file <<EOF
     EOF

   Many shells (including the Bourne shell) implement here-documents
inefficiently.  In particular, some shells can be extremely inefficient
when a single statement contains many here-documents.  For instance if
your `configure.ac' includes something like:

     if <cross_compiling>; then
       assume this and that
     else
       check this
       check that
       check something else
       ...
       on and on forever
       ...
     fi

   A shell parses the whole `if'/`fi' construct, creating temporary
files for each here-document in it.  Some shells create links for such
here-documents on every `fork', so that the clean-up code they had
installed correctly removes them.  It is creating the links that can
take the shell forever.

   Moving the tests out of the `if'/`fi', or creating multiple
`if'/`fi' constructs, would improve the performance significantly.
Anyway, this kind of construct is not exactly the typical use of
Autoconf.  In fact, it's even not recommended, because M4 macros can't
look into shell conditionals, so we may fail to expand a macro when it
was expanded before in a conditional path, and the condition turned out
to be false at runtime, and we end up not executing the macro at all.

   Be careful with the use of `<<-' to unindent here-documents.  The
behavior is only portable for stripping leading <TAB>s, and things can
silently break if an overzealous editor converts to using leading
spaces (not all shells are nice enough to warn about unterminated
here-documents).

     $ printf 'cat <<-x\n\t1\n\t 2\n\tx\n' | bash && echo done
     1
      2
     done
     $ printf 'cat <<-x\n 1\n  2\n x\n' | bash-3.2 && echo done
      1
       2
      x
     done

==============================================================================
File: autoconf.info,  Node: |File_Descriptors|,  Next: |Signal_Handling|,  Prev: |Here_Documents|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *File_Descriptors*

11.4 File Descriptors
==========-----------

Most shells, if not all (including Bash, Zsh, Ash), output traces on
stderr, even for subshells.  This might result in undesirable content
if you meant to capture the standard-error output of the inner command:

     $ ash -x -c '(eval "echo foo >&2") 2>stderr'
     $ cat stderr
     + eval echo foo >&2
     + echo foo
     foo
     $ bash -x -c '(eval "echo foo >&2") 2>stderr'
     $ cat stderr
     + eval 'echo foo >&2'
     ++ echo foo
     foo
     $ zsh -x -c '(eval "echo foo >&2") 2>stderr'
     # Traces on startup files deleted here.
     $ cat stderr
     +zsh:1> eval echo foo >&2
     +zsh:1> echo foo
     foo

One workaround is to grep out uninteresting lines, hoping not to remove
good ones.

   If you intend to redirect both standard error and standard output,
redirect standard output first.  This works better with HP-UX, since
its shell mishandles tracing if standard error is redirected first:

     $ sh -x -c ': 2>err >out'
     + :
     + 2> err $ cat err
     1> out

   Don't try to redirect the standard error of a command substitution.
It must be done _inside_ the command substitution.  When running `: `cd
/zorglub` 2>/dev/null' expect the error message to escape, while `: `cd
/zorglub 2>/dev/null`' works properly.

   On the other hand, some shells, such as Solaris or FreeBSD
`/bin/sh', warn about missing programs before performing redirections.
Therefore, to silently check whether a program exists, it is necessary
to perform redirections on a subshell or brace group:
     $ /bin/sh -c 'nosuch 2>/dev/null'
     nosuch: not found
     $ /bin/sh -c '(nosuch) 2>/dev/null'
     $ /bin/sh -c '{ nosuch; } 2>/dev/null'
     $ bash -c 'nosuch 2>/dev/null'

   FreeBSD 6.2 sh may mix the trace output lines from the statements in
a shell pipeline.

   It is worth noting that Zsh (but not Ash nor Bash) makes it possible
in assignments though: `foo=`cd /zorglub` 2>/dev/null'.

   Some shells, like `ash', don't recognize bi-directional redirection
(`<>').  And even on shells that recognize it, it is not portable to
use on fifos: Posix does not require read-write support for named
pipes, and Cygwin does not support it:

     $ mkfifo fifo
     $ exec 5<>fifo
     $ echo hi >&5
     bash: echo: write error: Communication error on send

Furthermore, versions of `dash' before 0.5.6 mistakenly truncate
regular files when using `<>':

     $ echo a > file
     $ bash -c ': 1<>file'; cat file
     a
     $ dash -c ': 1<>file'; cat file
     $ rm a

   When catering to old systems, don't redirect the same file descriptor
several times, as you are doomed to failure under Ultrix.

     ULTRIX V4.4 (Rev. 69) System #31: Thu Aug 10 19:42:23 GMT 1995
     UWS V4.4 (Rev. 11)
     $ eval 'echo matter >fullness' >void
     illegal io
     $ eval '(echo matter >fullness)' >void
     illegal io
     $ (eval '(echo matter >fullness)') >void
     Ambiguous output redirect.

In each case the expected result is of course `fullness' containing
`matter' and `void' being empty.  However, this bug is probably not of
practical concern to modern platforms.

   Solaris 10 `sh' will try to optimize away a `:' command (even if it
is redirected) in a loop after the first iteration, or in a shell
function after the first call:

     $ for i in 1 2 3 ; do : >x$i; done
     $ ls x*
     x1
     $ f () { : >$1; }; f y1; f y2; f y3;
     $ ls y*
     y1

As a workaround, `echo' or `eval' can be used.

   Don't rely on file descriptors 0, 1, and 2 remaining closed in a
subsidiary program.  If any of these descriptors is closed, the
operating system may open an unspecified file for the descriptor in the
new process image.  Posix 2008 says this may be done only if the
subsidiary program is set-user-ID or set-group-ID, but HP-UX 11.23 does
it even for ordinary programs, and the next version of Posix will allow
HP-UX behavior.

   If you want a file descriptor above 2 to be inherited into a child
process, then you must use redirections specific to that command or a
containing subshell or command group, rather than relying on `exec' in
the shell. In `ksh' as well as HP-UX `sh', file descriptors above 2
which are opened using `exec N>file' are closed by a subsequent `exec'
(such as that involved in the fork-and-exec which runs a program or
script):

     $ echo 'echo hello >&5' >k
     $ /bin/sh -c 'exec 5>t; ksh ./k; exec 5>&-; cat t
     hello
     $ bash -c 'exec 5>t; ksh ./k; exec 5>&-; cat t
     hello
     $ ksh -c 'exec 5>t; ksh ./k; exec 5>&-; cat t
     ./k[1]: 5: cannot open [Bad file number]
     $ ksh -c '(ksh ./k) 5>t; cat t'
     hello
     $ ksh -c '{ ksh ./k; } 5>t; cat t'
     hello
     $ ksh -c '5>t ksh ./k; cat t
     hello

   Don't rely on duplicating a closed file descriptor to cause an
error.  With Solaris `/bin/sh', failed duplication is silently ignored,
which can cause unintended leaks to the original file descriptor.  In
this example, observe the leak to standard output:

     $ bash -c 'echo hi >&3' 3>&-; echo $?
     bash: 3: Bad file descriptor
     1
     $ /bin/sh -c 'echo hi >&3' 3>&-; echo $?
     hi
     0

   Fortunately, an attempt to close an already closed file descriptor
will portably succeed.  Likewise, it is safe to use either style of
`N<&-' or `N>&-' for closing a file descriptor, even if it doesn't
match the read/write mode that the file descriptor was opened with.

   DOS variants cannot rename or remove open files, such as in `mv foo
bar >foo' or `rm foo >foo', even though this is perfectly portable
among Posix hosts.

   A few ancient systems reserved some file descriptors.  By convention,
file descriptor 3 was opened to `/dev/tty' when you logged into Eighth
Edition (1985) through Tenth Edition Unix (1989).  File descriptor 4
had a special use on the Stardent/Kubota Titan (circa 1990), though we
don't now remember what it was.  Both these systems are obsolete, so
it's now safe to treat file descriptors 3 and 4 like any other file
descriptors.

   On the other hand, you can't portably use multi-digit file
descriptors.  Solaris `ksh' doesn't understand any file descriptor
larger than `9':

     $ bash -c 'exec 10>&-'; echo $?
     0
     $ ksh -c 'exec 9>&-'; echo $?
     0
     $ ksh -c 'exec 10>&-'; echo $?
     ksh[1]: exec: 10: not found
     127

==============================================================================
File: autoconf.info,  Node: |Signal_Handling|,  Next: |File_System_Conventions|,  Prev: |File_Descriptors|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Signal_Handling*

11.5 Signal Handling
==========----------

Portable handling of signals within the shell is another major source of
headaches.  This is worsened by the fact that various different,
mutually incompatible approaches are possible in this area, each with
its distinctive merits and demerits.  A detailed description of these
possible approaches, as well as of their pros and cons, can be found in
this article (http://www.cons.org/cracauer/sigint.html).

   Solaris 10 `/bin/sh' automatically traps most signals by default;
the shell still exits with error upon termination by one of those
signals, but in such a case the exit status might be somewhat
unexpected (even if allowed by POSIX, strictly speaking):

     $ bash -c 'kill -1 $$'; echo $? # Will exit 128 + (signal number).
     Hangup
     129
     $ /bin/ksh -c 'kill -15 $$'; echo $? # Likewise.
     Terminated
     143
     $ for sig in 1 2 3 15; do
     >   echo $sig:
     >   /bin/sh -c "kill -$s \$\$"; echo $?
     > done
     signal 1:
     Hangup
     129
     signal 2:
     208
     signal 3:
     208
     signal 15:
     208

   This gets even worse if one is using the POSIX `wait' interface to
get details about the shell process terminations: it will result in the
shell having exited normally, rather than by receiving a signal.

     $ cat > foo.c <<'END'
     #include <stdio.h>    /* for printf */
     #include <stdlib.h>   /* for system */
     #include <sys/wait.h> /* for WIF* macros */
     int main(void)
     {
       int status = system ("kill -15 $$");
       printf ("Terminated by signal: %s\n",
               WIFSIGNALED (status) ? "yes" : "no");
       printf ("Exited normally: %s\n",
               WIFEXITED (status) ? "yes" : "no");
       return 0;
     }
     END
     $ cc -o foo foo.c
     $ ./a.out # On GNU/Linux
     Terminated by signal: no
     Exited normally: yes
     $ ./a.out # On Solaris 10
     Terminated by signal: yes
     Exited normally: no

   Various shells seem to handle `SIGQUIT' specially: they ignore it
even if it is not blocked, and even if the shell is not running
interactively (in fact, even if the shell has no attached tty); among
these shells are at least Bash (from version 2 onwards), Zsh 4.3.12,
Solaris 10 `/bin/ksh' and `/usr/xpg4/bin/sh', and AT&T `ksh93' (2011).
Still, `SIGQUIT' seems to be trappable quite portably within all these
shells.  OTOH, some other shells doesn't special-case the handling of
`SIGQUIT'; among these shells are at least `pdksh' 5.2.14, Solaris 10
and NetBSD 5.1 `/bin/sh', and the Almquist Shell 0.5.5.1.

   Some shells (especially Korn shells and derivatives) might try to
propagate to themselves a signal that has killed a child process; this
is not a bug, but a conscious design choice (although its overall value
might be debatable).  The exact details of how this is attained vary
from shell to shell.  For example, upon running `perl -e 'kill 2, $$'',
after the perl process has been interrupted AT&T `ksh93' (2011) will
proceed to send itself a `SIGINT', while Solaris 10 `/bin/ksh' and
`/usr/xpg4/bin/sh' will proceed to exit with status 130 (i.e., 128 +
2). In any case, if there is an active trap associated with `SIGINT',
those shells will correctly execute it.

   Some Korn shells, when a child process die due receiving a signal
with signal number N, can leave in `$?' an exit status of 256+N instead
of the more common 128+N.  Observe the difference between AT&T `ksh93'
(2011) and `bash' 4.1.5 on Debian:

     $ /bin/ksh -c 'sh -c "kill -1 \$\$"; echo $?'
     /bin/ksh: line 1: 7837: Hangup
     257
     $ /bin/bash -c 'sh -c "kill -1 \$\$"; echo $?'
     /bin/bash: line 1:  7861 Hangup        (sh -c "kill -1 \$\$")
     129

This `ksh' behavior is allowed by POSIX, if implemented with due care;
see this Austin Group discussion
(http://www.austingroupbugs.net/view.php?id=51) for more background.
However, if it is not implemented with proper care, such a behavior
might cause problems in some corner cases.  To see why, assume we have
a "wrapper" script like this:

     #!/bin/sh
     # Ignore some signals in the shell only, not in its child processes.
     trap : 1 2 13 15
     wrapped_command "$@"
     ret=$?
     other_command
     exit $ret

If `wrapped_command' is interrupted by a `SIGHUP' (which has signal
number 1), `ret' will be set to 257.  Unless the `exit' shell builtin
is smart enough to understand that such a value can only have
originated from a signal, and adjust the final wait status of the shell
appropriately, the value 257 will just get truncated to 1 by the
closing `exit' call, so that a caller of the script will have no way to
determine that termination by a signal was involved.  Observe the
different behavior of AT&T `ksh93' (2011) and `bash' 4.1.5 on Debian:

     $ cat foo.sh
     #!/bin/sh
     sh -c 'kill -1 $$'
     ret=$?
     echo $ret
     exit $ret
     $ /bin/ksh foo.sh; echo $?
     foo.sh: line 2: 12479: Hangup
     257
     1
     $ /bin/bash foo.sh; echo $?
     foo.sh: line 2: 12487 Hangup        (sh -c 'kill -1 $$')
     129
     129

==============================================================================
File: autoconf.info,  Node: |File_System_Conventions|,  Next: |Shell_Pattern_Matching|,  Prev: |Signal_Handling|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *File_System_Conventions*

11.6 File System Conventions
==========------------------

Autoconf uses shell-script processing extensively, so the file names
that it processes should not contain characters that are special to the
shell.  Special characters include space, tab, newline, NUL, and the
following:

     " # $ & ' ( ) * ; < = > ? [ \ ` |

   Also, file names should not begin with `~' or `-', and should
contain neither `-' immediately after `/' nor `~' immediately after
`:'.  On Posix-like platforms, directory names should not contain `:',
as this runs afoul of `:' used as the path separator.

   These restrictions apply not only to the files that you distribute,
but also to the absolute file names of your source, build, and
destination directories.

   On some Posix-like platforms, `!' and `^' are special too, so they
should be avoided.

   Posix lets implementations treat leading `//' specially, but
requires leading `///' and beyond to be equivalent to `/'.  Most Unix
variants treat `//' like `/'.  However, some treat `//' as a
"super-root" that can provide access to files that are not otherwise
reachable from `/'.  The super-root tradition began with Apollo
Domain/OS, which died out long ago, but unfortunately Cygwin has
revived it.

   While `autoconf' and friends are usually run on some Posix variety,
they can be used on other systems, most notably DOS variants.  This
impacts several assumptions regarding file names.

For example, the following code:

     case $foo_dir in
       /*) # Absolute
          ;;
       *)
          foo_dir=$dots$foo_dir ;;
     esac

fails to properly detect absolute file names on those systems, because
they can use a drivespec, and usually use a backslash as directory
separator.  If you want to be portable to DOS variants (at the price of
rejecting valid but oddball Posix file names like `a:\b'), you can
check for absolute file names like this:

     case $foo_dir in
       [\\/]* | ?:[\\/]* ) # Absolute
          ;;
       *)
          foo_dir=$dots$foo_dir ;;
     esac

Make sure you quote the brackets if appropriate and keep the backslash
as first character (*note Limitations of Shell Builtins: case.).

   Also, because the colon is used as part of a drivespec, these
systems don't use it as path separator.  When creating or accessing
paths, you can use the `PATH_SEPARATOR' output variable instead.
`configure' sets this to the appropriate value for the build system
(`:' or `;') when it starts up.

   File names need extra care as well.  While DOS variants that are
Posixy enough to run `autoconf' (such as DJGPP) are usually able to
handle long file names properly, there are still limitations that can
seriously break packages.  Several of these issues can be easily
detected by the doschk
(ftp://ftp.gnu.org/gnu/non-gnu/doschk/doschk-1.1.tar.gz) package.

   A short overview follows; problems are marked with SFN/LFN to
indicate where they apply: SFN means the issues are only relevant to
plain DOS, not to DOS under Microsoft Windows variants, while LFN
identifies problems that exist even under Microsoft Windows variants.

No multiple dots (SFN)
     DOS cannot handle multiple dots in file names.  This is an
     especially important thing to remember when building a portable
     configure script, as `autoconf' uses a .in suffix for template
     files.

     This is perfectly OK on Posix variants:

          AC_CONFIG_HEADERS([config.h])
          AC_CONFIG_FILES([source.c foo.bar])
          AC_OUTPUT

     but it causes problems on DOS, as it requires `config.h.in',
     `source.c.in' and `foo.bar.in'.  To make your package more portable
     to DOS-based environments, you should use this instead:

          AC_CONFIG_HEADERS([config.h:config.hin])
          AC_CONFIG_FILES([source.c:source.cin foo.bar:foobar.in])
          AC_OUTPUT

No leading dot (SFN)
     DOS cannot handle file names that start with a dot.  This is
     usually not important for `autoconf'.

Case insensitivity (LFN)
     DOS is case insensitive, so you cannot, for example, have both a
     file called `INSTALL' and a directory called `install'.  This also
     affects `make'; if there's a file called `INSTALL' in the
     directory, `make install' does nothing (unless the `install'
     target is marked as PHONY).

The 8+3 limit (SFN)
     Because the DOS file system only stores the first 8 characters of
     the file name and the first 3 of the extension, those must be
     unique.  That means that `foobar-part1.c', `foobar-part2.c' and
     `foobar-prettybird.c' all resolve to the same file name
     (`FOOBAR-P.C').  The same goes for `foo.bar' and `foo.bartender'.

     The 8+3 limit is not usually a problem under Microsoft Windows, as
     it uses numeric tails in the short version of file names to make
     them unique.  However, a registry setting can turn this behavior
     off.  While this makes it possible to share file trees containing
     long file names between SFN and LFN environments, it also means
     the above problem applies there as well.

Invalid characters (LFN)
     Some characters are invalid in DOS file names, and should therefore
     be avoided.  In a LFN environment, these are `/', `\', `?', `*',
     `:', `<', `>', `|' and `"'.  In a SFN environment, other
     characters are also invalid.  These include `+', `,', `[' and `]'.

Invalid names (LFN)
     Some DOS file names are reserved, and cause problems if you try to
     use files with those names.  These names include `CON', `AUX',
     `COM1', `COM2', `COM3', `COM4', `LPT1', `LPT2', `LPT3', `NUL', and
     `PRN'.  File names are case insensitive, so even names like
     `aux/config.guess' are disallowed.


==============================================================================
File: autoconf.info,  Node: |Shell_Pattern_Matching|,  Next: |Shell_Substitutions|,  Prev: |File_System_Conventions|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Shell_Pattern_Matching*

11.7 Shell Pattern Matching
==========-----------------

Nowadays portable patterns can use negated character classes like
`[!-aeiou]'.  The older syntax `[^-aeiou]' is supported by some shells
but not others; hence portable scripts should never use `^' as the
first character of a bracket pattern.

   Outside the C locale, patterns like `[a-z]' are problematic since
they may match characters that are not lower-case letters.

==============================================================================
File: autoconf.info,  Node: |Shell_Substitutions|,  Next: |Assignments|,  Prev: |Shell_Pattern_Matching|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Shell_Substitutions*

11.8 Shell Substitutions
==========--------------

Contrary to a persistent urban legend, the Bourne shell does not
systematically split variables and back-quoted expressions, in
particular on the right-hand side of assignments and in the argument of
`case'.  For instance, the following code:

     case "$given_srcdir" in
     .)  top_srcdir="`echo "$dots" | sed 's|/$||'`" ;;
     *)  top_srcdir="$dots$given_srcdir" ;;
     esac

is more readable when written as:

     case $given_srcdir in
     .)  top_srcdir=`echo "$dots" | sed 's|/$||'` ;;
     *)  top_srcdir=$dots$given_srcdir ;;
     esac

and in fact it is even _more_ portable: in the first case of the first
attempt, the computation of `top_srcdir' is not portable, since not all
shells properly understand `"`..."..."...`"', for example Solaris 10
ksh:

     $ foo="`echo " bar" | sed 's, ,,'`"
     ksh: : cannot execute
     ksh: bar | sed 's, ,,': cannot execute

Posix does not specify behavior for this sequence.  On the other hand,
behavior for `"`...\"...\"...`"' is specified by Posix, but in
practice, not all shells understand it the same way: pdksh 5.2.14
prints spurious quotes when in Posix mode:

     $ echo "`echo \"hello\"`"
     hello
     $ set -o posix
     $ echo "`echo \"hello\"`"
     "hello"

There is just no portable way to use double-quoted strings inside
double-quoted back-quoted expressions (pfew!).

   Bash 4.1 has a bug where quoted empty strings adjacent to unquoted
parameter expansions are elided during word splitting.  Meanwhile, zsh
does not perform word splitting except when in Bourne compatibility
mode.  In the example below, the correct behavior is to have five
arguments to the function, and exactly two spaces on either side of the
middle `-', since word splitting collapses multiple spaces in `$f' but
leaves empty arguments intact.

     $ bash -c 'n() { echo "$#$@"; }; f="  -  "; n - ""$f"" -'
     3- - -
     $ ksh -c 'n() { echo "$#$@"; }; f="  -  "; n - ""$f"" -'
     5-  -  -
     $ zsh -c 'n() { echo "$#$@"; }; f="  -  "; n - ""$f"" -'
     3-   -   -
     $ zsh -c 'emulate sh;
     > n() { echo "$#$@"; }; f="  -  "; n - ""$f"" -'
     5-  -  -

You can work around this by doing manual word splitting, such as using
`"$str" $list' rather than `"$str"$list'.

   There are also portability pitfalls with particular expansions:

`$@'
     One of the most famous shell-portability issues is related to
     `"$@"'.  When there are no positional arguments, Posix says that
     `"$@"' is supposed to be equivalent to nothing, but the original
     Unix version 7 Bourne shell treated it as equivalent to `""'
     instead, and this behavior survives in later implementations like
     Digital Unix 5.0.

     The traditional way to work around this portability problem is to
     use `${1+"$@"}'.  Unfortunately this method does not work with Zsh
     (3.x and 4.x), which is used on Mac OS X.  When emulating the
     Bourne shell, Zsh performs word splitting on `${1+"$@"}':

          zsh $ emulate sh
          zsh $ for i in "$@"; do echo $i; done
          Hello World
          !
          zsh $ for i in ${1+"$@"}; do echo $i; done
          Hello
          World
          !

     Zsh handles plain `"$@"' properly, but we can't use plain `"$@"'
     because of the portability problems mentioned above.  One
     workaround relies on Zsh's "global aliases" to convert `${1+"$@"}'
     into `"$@"' by itself:

          test "${ZSH_VERSION+set}" = set && alias -g '${1+"$@"}'='"$@"'

     Zsh only recognizes this alias when a shell word matches it
     exactly; `"foo"${1+"$@"}' remains subject to word splitting.
     Since this case always yields at least one shell word, use plain
     `"$@"'.

     A more conservative workaround is to avoid `"$@"' if it is
     possible that there may be no positional arguments.  For example,
     instead of:

          cat conftest.c "$@"

     you can use this instead:

          case $# in
          0) cat conftest.c;;
          *) cat conftest.c "$@";;
          esac

     Autoconf macros often use the `set' command to update `$@', so if
     you are writing shell code intended for `configure' you should not
     assume that the value of `$@' persists for any length of time.

`${10}'
     The 10th, 11th, ... positional parameters can be accessed only
     after a `shift'.  The 7th Edition shell reported an error if given
     `${10}', and Solaris 10 `/bin/sh' still acts that way:

          $ set 1 2 3 4 5 6 7 8 9 10
          $ echo ${10}
          bad substitution

     Conversely, not all shells obey the Posix rule that when braces are
     omitted, multiple digits beyond a `$' imply the single-digit
     positional parameter expansion concatenated with the remaining
     literal digits.  To work around the issue, you must use braces.

          $ bash -c 'set a b c d e f g h i j; echo $10 ${1}0'
          a0 a0
          $ dash -c 'set a b c d e f g h i j; echo $10 ${1}0'
          j a0

`${VAR:-VALUE}'
     Old BSD shells, including the Ultrix `sh', don't accept the colon
     for any shell substitution, and complain and die.  Similarly for
     ${VAR:=VALUE}, ${VAR:?VALUE}, etc.  However, all shells that
     support functions allow the use of colon in shell substitution,
     and since m4sh requires functions, you can portably use null
     variable substitution patterns in configure scripts.

`${VAR+VALUE}'
     When using `${VAR-VALUE}' or `${VAR-VALUE}' for providing
     alternate substitutions, VALUE must either be a single shell word,
     quoted, or in the context of an unquoted here-document.  Solaris
     `/bin/sh' complains otherwise.

          $ /bin/sh -c 'echo ${a-b c}'
          /bin/sh: bad substitution
          $ /bin/sh -c 'echo ${a-'\''b c'\''}'
          b c
          $ /bin/sh -c 'echo "${a-b c}"'
          b c
          $ /bin/sh -c 'cat <<EOF
          ${a-b c}
          EOF
          b c

     According to Posix, if an expansion occurs inside double quotes,
     then the use of unquoted double quotes within VALUE is
     unspecified, and any single quotes become literal characters; in
     that case, escaping must be done with backslash.  Likewise, the
     use of unquoted here-documents is a case where double quotes have
     unspecified results:

          $ /bin/sh -c 'echo "${a-"b  c"}"'
          /bin/sh: bad substitution
          $ ksh -c 'echo "${a-"b  c"}"'
          b c
          $ bash -c 'echo "${a-"b  c"}"'
          b  c
          $ /bin/sh -c 'a=; echo ${a+'\''b  c'\''}'
          b  c
          $ /bin/sh -c 'a=; echo "${a+'\''b  c'\''}"'
          'b  c'
          $ /bin/sh -c 'a=; echo "${a+\"b  c\"}"'
          "b  c"
          $ /bin/sh -c 'a=; echo "${a+b  c}"'
          b  c
          $ /bin/sh -c 'cat <<EOF
          ${a-"b  c"}
          EOF'
          "b  c"
          $ /bin/sh -c 'cat <<EOF
          ${a-'b  c'}
          EOF'
          'b  c'
          $ bash -c 'cat <<EOF
          ${a-"b  c"}
          EOF'
          b  c
          $ bash -c 'cat <<EOF
          ${a-'b  c'}
          EOF'
          'b  c'

     Perhaps the easiest way to work around quoting issues in a manner
     portable to all shells is to place the results in a temporary
     variable, then use `$t' as the VALUE, rather than trying to inline
     the expression needing quoting.

          $ /bin/sh -c 't="b  c\"'\''}\\"; echo "${a-$t}"'
          b  c"'}\
          $ ksh -c 't="b  c\"'\''}\\"; echo "${a-$t}"'
          b  c"'}\
          $ bash -c 't="b  c\"'\''}\\"; echo "${a-$t}"'
          b  c"'}\

`${VAR=VALUE}'
     When using `${VAR=VALUE}' to assign a default value to VAR,
     remember that even though the assignment to VAR does not undergo
     file name expansion, the result of the variable expansion does
     unless the expansion occurred within double quotes.  In particular,
     when using `:' followed by unquoted variable expansion for the
     side effect of setting a default value, if the final value of
     `$var' contains any globbing characters (either from VALUE or from
     prior contents), the shell has to spend time performing file name
     expansion and field splitting even though those results will not be
     used.  Therefore, it is a good idea to consider double quotes when
     performing default initialization; while remembering how this
     impacts any quoting characters appearing in VALUE.

          $ time bash -c ': "${a=/usr/bin/*}"; echo "$a"'
          /usr/bin/*

          real	0m0.005s
          user	0m0.002s
          sys	0m0.003s
          $ time bash -c ': ${a=/usr/bin/*}; echo "$a"'
          /usr/bin/*

          real	0m0.039s
          user	0m0.026s
          sys	0m0.009s
          $ time bash -c 'a=/usr/bin/*; : ${a=noglob}; echo "$a"'
          /usr/bin/*

          real	0m0.031s
          user	0m0.020s
          sys	0m0.010s

          $ time bash -c 'a=/usr/bin/*; : "${a=noglob}"; echo "$a"'
          /usr/bin/*

          real	0m0.006s
          user	0m0.002s
          sys	0m0.003s

     As with `+' and `-', you must use quotes when using `=' if the
     VALUE contains more than one shell word; either single quotes for
     just the VALUE, or double quotes around the entire expansion:

          $ : ${var1='Some words'}
          $ : "${var2=like this}"
          $ echo $var1 $var2
          Some words like this

     otherwise some shells, such as Solaris `/bin/sh' or on Digital
     Unix V 5.0, die because of a "bad substitution".  Meanwhile, Posix
     requires that with `=', quote removal happens prior to the
     assignment, and the expansion be the final contents of VAR without
     quoting (and thus subject to field splitting), in contrast to the
     behavior with `-' passing the quoting through to the final
     expansion.  However, `bash' 4.1 does not obey this rule.

          $ ksh -c 'echo ${var-a\ \ b}'
          a  b
          $ ksh -c 'echo ${var=a\ \ b}'
          a b
          $ bash -c 'echo ${var=a\ \ b}'
          a  b

     Finally, Posix states that when mixing `${a=b}' with regular
     commands, it is unspecified whether the assignments affect the
     parent shell environment.  It is best to perform assignments
     independently from commands, to avoid the problems demonstrated in
     this example:

          $ bash -c 'x= y=${x:=b} sh -c "echo +\$x+\$y+";echo -$x-'
          +b+b+
          -b-
          $ /bin/sh -c 'x= y=${x:=b} sh -c "echo +\$x+\$y+";echo -$x-'
          ++b+
          --
          $ ksh -c 'x= y=${x:=b} sh -c "echo +\$x+\$y+";echo -$x-'
          +b+b+
          --

`${VAR=VALUE}'
     Solaris `/bin/sh' has a frightening bug in its handling of literal
     assignments.  Imagine you need set a variable to a string
     containing `}'.  This `}' character confuses Solaris `/bin/sh'
     when the affected variable was already set.  This bug can be
     exercised by running:

          $ unset foo
          $ foo=${foo='}'}
          $ echo $foo
          }
          $ foo=${foo='}'   # no error; this hints to what the bug is
          $ echo $foo
          }
          $ foo=${foo='}'}
          $ echo $foo
          }}
           ^ ugh!

     It seems that `}' is interpreted as matching `${', even though it
     is enclosed in single quotes.  The problem doesn't happen using
     double quotes, or when using a temporary variable holding the
     problematic string.

`${VAR=EXPANDED-VALUE}'
     On Ultrix, running

          default="yu,yaa"
          : ${var="$default"}

     sets VAR to `M-yM-uM-,M-yM-aM-a', i.e., the 8th bit of each char
     is set.  You don't observe the phenomenon using a simple `echo
     $var' since apparently the shell resets the 8th bit when it
     expands $var.  Here are two means to make this shell confess its
     sins:

          $ cat -v <<EOF
          $var
          EOF

     and

          $ set | grep '^var=' | cat -v

     One classic incarnation of this bug is:

          default="a b c"
          : ${list="$default"}
          for c in $list; do
            echo $c
          done

     You'll get `a b c' on a single line.  Why?  Because there are no
     spaces in `$list': there are `M- ', i.e., spaces with the 8th bit
     set, hence no IFS splitting is performed!!!

     One piece of good news is that Ultrix works fine with `:
     ${list=$default}'; i.e., if you _don't_ quote.  The bad news is
     then that QNX 4.25 then sets LIST to the _last_ item of DEFAULT!

     The portable way out consists in using a double assignment, to
     switch the 8th bit twice on Ultrix:

          list=${list="$default"}

     ...but beware of the `}' bug from Solaris (see above).  For safety,
     use:

          test "${var+set}" = set || var={VALUE}

`${#VAR}'
`${VAR%WORD}'
`${VAR%%WORD}'
`${VAR#WORD}'
`${VAR##WORD}'
     Posix requires support for these usages, but they do not work with
     many traditional shells, e.g., Solaris 10 `/bin/sh'.

     Also, `pdksh' 5.2.14 mishandles some WORD forms.  For example if
     `$1' is `a/b' and `$2' is `a', then `${1#$2}' should yield `/b',
     but with `pdksh' it yields the empty string.

``COMMANDS`'
     Posix requires shells to trim all trailing newlines from command
     output before substituting it, so assignments like `dir=`echo
     "$file" | tr a A`' do not work as expected if `$file' ends in a
     newline.

     While in general it makes no sense, do not substitute a single
     builtin with side effects, because Ash 0.2, trying to optimize,
     does not fork a subshell to perform the command.

     For instance, if you wanted to check that `cd' is silent, do not
     use `test -z "`cd /`"' because the following can happen:

          $ pwd
          /tmp
          $ test -z "`cd /`" && pwd
          /

     The result of `foo=`exit 1`' is left as an exercise to the reader.

     The MSYS shell leaves a stray byte in the expansion of a
     double-quoted command substitution of a native program, if the end
     of the substitution is not aligned with the end of the double
     quote.  This may be worked around by inserting another pair of
     quotes:

          $ echo "`printf 'foo\r\n'` bar" > broken
          $ echo "`printf 'foo\r\n'`"" bar" | cmp - broken
          - broken differ: char 4, line 1

     Upon interrupt or SIGTERM, some shells may abort a command
     substitution, replace it with a null string, and wrongly evaluate
     the enclosing command before entering the trap or ending the
     script.  This can lead to spurious errors:

          $ sh -c 'if test `sleep 5; echo hi` = hi; then echo yes; fi'
          $ ^C
          sh: test: hi: unexpected operator/operand

     You can avoid this by assigning the command substitution to a
     temporary variable:

          $ sh -c 'res=`sleep 5; echo hi`
                   if test "x$res" = xhi; then echo yes; fi'
          $ ^C

`$(COMMANDS)'
     This construct is meant to replace ``COMMANDS`', and it has most
     of the problems listed under ``COMMANDS`'.

     This construct can be nested while this is impossible to do
     portably with back quotes.  Unfortunately it is not yet
     universally supported.  Most notably, even recent releases of
     Solaris don't support it:

          $ showrev -c /bin/sh | grep version
          Command version: SunOS 5.10 Generic 121005-03 Oct 2006
          $ echo $(echo blah)
          syntax error: `(' unexpected

     nor does IRIX 6.5's Bourne shell:
          $ uname -a
          IRIX firebird-image 6.5 07151432 IP22
          $ echo $(echo blah)
          $(echo blah)

     If you do use `$(COMMANDS)', make sure that the commands do not
     start with a parenthesis, as that would cause confusion with a
     different notation `$((EXPRESSION))' that in modern shells is an
     arithmetic expression not a command.  To avoid the confusion,
     insert a space between the two opening parentheses.

     Avoid COMMANDS that contain unbalanced parentheses in
     here-documents, comments, or case statement patterns, as many
     shells mishandle them.  For example, Bash 3.1, `ksh88', `pdksh'
     5.2.14, and Zsh 4.2.6 all mishandle the following valid command:

          echo $(case x in x) echo hello;; esac)

`$((EXPRESSION))'
     Arithmetic expansion is not portable as some shells (most notably
     Solaris 10 `/bin/sh') don't support it.

     Among shells that do support `$(( ))', not all of them obey the
     Posix rule that octal and hexadecimal constants must be recognized:

          $ bash -c 'echo $(( 010 + 0x10 ))'
          24
          $ zsh -c 'echo $(( 010 + 0x10 ))'
          26
          $ zsh -c 'emulate sh; echo $(( 010 + 0x10 ))'
          24
          $ pdksh -c 'echo $(( 010 + 0x10 ))'
          pdksh:  010 + 0x10 : bad number `0x10'
          $ pdksh -c 'echo $(( 010 ))'
          10

     When it is available, using arithmetic expansion provides a
     noticeable speedup in script execution; but testing for support
     requires `eval' to avoid syntax errors.  The following construct
     is used by `AS_VAR_ARITH' to provide arithmetic computation when
     all arguments are provided in decimal and without a leading zero,
     and all operators are properly quoted and appear as distinct
     arguments:

          if ( eval 'test $(( 1 + 1 )) = 2' ) 2>/dev/null; then
            eval 'func_arith ()
            {
              func_arith_result=$(( $* ))
            }'
          else
            func_arith ()
            {
              func_arith_result=`expr "$@"`
            }
          fi
          func_arith 1 + 1
          foo=$func_arith_result

`^'
     Always quote `^', otherwise traditional shells such as `/bin/sh'
     on Solaris 10 treat this like `|'.


==============================================================================
File: autoconf.info,  Node: |Assignments|,  Next: |Parentheses|,  Prev: |Shell_Substitutions|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Assignments*

11.9 Assignments
==========------

When setting several variables in a row, be aware that the order of the
evaluation is undefined.  For instance `foo=1 foo=2; echo $foo' gives
`1' with Solaris `/bin/sh', but `2' with Bash.  You must use `;' to
enforce the order: `foo=1; foo=2; echo $foo'.

   Don't rely on the following to find `subdir/program':

     PATH=subdir$PATH_SEPARATOR$PATH program

as this does not work with Zsh 3.0.6.  Use something like this instead:

     (PATH=subdir$PATH_SEPARATOR$PATH; export PATH; exec program)

   Don't rely on the exit status of an assignment: Ash 0.2 does not
change the status and propagates that of the last statement:

     $ false || foo=bar; echo $?
     1
     $ false || foo=`:`; echo $?
     0

and to make things even worse, QNX 4.25 just sets the exit status to 0
in any case:

     $ foo=`exit 1`; echo $?
     0

   To assign default values, follow this algorithm:

  1. If the default value is a literal and does not contain any closing
     brace, use:

          : "${var='my literal'}"

  2. If the default value contains no closing brace, has to be
     expanded, and the variable being initialized is not intended to be
     IFS-split (i.e., it's not a list), then use:

          : ${var="$default"}

  3. If the default value contains no closing brace, has to be
     expanded, and the variable being initialized is intended to be
     IFS-split (i.e., it's a list), then use:

          var=${var="$default"}

  4. If the default value contains a closing brace, then use:

          test "${var+set}" = set || var="has a '}'"

   In most cases `var=${var="$default"}' is fine, but in case of doubt,
just use the last form.  *Note Shell Substitutions::, items
`${VAR:-VALUE}' and `${VAR=VALUE}' for the rationale.

==============================================================================
File: autoconf.info,  Node: |Parentheses|,  Next: |Slashes|,  Prev: |Assignments|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Parentheses*

11.10 Parentheses in Shell Scripts
==========------------------------

Beware of two opening parentheses in a row, as many shell
implementations treat them specially, and Posix says that a portable
script cannot use `((' outside the `$((' form used for shell
arithmetic.  In traditional shells, `((cat))' behaves like `(cat)'; but
many shells, including Bash and the Korn shell, treat `((cat))' as an
arithmetic expression equivalent to `let "cat"', and may or may not
report an error when they detect that `cat' is not a number.  As another
example, `pdksh' 5.2.14 does not treat the following code as a
traditional shell would:

     if ((true) || false); then
       echo ok
     fi

To work around this problem, insert a space between the two opening
parentheses.  There is a similar problem and workaround with `$(('; see
*note Shell Substitutions::.

==============================================================================
File: autoconf.info,  Node: |Slashes|,  Next: |Special_Shell_Variables|,  Prev: |Parentheses|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Slashes*

11.11 Slashes in Shell Scripts
==========--------------------

Unpatched Tru64 5.1 `sh' omits the last slash of command-line arguments
that contain two trailing slashes:

     $ echo / // /// //// .// //.
     / / // /// ./ //.
     $ x=//
     $ eval "echo \$x"
     /
     $ set -x
     $ echo abc | tr -t ab //
     + echo abc
     + tr -t ab /
     /bc

   Unpatched Tru64 4.0 `sh' adds a slash after `"$var"' if the variable
is empty and the second double-quote is followed by a word that begins
and ends with slash:

     $ sh -xc 'p=; echo "$p"/ouch/'
     p=
     + echo //ouch/
     //ouch/

   However, our understanding is that patches are available, so perhaps
it's not worth worrying about working around these horrendous bugs.

==============================================================================
File: autoconf.info,  Node: |Special_Shell_Variables|,  Next: |Shell_Functions|,  Prev: |Slashes|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Special_Shell_Variables*

11.12 Special Shell Variables
==========-------------------

Some shell variables should not be used, since they can have a deep
influence on the behavior of the shell.  In order to recover a sane
behavior from the shell, some variables should be unset; M4sh takes
care of this and provides fallback values, whenever needed, to cater
for a very old `/bin/sh' that does not support `unset'.  (*note
Portable Shell Programming: Portable Shell.).

   As a general rule, shell variable names containing a lower-case
letter are safe; you can define and use these variables without
worrying about their effect on the underlying system, and without
worrying about whether the shell changes them unexpectedly.  (The
exception is the shell variable `status', as described below.)

   Here is a list of names that are known to cause trouble.  This list
is not exhaustive, but you should be safe if you avoid the name
`status' and names containing only upper-case letters and underscores.

`?'
     Not all shells correctly reset `$?' after conditionals (*note
     Limitations of Shell Builtins: if.).  Not all shells manage `$?'
     correctly in shell functions (*note Shell Functions::) or in traps
     (*note Limitations of Shell Builtins: trap.).  Not all shells reset
     `$?' to zero after an empty command.

          $ bash -c 'false; $empty; echo $?'
          0
          $ zsh -c 'false; $empty; echo $?'
          1

`_'
     Many shells reserve `$_' for various purposes, e.g., the name of
     the last command executed.

`BIN_SH'
     In Tru64, if `BIN_SH' is set to `xpg4', subsidiary invocations of
     the standard shell conform to Posix.

`CDPATH'
     When this variable is set it specifies a list of directories to
     search when invoking `cd' with a relative file name that did not
     start with `./' or `../'.  Posix 1003.1-2001 says that if a
     nonempty directory name from `CDPATH' is used successfully, `cd'
     prints the resulting absolute file name.  Unfortunately this
     output can break idioms like `abs=`cd src && pwd`' because `abs'
     receives the name twice.  Also, many shells do not conform to this
     part of Posix; for example, `zsh' prints the result only if a
     directory name other than `.' was chosen from `CDPATH'.

     In practice the shells that have this problem also support
     `unset', so you can work around the problem as follows:

          (unset CDPATH) >/dev/null 2>&1 && unset CDPATH

     You can also avoid output by ensuring that your directory name is
     absolute or anchored at `./', as in `abs=`cd ./src && pwd`'.

     Configure scripts use M4sh, which automatically unsets `CDPATH' if
     possible, so you need not worry about this problem in those
     scripts.

`CLICOLOR_FORCE'
     When this variable is set, some implementations of tools like `ls'
     attempt to add color to their output via terminal escape
     sequences, even when the output is not directed to a terminal, and
     can thus cause spurious failures in scripts.  Configure scripts
     use M4sh, which automatically unsets this variable.

`DUALCASE'
     In the MKS shell, case statements and file name generation are
     case-insensitive unless `DUALCASE' is nonzero.  Autoconf-generated
     scripts export this variable when they start up.

`ENV'
`MAIL'
`MAILPATH'
`PS1'
`PS2'
`PS4'
     These variables should not matter for shell scripts, since they are
     supposed to affect only interactive shells.  However, at least one
     shell (the pre-3.0 UWIN Korn shell) gets confused about whether it
     is interactive, which means that (for example) a `PS1' with a side
     effect can unexpectedly modify `$?'.  To work around this bug,
     M4sh scripts (including `configure' scripts) do something like
     this:

          (unset ENV) >/dev/null 2>&1 && unset ENV MAIL MAILPATH
          PS1='$ '
          PS2='> '
          PS4='+ '

     (actually, there is some complication due to bugs in `unset';
     *note Limitations of Shell Builtins: unset.).

`FPATH'
     The Korn shell uses `FPATH' to find shell functions, so avoid
     `FPATH' in portable scripts.  `FPATH' is consulted after `PATH',
     but you still need to be wary of tests that use `PATH' to find
     whether a command exists, since they might report the wrong result
     if `FPATH' is also set.

`GREP_OPTIONS'
     When this variable is set, some implementations of `grep' honor
     these options, even if the options include direction to enable
     colored output via terminal escape sequences, and the result can
     cause spurious failures when the output is not directed to a
     terminal.  Configure scripts use M4sh, which automatically unsets
     this variable.

`IFS'
     Long ago, shell scripts inherited `IFS' from the environment, but
     this caused many problems so modern shells ignore any environment
     settings for `IFS'.

     Don't set the first character of `IFS' to backslash.  Indeed,
     Bourne shells use the first character (backslash) when joining the
     components in `"$@"' and some shells then reinterpret (!) the
     backslash escapes, so you can end up with backspace and other
     strange characters.

     The proper value for `IFS' (in regular code, not when performing
     splits) is `<SPC><TAB><RET>'.  The first character is especially
     important, as it is used to join the arguments in `$*'; however,
     note that traditional shells, but also bash-2.04, fail to adhere
     to this and join with a space anyway.

     M4sh guarantees that `IFS' will have the default value at the
     beginning of a script, and many macros within autoconf rely on this
     setting.  It is okay to use blocks of shell code that temporarily
     change the value of `IFS' in order to split on another character,
     but remember to restore it before expanding further macros.

     Unsetting `IFS' instead of resetting it to the default sequence is
     not suggested, since code that tries to save and restore the
     variable's value will incorrectly reset it to an empty value, thus
     disabling field splitting:

          unset IFS
          # default separators used for field splitting

          save_IFS=$IFS
          IFS=:
          # ...
          IFS=$save_IFS
          # no field splitting performed

`LANG'
`LC_ALL'
`LC_COLLATE'
`LC_CTYPE'
`LC_MESSAGES'
`LC_MONETARY'
`LC_NUMERIC'
`LC_TIME'
     You should set all these variables to `C' because so much
     configuration code assumes the C locale and Posix requires that
     locale environment variables be set to `C' if the C locale is
     desired; `configure' scripts and M4sh do that for you.  Export
     these variables after setting them.

`LANGUAGE'
     `LANGUAGE' is not specified by Posix, but it is a GNU extension
     that overrides `LC_ALL' in some cases, so you (or M4sh) should set
     it too.

`LC_ADDRESS'
`LC_IDENTIFICATION'
`LC_MEASUREMENT'
`LC_NAME'
`LC_PAPER'
`LC_TELEPHONE'
     These locale environment variables are GNU extensions.  They are
     treated like their Posix brethren (`LC_COLLATE', etc.) as
     described above.

`LINENO'
     Most modern shells provide the current line number in `LINENO'.
     Its value is the line number of the beginning of the current
     command.  M4sh, and hence Autoconf, attempts to execute
     `configure' with a shell that supports `LINENO'.  If no such shell
     is available, it attempts to implement `LINENO' with a Sed prepass
     that replaces each instance of the string `$LINENO' (not followed
     by an alphanumeric character) with the line's number.  In M4sh
     scripts you should execute `AS_LINENO_PREPARE' so that these
     workarounds are included in your script; configure scripts do this
     automatically in `AC_INIT'.

     You should not rely on `LINENO' within `eval' or shell functions,
     as the behavior differs in practice.  The presence of a quoted
     newline within simple commands can alter which line number is used
     as the starting point for `$LINENO' substitutions within that
     command.  Also, the possibility of the Sed prepass means that you
     should not rely on `$LINENO' when quoted, when in here-documents,
     or when line continuations are used.  Subshells should be OK,
     though.  In the following example, lines 1, 9, and 14 are
     portable, but the other instances of `$LINENO' do not have
     deterministic values:

          $ cat lineno
          echo 1. $LINENO
          echo "2. $LINENO
          3. $LINENO"
          cat <<EOF
          5. $LINENO
          6. $LINENO
          7. \$LINENO
          EOF
          ( echo 9. $LINENO )
          eval 'echo 10. $LINENO'
          eval 'echo 11. $LINENO
          echo 12. $LINENO'
          echo 13. '$LINENO'
          echo 14. $LINENO '
          15.' $LINENO
          f () { echo $1 $LINENO;
          echo $1 $LINENO }
          f 18.
          echo 19. \
          $LINENO
          $ bash-3.2 ./lineno
          1. 1
          2. 3
          3. 3
          5. 4
          6. 4
          7. $LINENO
          9. 9
          10. 10
          11. 12
          12. 13
          13. $LINENO
          14. 14
          15. 14
          18. 16
          18. 17
          19. 19
          $ zsh-4.3.4 ./lineno
          1. 1
          2. 2
          3. 2
          5. 4
          6. 4
          7. $LINENO
          9. 9
          10. 1
          11. 1
          12. 2
          13. $LINENO
          14. 14
          15. 14
          18. 0
          18. 1
          19. 19
          $ pdksh-5.2.14 ./lineno
          1. 1
          2. 2
          3. 2
          5. 4
          6. 4
          7. $LINENO
          9. 9
          10. 0
          11. 0
          12. 0
          13. $LINENO
          14. 14
          15. 14
          18. 16
          18. 17
          19. 19
          $ sed '=' <lineno |
          >   sed '
          >     N
          >     s,$,-,
          >     t loop
          >     :loop
          >     s,^\([0-9]*\)\(.*\)[$]LINENO\([^a-zA-Z0-9_]\),\1\2\1\3,
          >     t loop
          >     s,-$,,
          >     s,^[0-9]*\n,,
          >   ' |
          >   sh
          1. 1
          2. 2
          3. 3
          5. 5
          6. 6
          7. \7
          9. 9
          10. 10
          11. 11
          12. 12
          13. 13
          14. 14
          15. 15
          18. 16
          18. 17
          19. 20

     In particular, note that `config.status' (and any other subsidiary
     script created by `AS_INIT_GENERATED') might report line numbers
     relative to the parent script as a result of the potential Sed
     pass.

`NULLCMD'
     When executing the command `>foo', `zsh' executes `$NULLCMD >foo'
     unless it is operating in Bourne shell compatibility mode and the
     `zsh' version is newer than 3.1.6-dev-18.  If you are using an
     older `zsh' and forget to set `NULLCMD', your script might be
     suspended waiting for data on its standard input.

`options'
     For `zsh' 4.3.10, `options' is treated as an associative array
     even after `emulate sh', so it should not be used.

`PATH_SEPARATOR'
     On DJGPP systems, the `PATH_SEPARATOR' environment variable can be
     set to either `:' or `;' to control the path separator Bash uses
     to set up certain environment variables (such as `PATH').  You can
     set this variable to `;' if you want `configure' to use `;' as a
     separator; this might be useful if you plan to use non-Posix
     shells to execute files.  *Note File System Conventions::, for
     more information about `PATH_SEPARATOR'.

`POSIXLY_CORRECT'
     In the GNU environment, exporting `POSIXLY_CORRECT' with any value
     (even empty) causes programs to try harder to conform to Posix.
     Autoconf does not directly manipulate this variable, but `bash'
     ties the shell variable `POSIXLY_CORRECT' to whether the script is
     running in Posix mode.  Therefore, take care when exporting or
     unsetting this variable, so as not to change whether `bash' is in
     Posix mode.

          $ bash --posix -c 'set -o | grep posix
          > unset POSIXLY_CORRECT
          > set -o | grep posix'
          posix           on
          posix           off

`PWD'
     Posix 1003.1-2001 requires that `cd' and `pwd' must update the
     `PWD' environment variable to point to the logical name of the
     current directory, but traditional shells do not support this.
     This can cause confusion if one shell instance maintains `PWD' but
     a subsidiary and different shell does not know about `PWD' and
     executes `cd'; in this case `PWD' points to the wrong directory.
     Use ``pwd`' rather than `$PWD'.

`RANDOM'
     Many shells provide `RANDOM', a variable that returns a different
     integer each time it is used.  Most of the time, its value does not
     change when it is not used, but on IRIX 6.5 the value changes all
     the time.  This can be observed by using `set'.  It is common
     practice to use `$RANDOM' as part of a file name, but code
     shouldn't rely on `$RANDOM' expanding to a nonempty string.

`status'
     This variable is an alias to `$?' for `zsh' (at least 3.1.6),
     hence read-only.  Do not use it.

==============================================================================
File: autoconf.info,  Node: |Shell_Functions|,  Next: |Limitations_of_Builtins|,  Prev: |Special_Shell_Variables|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Shell_Functions*

11.13 Shell Functions
==========-----------

Nowadays, it is difficult to find a shell that does not support shell
functions at all.  However, some differences should be expected.

   When declaring a shell function, you must include whitespace between
the `)' after the function name and the start of the compound
expression, to avoid upsetting `ksh'.  While it is possible to use any
compound command, most scripts use `{...}'.

     $ /bin/sh -c 'a(){ echo hi;}; a'
     hi
     $ ksh -c 'a(){ echo hi;}; a'
     ksh: syntax error at line 1: `}' unexpected
     $ ksh -c 'a() { echo hi;}; a'
     hi

   Inside a shell function, you should not rely on the error status of a
subshell if the last command of that subshell was `exit' or `trap', as
this triggers bugs in zsh 4.x; while Autoconf tries to find a shell
that does not exhibit the bug, zsh might be the only shell present on
the user's machine.

   Likewise, the state of `$?' is not reliable when entering a shell
function.  This has the effect that using a function as the first
command in a `trap' handler can cause problems.

     $ bash -c 'foo() { echo $?; }; trap foo 0; (exit 2); exit 2'; echo $?
     2
     2
     $ ash -c 'foo() { echo $?; }; trap foo 0; (exit 2); exit 2'; echo $?
     0
     2

   DJGPP bash 2.04 has a bug in that `return' from a shell function
which also used a command substitution causes a segmentation fault.  To
work around the issue, you can use `return' from a subshell, or
`AS_SET_STATUS' as last command in the execution flow of the function
(*note Common Shell Constructs::).

   Not all shells treat shell functions as simple commands impacted by
`set -e', for example with Solaris 10 `/bin/sh':

     $ bash -c 'f() { return 1; }; set -e; f; echo oops'
     $ /bin/sh -c 'f() { return 1; }; set -e; f; echo oops'
     oops

   Shell variables and functions may share the same namespace, for
example with Solaris 10 `/bin/sh':

     $ f () { :; }; f=; f
     f: not found

For this reason, Autoconf (actually M4sh, *note Programming in M4sh::)
uses the prefix `as_fn_' for its functions.

   Handling of positional parameters and shell options varies among
shells.  For example, Korn shells reset and restore trace output (`set
-x') and other options upon function entry and exit.  Inside a function,
IRIX sh sets `$0' to the function name.

   It is not portable to pass temporary environment variables to shell
functions.  Solaris `/bin/sh' does not see the variable.  Meanwhile,
not all shells follow the Posix rule that the assignment must affect
the current environment in the same manner as special built-ins.

     $ /bin/sh -c 'func() { echo $a;}; a=1 func; echo $a'
     =>
     =>
     $ ash -c 'func() { echo $a;}; a=1 func; echo $a'
     =>1
     =>
     $ bash -c 'set -o posix; func() { echo $a;}; a=1 func; echo $a'
     =>1
     =>1

   Some ancient Bourne shell variants with function support did not
reset `$I, I >= 0', upon function exit, so effectively the arguments of
the script were lost after the first function invocation.  It is
probably not worth worrying about these shells any more.

   With AIX sh, a `trap' on 0 installed in a shell function triggers at
function exit rather than at script exit.  *Note Limitations of Shell
Builtins: trap.

==============================================================================
File: autoconf.info,  Node: |Limitations_of_Builtins|,  Next: |Limitations_of_Usual_Tools|,  Prev: |Shell_Functions|,  Up: |Portable_Shell|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Limitations_of_Builtins*

11.14 Limitations of Shell Builtins
==========-------------------------

No, no, we are serious: some shells do have limitations!  :)

   You should always keep in mind that any builtin or command may
support options, and therefore differ in behavior with arguments
starting with a dash.  For instance, even the innocent `echo "$word"'
can give unexpected results when `word' starts with a dash.  It is
often possible to avoid this problem using `echo "x$word"', taking the
`x' into account later in the pipe.  Many of these limitations can be
worked around using M4sh (*note Programming in M4sh::).

`.'
     Use `.' only with regular files (use `test -f').  Bash 2.03, for
     instance, chokes on `. /dev/null'.  Remember that `.' uses `PATH'
     if its argument contains no slashes.  Also, some shells, including
     bash 3.2, implicitly append the current directory to this `PATH'
     search, even though Posix forbids it.  So if you want to use `.'
     on a file `foo' in the current directory, you must use `. ./foo'.

     Not all shells gracefully handle syntax errors within a sourced
     file.  On one extreme, some non-interactive shells abort the
     entire script.  On the other, `zsh' 4.3.10 has a bug where it
     fails to react to the syntax error.

          $ echo 'fi' > syntax
          $ bash -c '. ./syntax; echo $?'
          ./syntax: line 1: syntax error near unexpected token `fi'
          ./syntax: line 1: `fi'
          1
          $ ash -c '. ./syntax; echo $?'
          ./syntax: 1: Syntax error: "fi" unexpected
          $ zsh -c '. ./syntax; echo $?'
          ./syntax:1: parse error near `fi'
          0

`!'
     The Unix version 7 shell did not support negating the exit status
     of commands with `!', and this feature is still absent from some
     shells (e.g., Solaris `/bin/sh').  Other shells, such as FreeBSD
     `/bin/sh' or `ash', have bugs when using `!':

          $ sh -c '! : | :'; echo $?
          1
          $ ash -c '! : | :'; echo $?
          0
          $ sh -c '! { :; }'; echo $?
          1
          $ ash -c '! { :; }'; echo $?
          {: not found
          Syntax error: "}" unexpected
          2

     Shell code like this:

          if ! cmp file1 file2 >/dev/null 2>&1; then
            echo files differ or trouble
          fi

     is therefore not portable in practice.  Typically it is easy to
     rewrite such code, e.g.:

          cmp file1 file2 >/dev/null 2>&1 ||
            echo files differ or trouble

     More generally, one can always rewrite `! COMMAND' as:

          if COMMAND; then (exit 1); else :; fi

`{...}'
     Bash 3.2 (and earlier versions) sometimes does not properly set
     `$?' when failing to write redirected output of a compound command.
     This problem is most commonly observed with `{...}'; it does not
     occur with `(...)'.  For example:

          $ bash -c '{ echo foo; } >/bad; echo $?'
          bash: line 1: /bad: Permission denied
          0
          $ bash -c 'while :; do echo; done >/bad; echo $?'
          bash: line 1: /bad: Permission denied
          0

     To work around the bug, prepend `:;':

          $ bash -c ':;{ echo foo; } >/bad; echo $?'
          bash: line 1: /bad: Permission denied
          1

     Posix requires a syntax error if a brace list has no contents.
     However, not all shells obey this rule; and on shells where empty
     lists are permitted, the effect on `$?' is inconsistent.  To avoid
     problems, ensure that a brace list is never empty.

          $ bash -c 'false; { }; echo $?' || echo $?
          bash: line 1: syntax error near unexpected token `}'
          bash: line 1: `false; { }; echo $?'
          2
          $ zsh -c 'false; { }; echo $?' || echo $?
          1
          $ pdksh -c 'false; { }; echo $?' || echo $?
          0

`break'
     The use of `break 2' etc. is safe.

`case'
     You don't need to quote the argument; no splitting is performed.

     You don't need the final `;;', but you should use it.

     Posix requires support for `case' patterns with opening
     parentheses like this:

          case $file_name in
            (*.c) echo "C source code";;
          esac

     but the `(' in this example is not portable to many Bourne shell
     implementations, which is a pity for those of us using tools that
     rely on balanced parentheses.  For instance, with Solaris
     `/bin/sh':

          $ case foo in (foo) echo foo;; esac
          error-->syntax error: `(' unexpected

     The leading `(' can be omitted safely.  Unfortunately, there are
     contexts where unbalanced parentheses cause other problems, such
     as when using a syntax-highlighting editor that searches for the
     balancing counterpart, or more importantly, when using a case
     statement as an underquoted argument to an Autoconf macro.  *Note
     Balancing Parentheses::, for tradeoffs involved in various styles
     of dealing with unbalanced `)'.

     Zsh handles pattern fragments derived from parameter expansions or
     command substitutions as though quoted:

          $ pat=\?; case aa in ?$pat) echo match;; esac
          $ pat=\?; case a? in ?$pat) echo match;; esac
          match

     Because of a bug in its `fnmatch', Bash fails to properly handle
     backslashes in character classes:

          bash-2.02$ case /tmp in [/\\]*) echo OK;; esac
          bash-2.02$

     This is extremely unfortunate, since you are likely to use this
     code to handle Posix or MS-DOS absolute file names.  To work
     around this bug, always put the backslash first:

          bash-2.02$ case '\TMP' in [\\/]*) echo OK;; esac
          OK
          bash-2.02$ case /tmp in [\\/]*) echo OK;; esac
          OK

     Many Bourne shells cannot handle closing brackets in character
     classes correctly.

     Some shells also have problems with backslash escaping in case you
     do not want to match the backslash: both a backslash and the
     escaped character match this pattern.  To work around this,
     specify the character class in a variable, so that quote removal
     does not apply afterwards, and the special characters don't have
     to be backslash-escaped:

          $ case '\' in [\<]) echo OK;; esac
          OK
          $ scanset='[<]'; case '\' in $scanset) echo OK;; esac
          $

     Even with this, Solaris `ksh' matches a backslash if the set
     contains any of the characters `|', `&', `(', or `)'.

     Conversely, Tru64 `ksh' (circa 2003) erroneously always matches a
     closing parenthesis if not specified in a character class:

          $ case foo in *\)*) echo fail ;; esac
          fail
          $ case foo in ')') echo fail ;; esac
          fail

     Some shells, such as Ash 0.3.8, are confused by an empty
     `case'/`esac':

          ash-0.3.8 $ case foo in esac;
          error-->Syntax error: ";" unexpected (expecting ")")

     Posix requires `case' to give an exit status of 0 if no cases
     match.  However, `/bin/sh' in Solaris 10 does not obey this rule.
     Meanwhile, it is unclear whether a case that matches, but contains
     no statements, must also change the exit status to 0.  The M4sh
     macro `AS_CASE' works around these inconsistencies.

          $ bash -c 'case `false` in ?) ;; esac; echo $?'
          0
          $ /bin/sh -c 'case `false` in ?) ;; esac; echo $?'
          255

`cd'
     Posix 1003.1-2001 requires that `cd' must support the `-L'
     ("logical") and `-P' ("physical") options, with `-L' being the
     default.  However, traditional shells do not support these
     options, and their `cd' command has the `-P' behavior.

     Portable scripts should assume neither option is supported, and
     should assume neither behavior is the default.  This can be a bit
     tricky, since the Posix default behavior means that, for example,
     `ls ..' and `cd ..' may refer to different directories if the
     current logical directory is a symbolic link.  It is safe to use
     `cd DIR' if DIR contains no `..' components.  Also,
     Autoconf-generated scripts check for this problem when computing
     variables like `ac_top_srcdir' (*note Configuration Actions::), so
     it is safe to `cd' to these variables.

     Posix states that behavior is undefined if `cd' is given an
     explicit empty argument.  Some shells do nothing, some change to
     the first entry in `CDPATH', some change to `HOME', and some exit
     the shell rather than returning an error.  Unfortunately, this
     means that if `$var' is empty, then `cd "$var"' is less predictable
     than `cd $var' (at least the latter is well-behaved in all shells
     at changing to `HOME', although this is probably not what you
     wanted in a script).  You should check that a directory name was
     supplied before trying to change locations.

     *Note Special Shell Variables::, for portability problems involving
     `cd' and the `CDPATH' environment variable.  Also please see the
     discussion of the `pwd' command.

`echo'
     The simple `echo' is probably the most surprising source of
     portability troubles.  It is not possible to use `echo' portably
     unless both options and escape sequences are omitted.  Don't
     expect any option.

     Do not use backslashes in the arguments, as there is no consensus
     on their handling.  For `echo '\n' | wc -l', the `sh' of Solaris
     outputs 2, but Bash and Zsh (in `sh' emulation mode) output 1.
     The problem is truly `echo': all the shells understand `'\n'' as
     the string composed of a backslash and an `n'.  Within a command
     substitution, `echo 'string\c'' will mess up the internal state of
     ksh88 on AIX 6.1 so that it will print the first character `s'
     only, followed by a newline, and then entirely drop the output of
     the next echo in a command substitution.

     Because of these problems, do not pass a string containing
     arbitrary characters to `echo'.  For example, `echo "$foo"' is safe
     only if you know that FOO's value cannot contain backslashes and
     cannot start with `-'.

     If this may not be true, `printf' is in general safer and easier
     to use than `echo' and `echo -n'.  Thus, scripts where portability
     is not a major concern should use `printf '%s\n'' whenever `echo'
     could fail, and similarly use `printf %s' instead of `echo -n'.
     For portable shell scripts, instead, it is suggested to use a
     here-document like this:

          cat <<EOF
          $foo
          EOF

     Alternatively, M4sh provides `AS_ECHO' and `AS_ECHO_N' macros
     which choose between various portable implementations: `echo' or
     `print' where they work, `printf' if it is available, or else
     other creative tricks in order to work around the above problems.

`eval'
     The `eval' command is useful in limited circumstances, e.g., using
     commands like `eval table_$key=\$value' and `eval
     value=table_$key' to simulate a hash table when the key is known
     to be alphanumeric.

     You should also be wary of common bugs in `eval' implementations.
     In some shell implementations (e.g., older `ash', OpenBSD 3.8
     `sh', `pdksh' v5.2.14 99/07/13.2, and `zsh' 4.2.5), the arguments
     of `eval' are evaluated in a context where `$?' is 0, so they
     exhibit behavior like this:

          $ false; eval 'echo $?'
          0

     The correct behavior here is to output a nonzero value, but
     portable scripts should not rely on this.

     You should not rely on `LINENO' within `eval'.  *Note Special
     Shell Variables::.

     Note that, even though these bugs are easily avoided, `eval' is
     tricky to use on arbitrary arguments.  It is obviously unwise to
     use `eval $cmd' if the string value of `cmd' was derived from an
     untrustworthy source.  But even if the string value is valid,
     `eval $cmd' might not work as intended, since it causes field
     splitting and file name expansion to occur twice, once for the
     `eval' and once for the command itself.  It is therefore safer to
     use `eval "$cmd"'.  For example, if CMD has the value `cat
     test?.c', `eval $cmd' might expand to the equivalent of `cat
     test;.c' if there happens to be a file named `test;.c' in the
     current directory; and this in turn mistakenly attempts to invoke
     `cat' on the file `test' and then execute the command `.c'.  To
     avoid this problem, use `eval "$cmd"' rather than `eval $cmd'.

     However, suppose that you want to output the text of the evaluated
     command just before executing it.  Assuming the previous example,
     `echo "Executing: $cmd"' outputs `Executing: cat test?.c', but
     this output doesn't show the user that `test;.c' is the actual name
     of the copied file.  Conversely, `eval "echo Executing: $cmd"'
     works on this example, but it fails with `cmd='cat foo >bar'',
     since it mistakenly replaces the contents of `bar' by the string
     `cat foo'.  No simple, general, and portable solution to this
     problem is known.

`exec'
     Posix describes several categories of shell built-ins.  Special
     built-ins (such as `exit') must impact the environment of the
     current shell, and need not be available through `exec'.  All
     other built-ins are regular, and must not propagate variable
     assignments to the environment of the current shell.  However, the
     group of regular built-ins is further distinguished by commands
     that do not require a `PATH' search (such as `cd'), in contrast to
     built-ins that are offered as a more efficient version of
     something that must still be found in a `PATH' search (such as
     `echo').  Posix is not clear on whether `exec' must work with the
     list of 17 utilities that are invoked without a `PATH' search, and
     many platforms lack an executable for some of those built-ins:

          $ sh -c 'exec cd /tmp'
          sh: line 0: exec: cd: not found

     All other built-ins that provide utilities specified by Posix must
     have a counterpart executable that exists on `PATH', although Posix
     allows `exec' to use the built-in instead of the executable.  For
     example, contrast `bash' 3.2 and `pdksh' 5.2.14:

          $ bash -c 'pwd --version' | head -n1
          bash: line 0: pwd: --: invalid option
          pwd: usage: pwd [-LP]
          $ bash -c 'exec pwd --version' | head -n1
          pwd (GNU coreutils) 6.10
          $ pdksh -c 'exec pwd --version' | head -n1
          pdksh: pwd: --: unknown option

     When it is desired to avoid a regular shell built-in, the
     workaround is to use some other forwarding command, such as `env'
     or `nice', that will ensure a path search:

          $ pdksh -c 'exec true --version' | head -n1
          $ pdksh -c 'nice true --version' | head -n1
          true (GNU coreutils) 6.10
          $ pdksh -c 'env true --version' | head -n1
          true (GNU coreutils) 6.10

`exit'
     The default value of `exit' is supposed to be `$?'; unfortunately,
     some shells, such as the DJGPP port of Bash 2.04, just perform
     `exit 0'.

          bash-2.04$ foo=`exit 1` || echo fail
          fail
          bash-2.04$ foo=`(exit 1)` || echo fail
          fail
          bash-2.04$ foo=`(exit 1); exit` || echo fail
          bash-2.04$

     Using `exit $?' restores the expected behavior.

     Some shell scripts, such as those generated by `autoconf', use a
     trap to clean up before exiting.  If the last shell command exited
     with nonzero status, the trap also exits with nonzero status so
     that the invoker can tell that an error occurred.

     Unfortunately, in some shells, such as Solaris `/bin/sh', an exit
     trap ignores the `exit' command's argument.  In these shells, a
     trap cannot determine whether it was invoked by plain `exit' or by
     `exit 1'.  Instead of calling `exit' directly, use the
     `AC_MSG_ERROR' macro that has a workaround for this problem.

`export'
     The builtin `export' dubs a shell variable "environment variable".
     Each update of exported variables corresponds to an update of the
     environment variables.  Conversely, each environment variable
     received by the shell when it is launched should be imported as a
     shell variable marked as exported.

     Alas, many shells, such as Solaris `/bin/sh', IRIX 6.3, IRIX 5.2,
     AIX 4.1.5, and Digital Unix 4.0, forget to `export' the
     environment variables they receive.  As a result, two variables
     coexist: the environment variable and the shell variable.  The
     following code demonstrates this failure:

          #!/bin/sh
          echo $FOO
          FOO=bar
          echo $FOO
          exec /bin/sh $0

     when run with `FOO=foo' in the environment, these shells print
     alternately `foo' and `bar', although they should print only `foo'
     and then a sequence of `bar's.

     Therefore you should `export' again each environment variable that
     you update; the export can occur before or after the assignment.

     Posix is not clear on whether the `export' of an undefined
     variable causes the variable to be defined with the value of an
     empty string, or merely marks any future definition of a variable
     by that name for export.  Various shells behave differently in
     this regard:

          $ sh -c 'export foo; env | grep foo'
          $ ash -c 'export foo; env | grep foo'
          foo=

     Posix requires `export' to honor assignments made as arguments,
     but older shells do not support this, including `/bin/sh' in
     Solaris 10.  Portable scripts should separate assignments and
     exports into different statements.

          $ bash -c 'export foo=bar; echo $foo'
          bar
          $ /bin/sh -c 'export foo=bar; echo $foo'
          /bin/sh: foo=bar: is not an identifier
          $ /bin/sh -c 'export foo; foo=bar; echo $foo'
          bar

`false'
     Don't expect `false' to exit with status 1: in native Solaris
     `/bin/false' exits with status 255.

`for'
     To loop over positional arguments, use:

          for arg
          do
            echo "$arg"
          done

     You may _not_ leave the `do' on the same line as `for', since some
     shells improperly grok:

          for arg; do
            echo "$arg"
          done

     If you want to explicitly refer to the positional arguments, given
     the `$@' bug (*note Shell Substitutions::), use:

          for arg in ${1+"$@"}; do
            echo "$arg"
          done

     But keep in mind that Zsh, even in Bourne shell emulation mode,
     performs word splitting on `${1+"$@"}'; see *note Shell
     Substitutions::, item `$@', for more.

     In Solaris `/bin/sh', when the list of arguments of a `for' loop
     starts with _unquoted_ tokens looking like variable assignments,
     the loop is not executed on those tokens:

          $ /bin/sh -c 'for v in a=b c=d x e=f; do echo $v; done'
          x
          e=f

     Thankfully, quoting the assignment-like tokens, or starting the
     list with other tokens (including unquoted variable expansion that
     results in an assignment-like result), avoids the problem, so it
     is easy to work around:

          $ /bin/sh -c 'for v in "a=b"; do echo $v; done'
          a=b
          $ /bin/sh -c 'x=a=b; for v in $x c=d; do echo $v; done'
          a=b
          c=d

`if'
     Using `!' is not portable.  Instead of:

          if ! cmp -s file file.new; then
            mv file.new file
          fi

     use:

          if cmp -s file file.new; then :; else
            mv file.new file
          fi

     Or, especially if the "else" branch is short, you can use `||'.
     In M4sh, the `AS_IF' macro provides an easy way to write these
     kinds of conditionals:

          AS_IF([cmp -s file file.new], [], [mv file.new file])

     This is especially useful in other M4 macros, where the "then" and
     "else" branches might be macro arguments.

     Some very old shells did not reset the exit status from an `if'
     with no `else':

          $ if (exit 42); then true; fi; echo $?
          42

     whereas a proper shell should have printed `0'.  But this is no
     longer a portability problem; any shell that supports functions
     gets it correct.  However, it explains why some makefiles have
     lengthy constructs:

          if test -f "$file"; then
            install "$file" "$dest"
          else
            :
          fi

`printf'
     A format string starting with a `-' can cause problems.  Bash
     interprets it as an option and gives an error.  And `--' to mark
     the end of options is not good in the NetBSD Almquist shell (e.g.,
     0.4.6) which takes that literally as the format string.  Putting
     the `-' in a `%c' or `%s' is probably easiest:

          printf %s -foo

     Bash 2.03 mishandles an escape sequence that happens to evaluate
     to `%':

          $ printf '\045'
          bash: printf: `%': missing format character

     Large outputs may cause trouble.  On Solaris 2.5.1 through 10, for
     example, `/usr/bin/printf' is buggy, so when using `/bin/sh' the
     command `printf %010000x 123' normally dumps core.

     Since `printf' is not always a shell builtin, there is a potential
     speed penalty for using `printf '%s\n'' as a replacement for an
     `echo' that does not interpret `\' or leading `-'. With Solaris
     `ksh', it is possible to use `print -r --' for this role instead.

     *Note Limitations of Shell Builtins: echo for a discussion of
     portable alternatives to both `printf' and `echo'.

`pwd'
     With modern shells, plain `pwd' outputs a "logical" directory
     name, some of whose components may be symbolic links.  These
     directory names are in contrast to "physical" directory names,
     whose components are all directories.

     Posix 1003.1-2001 requires that `pwd' must support the `-L'
     ("logical") and `-P' ("physical") options, with `-L' being the
     default.  However, traditional shells do not support these
     options, and their `pwd' command has the `-P' behavior.

     Portable scripts should assume neither option is supported, and
     should assume neither behavior is the default.  Also, on many hosts
     `/bin/pwd' is equivalent to `pwd -P', but Posix does not require
     this behavior and portable scripts should not rely on it.

     Typically it's best to use plain `pwd'.  On modern hosts this
     outputs logical directory names, which have the following
     advantages:

        * Logical names are what the user specified.

        * Physical names may not be portable from one installation host
          to another due to network file system gymnastics.

        * On modern hosts `pwd -P' may fail due to lack of permissions
          to some parent directory, but plain `pwd' cannot fail for this
          reason.

     Also please see the discussion of the `cd' command.

`read'
     No options are portable, not even support `-r' (Solaris `/bin/sh'
     for example).  Tru64/OSF 5.1 `sh' treats `read' as a special
     built-in, so it may exit if input is redirected from a
     non-existent or unreadable file.

`set'
     With the FreeBSD 6.0 shell, the `set' command (without any
     options) does not sort its output.

     The `set' builtin faces the usual problem with arguments starting
     with a dash.  Modern shells such as Bash or Zsh understand `--' to
     specify the end of the options (any argument after `--' is a
     parameter, even `-x' for instance), but many traditional shells
     (e.g., Solaris 10 `/bin/sh') simply stop option processing as soon
     as a non-option argument is found.  Therefore, use `dummy' or
     simply `x' to end the option processing, and use `shift' to pop it
     out:

          set x $my_list; shift

     Avoid `set -', e.g., `set - $my_list'.  Posix no longer requires
     support for this command, and in traditional shells `set -
     $my_list' resets the `-v' and `-x' options, which makes scripts
     harder to debug.

     Some nonstandard shells do not recognize more than one option
     (e.g., `set -e -x' assigns `-x' to the command line).  It is
     better to combine them:

          set -ex

     The option `-e' has historically been underspecified, with enough
     ambiguities to cause numerous differences across various shell
     implementations; see for example this overview
     (http://www.in-ulm.de/~mascheck/various/set-e/), or this link
     (http://www.austingroupbugs.net/view.php?id=52), documenting a
     change to Posix 2008 to match `ksh88' behavior.  Note that mixing
     `set -e' and shell functions is asking for surprises:

          set -e
          doit()
          {
            rm file
            echo one
          }
          doit || echo two

     According to the recommendation, `one' should always be output
     regardless of whether the `rm' failed, because it occurs within
     the body of the shell function `doit' invoked on the left side of
     `||', where the effects of `set -e' are not enforced.  Likewise,
     `two' should never be printed, since the failure of `rm' does not
     abort the function, such that the status of `doit' is 0.

     The BSD shell has had several problems with the `-e' option.
     Older versions of the BSD shell (circa 1990) mishandled `&&',
     `||', `if', and `case' when `-e' was in effect, causing the shell
     to exit unexpectedly in some cases.  This was particularly a
     problem with makefiles, and led to circumlocutions like `sh -c
     'test -f file || touch file'', where the seemingly-unnecessary `sh
     -c '...'' wrapper works around the bug (*note Failure in Make
     Rules::).

     Even relatively-recent versions of the BSD shell (e.g., OpenBSD
     3.4) wrongly exit with `-e' if the last command within a compound
     statement fails and is guarded by an `&&' only.  For example:

          #! /bin/sh
          set -e
          foo=''
          test -n "$foo" && exit 1
          echo one
          if :; then
            test -n "$foo" && exit 1
            echo two
            test -n "$foo" && exit 1
          fi
          echo three

     does not print `three'.  One workaround is to change the last
     instance of `test -n "$foo" && exit 1' to be `if test -n "$foo";
     then exit 1; fi' instead.  Another possibility is to warn BSD
     users not to use `sh -e'.

     When `set -e' is in effect, a failed command substitution in
     Solaris `/bin/sh' cannot be ignored, even with `||'.

          $ /bin/sh -c 'set -e; foo=`false` || echo foo; echo bar'
          $ bash -c 'set -e; foo=`false` || echo foo; echo bar'
          foo
          bar

     Moreover, a command substitution, successful or not, causes this
     shell to exit from a failing outer command even in presence of an
     `&&' list:

          $ bash -c 'set -e; false `true` && echo notreached; echo ok'
          ok
          $ sh -c 'set -e; false `true` && echo notreached; echo ok'
          $

     Portable scripts should not use `set -e' if `trap' is used to
     install an exit handler.  This is because Tru64/OSF 5.1 `sh'
     sometimes enters the trap handler with the exit status of the
     command prior to the one that triggered the errexit handler:

          $ sh -ec 'trap '\''echo $?'\'' 0; false'
          0
          $ sh -c 'set -e; trap '\''echo $?'\'' 0; false'
          1

     Thus, when writing a script in M4sh, rather than trying to rely on
     `set -e', it is better to append `|| AS_EXIT' to any statement
     where it is desirable to abort on failure.

     Job control is not provided by all shells, so the use of `set -m'
     or `set -b' must be done with care.  When using `zsh' in native
     mode, asynchronous notification (`set -b') is enabled by default,
     and using `emulate sh' to switch to Posix mode does not clear this
     setting (although asynchronous notification has no impact unless
     job monitoring is also enabled).  Also, `zsh' 4.3.10 and earlier
     have a bug where job control can be manipulated in interactive
     shells, but not in subshells or scripts.  Furthermore, some
     shells, like `pdksh', fail to treat subshells as interactive, even
     though the parent shell was.

          $ echo $ZSH_VERSION
          4.3.10
          $ set -m; echo $?
          0
          $ zsh -c 'set -m; echo $?'
          set: can't change option: -m
          $ (set -m); echo $?
          set: can't change option: -m
          1
          $ pdksh -ci 'echo $-; (echo $-)'
          cim
          c

     Use of `set -n' (typically via `sh -n script') to validate a
     script is not foolproof.  Modern `ksh93' tries to be helpful by
     informing you about better syntax, but switching the script to use
     the suggested syntax in order to silence the warnings would render
     the script no longer portable to older shells:

          $ ksh -nc '``'
          ksh: warning: line 1: `...` obsolete, use $(...)
          0

     Furthermore, on ancient hosts, such as SunOS 4, `sh -n' could go
     into an infinite loop; even with that bug fixed, Solaris 8
     `/bin/sh' takes extremely long to parse large scripts.  Autoconf
     itself uses `sh -n' within its testsuite to check that correct
     scripts were generated, but only after first probing for other
     shell features (such as `test -n "${BASH_VERSION+set}"') that
     indicate a reasonably fast and working implementation.

`shift'
     Not only is `shift'ing a bad idea when there is nothing left to
     shift, but in addition it is not portable: the shell of MIPS
     RISC/OS 4.52 refuses to do it.

     Don't use `shift 2' etc.; while it in the SVR1 shell (1983), it is
     also absent in many pre-Posix shells.

`source'
     This command is not portable, as Posix does not require it; use
     `.' instead.

`test'
     The `test' program is the way to perform many file and string
     tests.  It is often invoked by the alternate name `[', but using
     that name in Autoconf code is asking for trouble since it is an M4
     quote character.

     The `-a', `-o', `(', and `)' operands are not present in all
     implementations, and have been marked obsolete by Posix 2008.
     This is because there are inherent ambiguities in using them.  For
     example, `test "$1" -a "$2"' looks like a binary operator to check
     whether two strings are both non-empty, but if `$1' is the literal
     `!', then some implementations of `test' treat it as a negation of
     the unary operator `-a'.

     Thus, portable uses of `test' should never have more than four
     arguments, and scripts should use shell constructs like `&&' and
     `||' instead.  If you combine `&&' and `||' in the same statement,
     keep in mind that they have equal precedence, so it is often
     better to parenthesize even when this is redundant.  For example:

          # Not portable:
          test "X$a" = "X$b" -a \
            '(' "X$c" != "X$d" -o "X$e" = "X$f" ')'

          # Portable:
          test "X$a" = "X$b" &&
            { test "X$c" != "X$d" || test "X$e" = "X$f"; }

     `test' does not process options like most other commands do; for
     example, it does not recognize the `--' argument as marking the
     end of options.

     It is safe to use `!' as a `test' operator.  For example, `if test
     ! -d foo; ...' is portable even though `if ! test -d foo; ...' is
     not.

`test' (files)
     To enable `configure' scripts to support cross-compilation, they
     shouldn't do anything that tests features of the build system
     instead of the host system.  But occasionally you may find it
     necessary to check whether some arbitrary file exists.  To do so,
     use `test -f', `test -r', or `test -x'.  Do not use `test -e',
     because Solaris 10 `/bin/sh' lacks it.  To test for symbolic links
     on systems that have them, use `test -h' rather than `test -L';
     either form conforms to Posix 1003.1-2001, but older shells like
     Solaris 8 `/bin/sh' support only `-h'.

     For historical reasons, Posix reluctantly allows implementations of
     `test -x' that will succeed for the root user, even if no execute
     permissions are present.  Furthermore, shells do not all agree on
     whether Access Control Lists should affect `test -r', `test -w',
     and `test -x'; some shells base test results strictly on the
     current user id compared to file owner and mode, as if by
     `stat(2)'; while other shells base test results on whether the
     current user has the given right, even if that right is only
     granted by an ACL, as if by `faccessat(2)'.  Furthermore, there is
     a classic time of check to time of use race between any use of
     `test' followed by operating on the just-checked file.  Therefore,
     it is a good idea to write scripts that actually attempt an
     operation, and are prepared for the resulting failure if
     permission is denied, rather than trying to avoid an operation
     based solely on whether `test' guessed that it might not be
     permitted.

`test' (strings)
     Posix says that `test "STRING"' succeeds if STRING is not null,
     but this usage is not portable to traditional platforms like
     Solaris 10 `/bin/sh', which mishandle strings like `!' and `-n'.

     Posix also says that `test ! "STRING"', `test -n "STRING"' and
     `test -z "STRING"' work with any string, but many shells (such as
     Solaris, AIX 3.2, UNICOS 10.0.0.6, Digital Unix 4, etc.) get
     confused if STRING looks like an operator:

          $ test -n =
          test: argument expected
          $ test ! -n
          test: argument expected
          $ test -z ")"; echo $?
          0

     Similarly, Posix says that both `test "STRING1" = "STRING2"' and
     `test "STRING1" != "STRING2"' work for any pairs of strings, but
     in practice this is not true for troublesome strings that look
     like operators or parentheses, or that begin with `-'.

     It is best to protect such strings with a leading `X', e.g., `test
     "XSTRING" != X' rather than `test -n "STRING"' or `test !
     "STRING"'.

     It is common to find variations of the following idiom:

          test -n "`echo $ac_feature | sed 's/[-a-zA-Z0-9_]//g'`" &&
            ACTION

     to take an action when a token matches a given pattern.  Such
     constructs should be avoided by using:

          case $ac_feature in
            [!-a-zA-Z0-9_]) ACTION;;
          esac

     If the pattern is a complicated regular expression that cannot be
     expressed as a shell pattern, use something like this instead:

          expr "X$ac_feature" : 'X.*[^-a-zA-Z0-9_]' >/dev/null &&
            ACTION

     `expr "XFOO" : "XBAR"' is more robust than `echo "XFOO" | grep
     "^XBAR"', because it avoids problems when `FOO' contains
     backslashes.

`trap'
     It is safe to trap at least the signals 1, 2, 13, and 15.  You can
     also trap 0, i.e., have the `trap' run when the script ends
     (either via an explicit `exit', or the end of the script).  The
     trap for 0 should be installed outside of a shell function, or AIX
     5.3 `/bin/sh' will invoke the trap at the end of this function.

     Posix says that `trap - 1 2 13 15' resets the traps for the
     specified signals to their default values, but many common shells
     (e.g., Solaris `/bin/sh') misinterpret this and attempt to execute
     a "command" named `-' when the specified conditions arise.  Posix
     2008 also added a requirement to support `trap 1 2 13 15' to reset
     traps, as this is supported by a larger set of shells, but there
     are still shells like `dash' that mistakenly try to execute `1'
     instead of resetting the traps.  Therefore, there is no portable
     workaround, except for `trap - 0', for which `trap '' 0' is a
     portable substitute.

     Although Posix is not absolutely clear on this point, it is widely
     admitted that when entering the trap `$?' should be set to the exit
     status of the last command run before the trap.  The ambiguity can
     be summarized as: "when the trap is launched by an `exit', what is
     the _last_ command run: that before `exit', or `exit' itself?"

     Bash considers `exit' to be the last command, while Zsh and
     Solaris `/bin/sh' consider that when the trap is run it is _still_
     in the `exit', hence it is the previous exit status that the trap
     receives:

          $ cat trap.sh
          trap 'echo $?' 0
          (exit 42); exit 0
          $ zsh trap.sh
          42
          $ bash trap.sh
          0

     The portable solution is then simple: when you want to `exit 42',
     run `(exit 42); exit 42', the first `exit' being used to set the
     exit status to 42 for Zsh, and the second to trigger the trap and
     pass 42 as exit status for Bash.  In M4sh, this is covered by using
     `AS_EXIT'.

     The shell in FreeBSD 4.0 has the following bug: `$?' is reset to 0
     by empty lines if the code is inside `trap'.

          $ trap 'false

          echo $?' 0
          $ exit
          0

     Fortunately, this bug only affects `trap'.

     Several shells fail to execute an exit trap that is defined inside
     a subshell, when the last command of that subshell is not a
     builtin.  A workaround is to use `exit $?' as the shell builtin.

          $ bash -c '(trap "echo hi" 0; /bin/true)'
          hi
          $ /bin/sh -c '(trap "echo hi" 0; /bin/true)'
          $ /bin/sh -c '(trap "echo hi" 0; /bin/true; exit $?)'
          hi

     Likewise, older implementations of `bash' failed to preserve `$?'
     across an exit trap consisting of a single cleanup command.

          $ bash -c 'trap "/bin/true" 0; exit 2'; echo $?
          2
          $ bash-2.05b -c 'trap "/bin/true" 0; exit 2'; echo $?
          0
          $ bash-2.05b -c 'trap ":; /bin/true" 0; exit 2'; echo $?
          2

`true'
     Don't worry: as far as we know `true' is portable.  Nevertheless,
     it's not always a builtin (e.g., Bash 1.x), and the portable shell
     community tends to prefer using `:'.  This has a funny side
     effect: when asked whether `false' is more portable than `true'
     Alexandre Oliva answered:

          In a sense, yes, because if it doesn't exist, the shell will
          produce an exit status of failure, which is correct for
          `false', but not for `true'.

     Remember that even though `:' ignores its arguments, it still takes
     time to compute those arguments.  It is a good idea to use double
     quotes around any arguments to `:' to avoid time spent in field
     splitting and file name expansion.

`unset'
     In some nonconforming shells (e.g., Solaris 10 `/bin/ksh' and
     `/usr/xpg4/bin/sh', NetBSD 5.99.43 sh, or Bash 2.05a), `unset FOO'
     fails when `FOO' is not set.  This can interfere with `set -e'
     operation.  You can use

          FOO=; unset FOO

     if you are not sure that `FOO' is set.

     A few ancient shells lack `unset' entirely.  For some variables
     such as `PS1', you can use a neutralizing value instead:

          PS1='$ '

     Usually, shells that do not support `unset' need less effort to
     make the environment sane, so for example is not a problem if you
     cannot unset `CDPATH' on those shells.  However, Bash 2.01
     mishandles `unset MAIL' and `unset MAILPATH' in some cases and
     dumps core.  So, you should do something like

          ( (unset MAIL) || exit 1) >/dev/null 2>&1 && unset MAIL || :

     *Note Special Shell Variables::, for some neutralizing values.
     Also, see *note Limitations of Builtins: export, for the case of
     environment variables.

`wait'
     The exit status of `wait' is not always reliable.

==============================================================================
File: autoconf.info,  Node: |Limitations_of_Usual_Tools|,  Prev: Limitations of Builtins,  Up: Portable Shell
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Limitations_of_Usual_Tools*

11.15 Limitations of Usual Tools
==========----------------------

The small set of tools you can expect to find on any machine can still
include some limitations you should be aware of.

`awk'
     Don't leave white space before the opening parenthesis in a user
     function call.  Posix does not allow this and GNU Awk rejects it:

          $ gawk 'function die () { print "Aaaaarg!"  }
                  BEGIN { die () }'
          gawk: cmd. line:2:         BEGIN { die () }
          gawk: cmd. line:2:                      ^ parse error
          $ gawk 'function die () { print "Aaaaarg!"  }
                  BEGIN { die() }'
          Aaaaarg!

     Posix says that if a program contains only `BEGIN' actions, and
     contains no instances of `getline', then the program merely
     executes the actions without reading input.  However, traditional
     Awk implementations (such as Solaris 10 `awk') read and discard
     input in this case.  Portable scripts can redirect input from
     `/dev/null' to work around the problem.  For example:

          awk 'BEGIN {print "hello world"}' </dev/null

     Posix says that in an `END' action, `$NF' (and presumably, `$1')
     retain their value from the last record read, if no intervening
     `getline' occurred.  However, some implementations (such as
     Solaris 10 `/usr/bin/awk', `nawk', or Darwin `awk') reset these
     variables.  A workaround is to use an intermediate variable prior
     to the `END' block.  For example:

          $ cat end.awk
          { tmp = $1 }
          END { print "a", $1, $NF, "b", tmp }
          $ echo 1 | awk -f end.awk
          a   b 1
          $ echo 1 | gawk -f end.awk
          a 1 1 b 1

     If you want your program to be deterministic, don't depend on `for'
     on arrays:

          $ cat for.awk
          END {
            arr["foo"] = 1
            arr["bar"] = 1
            for (i in arr)
              print i
          }
          $ gawk -f for.awk </dev/null
          foo
          bar
          $ nawk -f for.awk </dev/null
          bar
          foo

     Some Awk implementations, such as HP-UX 11.0's native one,
     mishandle anchors:

          $ echo xfoo | $AWK '/foo|^bar/ { print }'
          $ echo bar | $AWK '/foo|^bar/ { print }'
          bar
          $ echo xfoo | $AWK '/^bar|foo/ { print }'
          xfoo
          $ echo bar | $AWK '/^bar|foo/ { print }'
          bar

     Either do not depend on such patterns (i.e., use `/^(.*foo|bar)/',
     or use a simple test to reject such implementations.

     On `ia64-hp-hpux11.23', Awk mishandles `printf' conversions after
     `%u':

          $ awk 'BEGIN { printf "%u %d\n", 0, -1 }'
          0 0

     AIX version 5.2 has an arbitrary limit of 399 on the length of
     regular expressions and literal strings in an Awk program.

     Traditional Awk implementations derived from Unix version 7, such
     as Solaris `/bin/awk', have many limitations and do not conform to
     Posix.  Nowadays `AC_PROG_AWK' (*note Particular Programs::) finds
     you an Awk that doesn't have these problems, but if for some
     reason you prefer not to use `AC_PROG_AWK' you may need to address
     them.  For more detailed descriptions, see *note `awk' language
     history: (gawk)Language History.

     Traditional Awk does not support multidimensional arrays or
     user-defined functions.

     Traditional Awk does not support the `-v' option.  You can use
     assignments after the program instead, e.g., `$AWK '{print v $1}'
     v=x'; however, don't forget that such assignments are not
     evaluated until they are encountered (e.g., after any `BEGIN'
     action).

     Traditional Awk does not support the keywords `delete' or `do'.

     Traditional Awk does not support the expressions `A?B:C', `!A',
     `A^B', or `A^=B'.

     Traditional Awk does not support the predefined `CONVFMT' or
     `ENVIRON' variables.

     Traditional Awk supports only the predefined functions `exp',
     `index', `int', `length', `log', `split', `sprintf', `sqrt', and
     `substr'.

     Traditional Awk `getline' is not at all compatible with Posix;
     avoid it.

     Traditional Awk has `for (i in a) ...' but no other uses of the
     `in' keyword.  For example, it lacks `if (i in a) ...'.

     In code portable to both traditional and modern Awk, `FS' must be a
     string containing just one ordinary character, and similarly for
     the field-separator argument to `split'.

     Traditional Awk has a limit of 99 fields in a record.  Since some
     Awk implementations, like Tru64's, split the input even if you
     don't refer to any field in the script, to circumvent this
     problem, set `FS' to an unusual character and use `split'.

     Traditional Awk has a limit of at most 99 bytes in a number
     formatted by `OFMT'; for example, `OFMT="%.300e"; print 0.1;'
     typically dumps core.

     The original version of Awk had a limit of at most 99 bytes per
     `split' field, 99 bytes per `substr' substring, and 99 bytes per
     run of non-special characters in a `printf' format, but these bugs
     have been fixed on all practical hosts that we know of.

     HP-UX 11.00 and IRIX 6.5 Awk require that input files have a line
     length of at most 3070 bytes.

`basename'
     Not all hosts have a working `basename'.  You can use `expr'
     instead.

`cat'
     Don't rely on any option.

`cc'
     The command `cc -c foo.c' traditionally produces an object file
     named `foo.o'.  Most compilers allow `-c' to be combined with `-o'
     to specify a different object file name, but Posix does not
     require this combination and a few compilers lack support for it.
     *Note C Compiler::, for how GNU Make tests for this feature with
     `AC_PROG_CC_C_O'.

     When a compilation such as `cc -o foo foo.c' fails, some compilers
     (such as CDS on Reliant Unix) leave a `foo.o'.

     HP-UX `cc' doesn't accept `.S' files to preprocess and assemble.
     `cc -c foo.S' appears to succeed, but in fact does nothing.

     The default executable, produced by `cc foo.c', can be

        * `a.out' -- usual Posix convention.

        * `b.out' -- i960 compilers (including `gcc').

vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
