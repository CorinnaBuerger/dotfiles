variables defined explicitly for that target, and before target-specific
variables defined for the parent target.

==============================================================================
File: make.info,  Node: |Suppressing_Inheritance|,  Next: |Special_Variables|,  Prev: |Pattern_specific|,  Up: |Using_Variables|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Suppressing_Inheritance*

6.13 Suppressing Inheritance
----------------------------

As described in previous sections, 'make' variables are inherited by
prerequisites.  This capability allows you to modify the behavior of a
prerequisite based on which targets caused it to be rebuilt.  For
example, you might set a target-specific variable on a 'debug' target,
then running 'make debug' will cause that variable to be inherited by
all prerequisites of 'debug', while just running 'make all' (for
example) would not have that assignment.

   Sometimes, however, you may not want a variable to be inherited.  For
these situations, 'make' provides the 'private' modifier.  Although this
modifier can be used with any variable assignment, it makes the most
sense with target- and pattern-specific variables.  Any variable marked
'private' will be visible to its local target but will not be inherited
by prerequisites of that target.  A global variable marked 'private'
will be visible in the global scope but will not be inherited by any
target, and hence will not be visible in any recipe.

   As an example, consider this makefile:
     EXTRA_CFLAGS =

     prog: private EXTRA_CFLAGS = -L/usr/local/lib
     prog: a.o b.o

   Due to the 'private' modifier, 'a.o' and 'b.o' will not inherit the
'EXTRA_CFLAGS' variable assignment from the 'prog' target.

==============================================================================
File: make.info,  Node: |Special_Variables|,  Prev: |Suppressing_Inheritance|,  Up: |Using_Variables|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Special_Variables*

6.14 Other Special Variables
----------------------------

GNU 'make' supports some variables that have special properties.

'MAKEFILE_LIST'
     Contains the name of each makefile that is parsed by 'make', in the
     order in which it was parsed.  The name is appended just before
     'make' begins to parse the makefile.  Thus, if the first thing a
     makefile does is examine the last word in this variable, it will be
     the name of the current makefile.  Once the current makefile has
     used 'include', however, the last word will be the just-included
     makefile.

     If a makefile named 'Makefile' has this content:

          name1 := $(lastword $(MAKEFILE_LIST))

          include inc.mk

          name2 := $(lastword $(MAKEFILE_LIST))

          all:
                  @echo name1 = $(name1)
                  @echo name2 = $(name2)

     then you would expect to see this output:

          name1 = Makefile
          name2 = inc.mk

'.DEFAULT_GOAL'
     Sets the default goal to be used if no targets were specified on
     the command line (*note Arguments to Specify the Goals: Goals.).
     The '.DEFAULT_GOAL' variable allows you to discover the current
     default goal, restart the default goal selection algorithm by
     clearing its value, or to explicitly set the default goal.  The
     following example illustrates these cases:

          # Query the default goal.
          ifeq ($(.DEFAULT_GOAL),)
            $(warning no default goal is set)
          endif

          .PHONY: foo
          foo: ; @echo $@

          $(warning default goal is $(.DEFAULT_GOAL))

          # Reset the default goal.
          .DEFAULT_GOAL :=

          .PHONY: bar
          bar: ; @echo $@

          $(warning default goal is $(.DEFAULT_GOAL))

          # Set our own.
          .DEFAULT_GOAL := foo

     This makefile prints:

          no default goal is set
          default goal is foo
          default goal is bar
          foo

     Note that assigning more than one target name to '.DEFAULT_GOAL' is
     invalid and will result in an error.

'MAKE_RESTARTS'
     This variable is set only if this instance of 'make' has restarted
     (*note How Makefiles Are Remade: Remaking Makefiles.): it will
     contain the number of times this instance has restarted.  Note this
     is not the same as recursion (counted by the 'MAKELEVEL' variable).
     You should not set, modify, or export this variable.

'MAKE_TERMOUT'
'MAKE_TERMERR'
     When 'make' starts it will check whether stdout and stderr will
     show their output on a terminal.  If so, it will set 'MAKE_TERMOUT'
     and 'MAKE_TERMERR', respectively, to the name of the terminal
     device (or 'true' if this cannot be determined).  If set these
     variables will be marked for export.  These variables will not be
     changed by 'make' and they will not be modified if already set.

     These values can be used (particularly in combination with output
     synchronization (*note Output During Parallel Execution: Parallel
     Output.) to determine whether 'make' itself is writing to a
     terminal; they can be tested to decide whether to force recipe
     commands to generate colorized output for example.

     If you invoke a sub-'make' and redirect its stdout or stderr it is
     your responsibility to reset or unexport these variables as well,
     if your makefiles rely on them.

'.RECIPEPREFIX'
     The first character of the value of this variable is used as the
     character make assumes is introducing a recipe line.  If the
     variable is empty (as it is by default) that character is the
     standard tab character.  For example, this is a valid makefile:

          .RECIPEPREFIX = >
          all:
          > @echo Hello, world

     The value of '.RECIPEPREFIX' can be changed multiple times; once
     set it stays in effect for all rules parsed until it is modified.

'.VARIABLES'
     Expands to a list of the _names_ of all global variables defined so
     far.  This includes variables which have empty values, as well as
     built-in variables (*note Variables Used by Implicit Rules:
     Implicit Variables.), but does not include any variables which are
     only defined in a target-specific context.  Note that any value you
     assign to this variable will be ignored; it will always return its
     special value.

'.FEATURES'
     Expands to a list of special features supported by this version of
     'make'.  Possible values include, but are not limited to:

     'archives'
          Supports 'ar' (archive) files using special file name syntax.
          *Note Using 'make' to Update Archive Files: Archives.

     'check-symlink'
          Supports the '-L' ('--check-symlink-times') flag.  *Note
          Summary of Options: Options Summary.

     'else-if'
          Supports "else if" non-nested conditionals.  *Note Syntax of
          Conditionals: Conditional Syntax.

     'jobserver'
          Supports "job server" enhanced parallel builds.  *Note
          Parallel Execution: Parallel.

     'oneshell'
          Supports the '.ONESHELL' special target.  *Note Using One
          Shell: One Shell.

     'order-only'
          Supports order-only prerequisites.  *Note Types of
          Prerequisites: Prerequisite Types.

     'second-expansion'
          Supports secondary expansion of prerequisite lists.

     'shortest-stem'
          Uses the "shortest stem" method of choosing which pattern, of
          multiple applicable options, will be used.  *Note How Patterns
          Match: Pattern Match.

     'target-specific'
          Supports target-specific and pattern-specific variable
          assignments.  *Note Target-specific Variable Values:
          Target-specific.

     'undefine'
          Supports the 'undefine' directive.  *Note Undefine
          Directive::.

     'guile'
          Has GNU Guile available as an embedded extension language.
          *Note GNU Guile Integration: Guile Integration.

     'load'
          Supports dynamically loadable objects for creating custom
          extensions.  *Note Loading Dynamic Objects: Loading Objects.

'.INCLUDE_DIRS'
     Expands to a list of directories that 'make' searches for included
     makefiles (*note Including Other Makefiles: Include.).

==============================================================================
File: make.info,  Node: |Conditionals|,  Next: |Functions|,  Prev: |Using_Variables|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Conditionals*

7 Conditional Parts of Makefiles
================================

A "conditional" directive causes part of a makefile to be obeyed or
ignored depending on the values of variables.  Conditionals can compare
the value of one variable to another, or the value of a variable to a
constant string.  Conditionals control what 'make' actually "sees" in
the makefile, so they _cannot_ be used to control recipes at the time of
execution.

MENU

* |Conditional_Example|::         Example of a conditional
* |Conditional_Syntax|::          The syntax of conditionals.
* |Testing_Flags|::               Conditionals that test flags.

==============================================================================
File: make.info,  Node: |Conditional_Example|,  Next: |Conditional_Syntax|,  Prev: |Conditionals|,  Up: |Conditionals|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Conditional_Example*

7.1 Example of a Conditional
----------------------------

The following example of a conditional tells 'make' to use one set of
libraries if the 'CC' variable is 'gcc', and a different set of
libraries otherwise.  It works by controlling which of two recipe lines
will be used for the rule.  The result is that 'CC=gcc' as an argument
to 'make' changes not only which compiler is used but also which
libraries are linked.

     libs_for_gcc = -lgnu
     normal_libs =

     foo: $(objects)
     ifeq ($(CC),gcc)
             $(CC) -o foo $(objects) $(libs_for_gcc)
     else
             $(CC) -o foo $(objects) $(normal_libs)
     endif

   This conditional uses three directives: one 'ifeq', one 'else' and
one 'endif'.

   The 'ifeq' directive begins the conditional, and specifies the
condition.  It contains two arguments, separated by a comma and
surrounded by parentheses.  Variable substitution is performed on both
arguments and then they are compared.  The lines of the makefile
following the 'ifeq' are obeyed if the two arguments match; otherwise
they are ignored.

   The 'else' directive causes the following lines to be obeyed if the
previous conditional failed.  In the example above, this means that the
second alternative linking command is used whenever the first
alternative is not used.  It is optional to have an 'else' in a
conditional.

   The 'endif' directive ends the conditional.  Every conditional must
end with an 'endif'.  Unconditional makefile text follows.

   As this example illustrates, conditionals work at the textual level:
the lines of the conditional are treated as part of the makefile, or
ignored, according to the condition.  This is why the larger syntactic
units of the makefile, such as rules, may cross the beginning or the end
of the conditional.

   When the variable 'CC' has the value 'gcc', the above example has
this effect:

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs_for_gcc)

When the variable 'CC' has any other value, the effect is this:

     foo: $(objects)
             $(CC) -o foo $(objects) $(normal_libs)

   Equivalent results can be obtained in another way by conditionalizing
a variable assignment and then using the variable unconditionally:

     libs_for_gcc = -lgnu
     normal_libs =

     ifeq ($(CC),gcc)
       libs=$(libs_for_gcc)
     else
       libs=$(normal_libs)
     endif

     foo: $(objects)
             $(CC) -o foo $(objects) $(libs)

==============================================================================
File: make.info,  Node: |Conditional_Syntax|,  Next: |Testing_Flags|,  Prev: |Conditional_Example|,  Up: |Conditionals|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Conditional_Syntax*

7.2 Syntax of Conditionals
--------------------------

The syntax of a simple conditional with no 'else' is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     endif

The TEXT-IF-TRUE may be any lines of text, to be considered as part of
the makefile if the condition is true.  If the condition is false, no
text is used instead.

   The syntax of a complex conditional is as follows:

     CONDITIONAL-DIRECTIVE
     TEXT-IF-TRUE
     else
     TEXT-IF-FALSE
     endif

   or:

     CONDITIONAL-DIRECTIVE-ONE
     TEXT-IF-ONE-IS-TRUE
     else CONDITIONAL-DIRECTIVE-TWO
     TEXT-IF-TWO-IS-TRUE
     else
     TEXT-IF-ONE-AND-TWO-ARE-FALSE
     endif

There can be as many "'else' CONDITIONAL-DIRECTIVE" clauses as
necessary.  Once a given condition is true, TEXT-IF-TRUE is used and no
other clause is used; if no condition is true then TEXT-IF-FALSE is
used.  The TEXT-IF-TRUE and TEXT-IF-FALSE can be any number of lines of
text.

   The syntax of the CONDITIONAL-DIRECTIVE is the same whether the
conditional is simple or complex; after an 'else' or not.  There are
four different directives that test different conditions.  Here is a
table of them:

'ifeq (ARG1, ARG2)'
'ifeq 'ARG1' 'ARG2''
'ifeq "ARG1" "ARG2"'
'ifeq "ARG1" 'ARG2''
'ifeq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare them.
     If they are identical, the TEXT-IF-TRUE is effective; otherwise,
     the TEXT-IF-FALSE, if any, is effective.

     Often you want to test if a variable has a non-empty value.  When
     the value results from complex expansions of variables and
     functions, expansions you would consider empty may actually contain
     whitespace characters and thus are not seen as empty.  However, you
     can use the 'strip' function (*note Text Functions::) to avoid
     interpreting whitespace as a non-empty value.  For example:

          ifeq ($(strip $(foo)),)
          TEXT-IF-EMPTY
          endif

     will evaluate TEXT-IF-EMPTY even if the expansion of '$(foo)'
     contains whitespace characters.

'ifneq (ARG1, ARG2)'
'ifneq 'ARG1' 'ARG2''
'ifneq "ARG1" "ARG2"'
'ifneq "ARG1" 'ARG2''
'ifneq 'ARG1' "ARG2"'
     Expand all variable references in ARG1 and ARG2 and compare them.
     If they are different, the TEXT-IF-TRUE is effective; otherwise,
     the TEXT-IF-FALSE, if any, is effective.

'ifdef VARIABLE-NAME'
     The 'ifdef' form takes the _name_ of a variable as its argument,
     not a reference to a variable.  If the value of that variable has a
     non-empty value, the TEXT-IF-TRUE is effective; otherwise, the
     TEXT-IF-FALSE, if any, is effective.  Variables that have never
     been defined have an empty value.  The text VARIABLE-NAME is
     expanded, so it could be a variable or function that expands to the
     name of a variable.  For example:

          bar = true
          foo = bar
          ifdef $(foo)
          frobozz = yes
          endif

     The variable reference '$(foo)' is expanded, yielding 'bar', which
     is considered to be the name of a variable.  The variable 'bar' is
     not expanded, but its value is examined to determine if it is
     non-empty.

     Note that 'ifdef' only tests whether a variable has a value.  It
     does not expand the variable to see if that value is nonempty.
     Consequently, tests using 'ifdef' return true for all definitions
     except those like 'foo ='.  To test for an empty value, use
     'ifeq ($(foo),)'.  For example,

          bar =
          foo = $(bar)
          ifdef foo
          frobozz = yes
          else
          frobozz = no
          endif

     sets 'frobozz' to 'yes', while:

          foo =
          ifdef foo
          frobozz = yes
          else
          frobozz = no
          endif

     sets 'frobozz' to 'no'.

'ifndef VARIABLE-NAME'
     If the variable VARIABLE-NAME has an empty value, the TEXT-IF-TRUE
     is effective; otherwise, the TEXT-IF-FALSE, if any, is effective.
     The rules for expansion and testing of VARIABLE-NAME are identical
     to the 'ifdef' directive.

   Extra spaces are allowed and ignored at the beginning of the
conditional directive line, but a tab is not allowed.  (If the line
begins with a tab, it will be considered part of a recipe for a rule.)
Aside from this, extra spaces or tabs may be inserted with no effect
anywhere except within the directive name or within an argument.  A
comment starting with '#' may appear at the end of the line.

   The other two directives that play a part in a conditional are 'else'
and 'endif'.  Each of these directives is written as one word, with no
arguments.  Extra spaces are allowed and ignored at the beginning of the
line, and spaces or tabs at the end.  A comment starting with '#' may
appear at the end of the line.

   Conditionals affect which lines of the makefile 'make' uses.  If the
condition is true, 'make' reads the lines of the TEXT-IF-TRUE as part of
the makefile; if the condition is false, 'make' ignores those lines
completely.  It follows that syntactic units of the makefile, such as
rules, may safely be split across the beginning or the end of the
conditional.

   'make' evaluates conditionals when it reads a makefile.
Consequently, you cannot use automatic variables in the tests of
conditionals because they are not defined until recipes are run (*note
Automatic Variables::).

   To prevent intolerable confusion, it is not permitted to start a
conditional in one makefile and end it in another.  However, you may
write an 'include' directive within a conditional, provided you do not
attempt to terminate the conditional inside the included file.

==============================================================================
File: make.info,  Node: |Testing_Flags|,  Prev: |Conditional_Syntax|,  Up: |Conditionals|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Testing_Flags*

7.3 Conditionals that Test Flags
--------------------------------

You can write a conditional that tests 'make' command flags such as '-t'
by using the variable 'MAKEFLAGS' together with the 'findstring'
function (*note Functions for String Substitution and Analysis: Text
Functions.).  This is useful when 'touch' is not enough to make a file
appear up to date.

   The 'findstring' function determines whether one string appears as a
substring of another.  If you want to test for the '-t' flag, use 't' as
the first string and the value of 'MAKEFLAGS' as the other.

   For example, here is how to arrange to use 'ranlib -t' to finish
marking an archive file up to date:

     archive.a: ...
     ifneq (,$(findstring t,$(MAKEFLAGS)))
             +touch archive.a
             +ranlib -t archive.a
     else
             ranlib archive.a
     endif

The '+' prefix marks those recipe lines as "recursive" so that they will
be executed despite use of the '-t' flag.  *Note Recursive Use of
'make': Recursion.

==============================================================================
File: make.info,  Node: |Functions|,  Next: |Running|,  Prev: |Conditionals|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Functions*

8 Functions for Transforming Text
=================================

"Functions" allow you to do text processing in the makefile to compute
the files to operate on or the commands to use in recipes.  You use a
function in a "function call", where you give the name of the function
and some text (the "arguments") for the function to operate on.  The
result of the function's processing is substituted into the makefile at
the point of the call, just as a variable might be substituted.

MENU

* |Syntax_of_Functions|::         How to write a function call.
* |Text_Functions|::              General-purpose text manipulation functions.
* |File_Name_Functions|::         Functions for manipulating file names.
* |Conditional_Functions|::       Functions that implement conditions.
* |Foreach_Function|::            Repeat some text with controlled variation.
* |File_Function|::               Write text to a file.
* |Call_Function|::               Expand a user-defined function.
* |Value_Function|::              Return the un-expanded value of a variable.
* |Eval_Function|::               Evaluate the arguments as makefile syntax.
* |Origin_Function|::             Find where a variable got its value.
* |Flavor_Function|::             Find out the flavor of a variable.
* |Make_Control_Functions|::      Functions that control how make runs.
* |Shell_Function|::              Substitute the output of a shell command.
* |Guile_Function|::              Use GNU Guile embedded scripting language.

==============================================================================
File: make.info,  Node: |Syntax_of_Functions|,  Next: |Text_Functions|,  Prev: |Functions|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Syntax_of_Functions*

8.1 Function Call Syntax
------------------------

A function call resembles a variable reference.  It can appear anywhere
a variable reference can appear, and it is expanded using the same rules
as variable references.  A function call looks like this:

     $(FUNCTION ARGUMENTS)

or like this:

     ${FUNCTION ARGUMENTS}

   Here FUNCTION is a function name; one of a short list of names that
are part of 'make'.  You can also essentially create your own functions
by using the 'call' built-in function.

   The ARGUMENTS are the arguments of the function.  They are separated
from the function name by one or more spaces or tabs, and if there is
more than one argument, then they are separated by commas.  Such
whitespace and commas are not part of an argument's value.  The
delimiters which you use to surround the function call, whether
parentheses or braces, can appear in an argument only in matching pairs;
the other kind of delimiters may appear singly.  If the arguments
themselves contain other function calls or variable references, it is
wisest to use the same kind of delimiters for all the references; write
'$(subst a,b,$(x))', not '$(subst a,b,${x})'.  This is because it is
clearer, and because only one type of delimiter is matched to find the
end of the reference.

   The text written for each argument is processed by substitution of
variables and function calls to produce the argument value, which is the
text on which the function acts.  The substitution is done in the order
in which the arguments appear.

   Commas and unmatched parentheses or braces cannot appear in the text
of an argument as written; leading spaces cannot appear in the text of
the first argument as written.  These characters can be put into the
argument value by variable substitution.  First define variables 'comma'
and 'space' whose values are isolated comma and space characters, then
substitute these variables where such characters are wanted, like this:

     comma:= ,
     empty:=
     space:= $(empty) $(empty)
     foo:= a b c
     bar:= $(subst $(space),$(comma),$(foo))
     # bar is now 'a,b,c'.

Here the 'subst' function replaces each space with a comma, through the
value of 'foo', and substitutes the result.

==============================================================================
File: make.info,  Node: |Text_Functions|,  Next: |File_Name_Functions|,  Prev: |Syntax_of_Functions|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Text_Functions*

8.2 Functions for String Substitution and Analysis
--------------------------------------------------

Here are some functions that operate on strings:

'$(subst FROM,TO,TEXT)'
     Performs a textual replacement on the text TEXT: each occurrence of
     FROM is replaced by TO.  The result is substituted for the function
     call.  For example,

          $(subst ee,EE,feet on the street)

     substitutes the string 'fEEt on the strEEt'.

'$(patsubst PATTERN,REPLACEMENT,TEXT)'
     Finds whitespace-separated words in TEXT that match PATTERN and
     replaces them with REPLACEMENT.  Here PATTERN may contain a '%'
     which acts as a wildcard, matching any number of any characters
     within a word.  If REPLACEMENT also contains a '%', the '%' is
     replaced by the text that matched the '%' in PATTERN.  Only the
     first '%' in the PATTERN and REPLACEMENT is treated this way; any
     subsequent '%' is unchanged.

     '%' characters in 'patsubst' function invocations can be quoted
     with preceding backslashes ('\').  Backslashes that would otherwise
     quote '%' characters can be quoted with more backslashes.
     Backslashes that quote '%' characters or other backslashes are
     removed from the pattern before it is compared file names or has a
     stem substituted into it.  Backslashes that are not in danger of
     quoting '%' characters go unmolested.  For example, the pattern
     'the\%weird\\%pattern\\' has 'the%weird\' preceding the operative
     '%' character, and 'pattern\\' following it.  The final two
     backslashes are left alone because they cannot affect any '%'
     character.

     Whitespace between words is folded into single space characters;
     leading and trailing whitespace is discarded.

     For example,

          $(patsubst %.c,%.o,x.c.c bar.c)

     produces the value 'x.c.o bar.o'.

     Substitution references (*note Substitution References:
     Substitution Refs.) are a simpler way to get the effect of the
     'patsubst' function:

          $(VAR:PATTERN=REPLACEMENT)

     is equivalent to

          $(patsubst PATTERN,REPLACEMENT,$(VAR))

     The second shorthand simplifies one of the most common uses of
     'patsubst': replacing the suffix at the end of file names.

          $(VAR:SUFFIX=REPLACEMENT)

     is equivalent to

          $(patsubst %SUFFIX,%REPLACEMENT,$(VAR))

     For example, you might have a list of object files:

          objects = foo.o bar.o baz.o

     To get the list of corresponding source files, you could simply
     write:

          $(objects:.o=.c)

     instead of using the general form:

          $(patsubst %.o,%.c,$(objects))

'$(strip STRING)'
     Removes leading and trailing whitespace from STRING and replaces
     each internal sequence of one or more whitespace characters with a
     single space.  Thus, '$(strip a b c )' results in 'a b c'.

     The function 'strip' can be very useful when used in conjunction
     with conditionals.  When comparing something with the empty string
     '' using 'ifeq' or 'ifneq', you usually want a string of just
     whitespace to match the empty string (*note Conditionals::).

     Thus, the following may fail to have the desired results:

          .PHONY: all
          ifneq   "$(needs_made)" ""
          all: $(needs_made)
          else
          all:;@echo 'Nothing to make!'
          endif

     Replacing the variable reference '$(needs_made)' with the function
     call '$(strip $(needs_made))' in the 'ifneq' directive would make
     it more robust.

'$(findstring FIND,IN)'
     Searches IN for an occurrence of FIND.  If it occurs, the value is
     FIND; otherwise, the value is empty.  You can use this function in
     a conditional to test for the presence of a specific substring in a
     given string.  Thus, the two examples,

          $(findstring a,a b c)
          $(findstring a,b c)

     produce the values 'a' and '' (the empty string), respectively.
     *Note Testing Flags::, for a practical application of 'findstring'.

'$(filter PATTERN...,TEXT)'
     Returns all whitespace-separated words in TEXT that _do_ match any
     of the PATTERN words, removing any words that _do not_ match.  The
     patterns are written using '%', just like the patterns used in the
     'patsubst' function above.

     The 'filter' function can be used to separate out different types
     of strings (such as file names) in a variable.  For example:

          sources := foo.c bar.c baz.s ugh.h
          foo: $(sources)
                  cc $(filter %.c %.s,$(sources)) -o foo

     says that 'foo' depends of 'foo.c', 'bar.c', 'baz.s' and 'ugh.h'
     but only 'foo.c', 'bar.c' and 'baz.s' should be specified in the
     command to the compiler.

'$(filter-out PATTERN...,TEXT)'
     Returns all whitespace-separated words in TEXT that _do not_ match
     any of the PATTERN words, removing the words that _do_ match one or
     more.  This is the exact opposite of the 'filter' function.

     For example, given:

          objects=main1.o foo.o main2.o bar.o
          mains=main1.o main2.o

     the following generates a list which contains all the object files
     not in 'mains':

          $(filter-out $(mains),$(objects))

'$(sort LIST)'
     Sorts the words of LIST in lexical order, removing duplicate words.
     The output is a list of words separated by single spaces.  Thus,

          $(sort foo bar lose)

     returns the value 'bar foo lose'.

     Incidentally, since 'sort' removes duplicate words, you can use it
     for this purpose even if you don't care about the sort order.

'$(word N,TEXT)'
     Returns the Nth word of TEXT.  The legitimate values of N start
     from 1.  If N is bigger than the number of words in TEXT, the value
     is empty.  For example,

          $(word 2, foo bar baz)

     returns 'bar'.

'$(wordlist S,E,TEXT)'
     Returns the list of words in TEXT starting with word S and ending
     with word E (inclusive).  The legitimate values of S start from 1;
     E may start from 0.  If S is bigger than the number of words in
     TEXT, the value is empty.  If E is bigger than the number of words
     in TEXT, words up to the end of TEXT are returned.  If S is greater
     than E, nothing is returned.  For example,

          $(wordlist 2, 3, foo bar baz)

     returns 'bar baz'.

'$(words TEXT)'
     Returns the number of words in TEXT.  Thus, the last word of TEXT
     is '$(word $(words TEXT),TEXT)'.

'$(firstword NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace.  The value is the first name in the series.  The rest
     of the names are ignored.

     For example,

          $(firstword foo bar)

     produces the result 'foo'.  Although '$(firstword TEXT)' is the
     same as '$(word 1,TEXT)', the 'firstword' function is retained for
     its simplicity.

'$(lastword NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace.  The value is the last name in the series.

     For example,

          $(lastword foo bar)

     produces the result 'bar'.  Although '$(lastword TEXT)' is the same
     as '$(word $(words TEXT),TEXT)', the 'lastword' function was added
     for its simplicity and better performance.

   Here is a realistic example of the use of 'subst' and 'patsubst'.
Suppose that a makefile uses the 'VPATH' variable to specify a list of
directories that 'make' should search for prerequisite files (*note
'VPATH' Search Path for All Prerequisites: General Search.).  This
example shows how to tell the C compiler to search for header files in
the same list of directories.

   The value of 'VPATH' is a list of directories separated by colons,
such as 'src:../headers'.  First, the 'subst' function is used to change
the colons to spaces:

     $(subst :, ,$(VPATH))

This produces 'src ../headers'.  Then 'patsubst' is used to turn each
directory name into a '-I' flag.  These can be added to the value of the
variable 'CFLAGS', which is passed automatically to the C compiler, like
this:

     override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))

The effect is to append the text '-Isrc -I../headers' to the previously
given value of 'CFLAGS'.  The 'override' directive is used so that the
new value is assigned even if the previous value of 'CFLAGS' was
specified with a command argument (*note The 'override' Directive:
Override Directive.).

==============================================================================
File: make.info,  Node: |File_Name_Functions|,  Next: |Conditional_Functions|,  Prev: |Text_Functions|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *File_Name_Functions*

8.3 Functions for File Names
----------------------------

Several of the built-in expansion functions relate specifically to
taking apart file names or lists of file names.

   Each of the following functions performs a specific transformation on
a file name.  The argument of the function is regarded as a series of
file names, separated by whitespace.  (Leading and trailing whitespace
is ignored.)  Each file name in the series is transformed in the same
way and the results are concatenated with single spaces between them.

'$(dir NAMES...)'
     Extracts the directory-part of each file name in NAMES.  The
     directory-part of the file name is everything up through (and
     including) the last slash in it.  If the file name contains no
     slash, the directory part is the string './'.  For example,

          $(dir src/foo.c hacks)

     produces the result 'src/ ./'.

'$(notdir NAMES...)'
     Extracts all but the directory-part of each file name in NAMES.  If
     the file name contains no slash, it is left unchanged.  Otherwise,
     everything through the last slash is removed from it.

     A file name that ends with a slash becomes an empty string.  This
     is unfortunate, because it means that the result does not always
     have the same number of whitespace-separated file names as the
     argument had; but we do not see any other valid alternative.

     For example,

          $(notdir src/foo.c hacks)

     produces the result 'foo.c hacks'.

'$(suffix NAMES...)'
     Extracts the suffix of each file name in NAMES.  If the file name
     contains a period, the suffix is everything starting with the last
     period.  Otherwise, the suffix is the empty string.  This
     frequently means that the result will be empty when NAMES is not,
     and if NAMES contains multiple file names, the result may contain
     fewer file names.

     For example,

          $(suffix src/foo.c src-1.0/bar.c hacks)

     produces the result '.c .c'.

'$(basename NAMES...)'
     Extracts all but the suffix of each file name in NAMES.  If the
     file name contains a period, the basename is everything starting up
     to (and not including) the last period.  Periods in the directory
     part are ignored.  If there is no period, the basename is the
     entire file name.  For example,

          $(basename src/foo.c src-1.0/bar hacks)

     produces the result 'src/foo src-1.0/bar hacks'.

'$(addsuffix SUFFIX,NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace; SUFFIX is used as a unit.  The value of SUFFIX is
     appended to the end of each individual name and the resulting
     larger names are concatenated with single spaces between them.  For
     example,

          $(addsuffix .c,foo bar)

     produces the result 'foo.c bar.c'.

'$(addprefix PREFIX,NAMES...)'
     The argument NAMES is regarded as a series of names, separated by
     whitespace; PREFIX is used as a unit.  The value of PREFIX is
     prepended to the front of each individual name and the resulting
     larger names are concatenated with single spaces between them.  For
     example,

          $(addprefix src/,foo bar)

     produces the result 'src/foo src/bar'.

'$(join LIST1,LIST2)'
     Concatenates the two arguments word by word: the two first words
     (one from each argument) concatenated form the first word of the
     result, the two second words form the second word of the result,
     and so on.  So the Nth word of the result comes from the Nth word
     of each argument.  If one argument has more words that the other,
     the extra words are copied unchanged into the result.

     For example, '$(join a b,.c .o)' produces 'a.c b.o'.

     Whitespace between the words in the lists is not preserved; it is
     replaced with a single space.

     This function can merge the results of the 'dir' and 'notdir'
     functions, to produce the original list of files which was given to
     those two functions.

'$(wildcard PATTERN)'
     The argument PATTERN is a file name pattern, typically containing
     wildcard characters (as in shell file name patterns).  The result
     of 'wildcard' is a space-separated list of the names of existing
     files that match the pattern.  *Note Using Wildcard Characters in
     File Names: Wildcards.

'$(realpath NAMES...)'
     For each file name in NAMES return the canonical absolute name.  A
     canonical name does not contain any '.' or '..' components, nor any
     repeated path separators ('/') or symlinks.  In case of a failure
     the empty string is returned.  Consult the 'realpath(3)'
     documentation for a list of possible failure causes.

'$(abspath NAMES...)'
     For each file name in NAMES return an absolute name that does not
     contain any '.' or '..' components, nor any repeated path
     separators ('/').  Note that, in contrast to 'realpath' function,
     'abspath' does not resolve symlinks and does not require the file
     names to refer to an existing file or directory.  Use the
     'wildcard' function to test for existence.

==============================================================================
File: make.info,  Node: |Conditional_Functions|,  Next: |Foreach_Function|,  Prev: |File_Name_Functions|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Conditional_Functions*

8.4 Functions for Conditionals
------------------------------

There are three functions that provide conditional expansion.  A key
aspect of these functions is that not all of the arguments are expanded
initially.  Only those arguments which need to be expanded, will be
expanded.

'$(if CONDITION,THEN-PART[,ELSE-PART])'
     The 'if' function provides support for conditional expansion in a
     functional context (as opposed to the GNU 'make' makefile
     conditionals such as 'ifeq' (*note Syntax of Conditionals:
     Conditional Syntax.).

     The first argument, CONDITION, first has all preceding and trailing
     whitespace stripped, then is expanded.  If it expands to any
     non-empty string, then the condition is considered to be true.  If
     it expands to an empty string, the condition is considered to be
     false.

     If the condition is true then the second argument, THEN-PART, is
     evaluated and this is used as the result of the evaluation of the
     entire 'if' function.

     If the condition is false then the third argument, ELSE-PART, is
     evaluated and this is the result of the 'if' function.  If there is
     no third argument, the 'if' function evaluates to nothing (the
     empty string).

     Note that only one of the THEN-PART or the ELSE-PART will be
     evaluated, never both.  Thus, either can contain side-effects (such
     as 'shell' function calls, etc.)

'$(or CONDITION1[,CONDITION2[,CONDITION3...]])'
     The 'or' function provides a "short-circuiting" OR operation.  Each
     argument is expanded, in order.  If an argument expands to a
     non-empty string the processing stops and the result of the
     expansion is that string.  If, after all arguments are expanded,
     all of them are false (empty), then the result of the expansion is
     the empty string.

'$(and CONDITION1[,CONDITION2[,CONDITION3...]])'
     The 'and' function provides a "short-circuiting" AND operation.
     Each argument is expanded, in order.  If an argument expands to an
     empty string the processing stops and the result of the expansion
     is the empty string.  If all arguments expand to a non-empty string
     then the result of the expansion is the expansion of the last
     argument.

==============================================================================
File: make.info,  Node: |Foreach_Function|,  Next: |File_Function|,  Prev: |Conditional_Functions|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Foreach_Function*

8.5 The 'foreach' Function
--------------------------

The 'foreach' function is very different from other functions.  It
causes one piece of text to be used repeatedly, each time with a
different substitution performed on it.  It resembles the 'for' command
in the shell 'sh' and the 'foreach' command in the C-shell 'csh'.

   The syntax of the 'foreach' function is:

     $(foreach VAR,LIST,TEXT)

The first two arguments, VAR and LIST, are expanded before anything else
is done; note that the last argument, TEXT, is not expanded at the
same time.  Then for each word of the expanded value of LIST, the
variable named by the expanded value of VAR is set to that word, and
TEXT is expanded.  Presumably TEXT contains references to that variable,
so its expansion will be different each time.

   The result is that TEXT is expanded as many times as there are
whitespace-separated words in LIST.  The multiple expansions of TEXT are
concatenated, with spaces between them, to make the result of 'foreach'.

   This simple example sets the variable 'files' to the list of all
files in the directories in the list 'dirs':

     dirs := a b c d
     files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))

   Here TEXT is '$(wildcard $(dir)/*)'.  The first repetition finds the
value 'a' for 'dir', so it produces the same result as '$(wildcard
a/*)'; the second repetition produces the result of '$(wildcard b/*)';
and the third, that of '$(wildcard c/*)'.

   This example has the same result (except for setting 'dirs') as the
following example:

     files := $(wildcard a/* b/* c/* d/*)

   When TEXT is complicated, you can improve readability by giving it a
name, with an additional variable:

     find_files = $(wildcard $(dir)/*)
     dirs := a b c d
     files := $(foreach dir,$(dirs),$(find_files))

Here we use the variable 'find_files' this way.  We use plain '=' to
define a recursively-expanding variable, so that its value contains an
actual function call to be re-expanded under the control of 'foreach'; a
simply-expanded variable would not do, since 'wildcard' would be called
only once at the time of defining 'find_files'.

   The 'foreach' function has no permanent effect on the variable VAR;
its value and flavor after the 'foreach' function call are the same as
they were beforehand.  The other values which are taken from LIST are in
effect only temporarily, during the execution of 'foreach'.  The
variable VAR is a simply-expanded variable during the execution of
'foreach'.  If VAR was undefined before the 'foreach' function call, it
is undefined after the call.  *Note The Two Flavors of Variables:
Flavors.

   You must take care when using complex variable expressions that
result in variable names because many strange things are valid variable
names, but are probably not what you intended.  For example,

     files := $(foreach Esta-escrito-en-espanol!,b c ch,$(find_files))

might be useful if the value of 'find_files' references the variable
whose name is 'Esta-escrito-en-espanol!' (es un nombre bastante largo,
no?), but it is more likely to be a mistake.

==============================================================================
File: make.info,  Node: |File_Function|,  Next: |Call_Function|,  Prev: |Foreach_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *File_Function*

8.6 The 'file' Function
-----------------------

The 'file' function allows the makefile to write to or read from a file.
Two modes of writing are supported: overwrite, where the text is written
to the beginning of the file and any existing content is lost, and
append, where the text is written to the end of the file, preserving the
existing content.  In both cases the file is created if it does not
exist.  It is a fatal error if the file cannot be opened for writing, or
if the write operation fails.  The 'file' function expands to the empty
string when writing to a file.

   When reading from a file, the 'file' function expands to the verbatim
contents of the file, except that the final newline (if there is one)
will be stripped.  Attempting to read from a non-existent file expands
to the empty string.

   The syntax of the 'file' function is:

     $(file OP FILENAME[,TEXT])

   When the 'file' function is evaluated all its arguments are expanded
first, then the file indicated by FILENAME will be opened in the mode
described by OP.

   The operator OP can be '>' to indicate the file will be overwritten
with new content, '>>' to indicate the current contents of the file will
be appended to, or '<' to indicate the contents of the file will be read
in.  The FILENAME specifies the file to be written to or read from.
There may optionally be whitespace between the operator and the file
name.

   When reading files, it is an error to provide a TEXT value.

   When writing files, TEXT will be written to the file.  If TEXT does
not already end in a newline a final newline will be written (even if
TEXT is the empty string).  If the TEXT argument is not given at all,
nothing will be written.

   For example, the 'file' function can be useful if your build system
has a limited command line size and your recipe runs a command that can
accept arguments from a file as well.  Many commands use the convention
that an argument prefixed with an '@' specifies a file containing more
arguments.  Then you might write your recipe in this way:

     program: $(OBJECTS)
             $(file >$@.in,$^)
             $(CMD) $(CMDFLAGS) @$@.in
             @rm $@.in

   If the command required each argument to be on a separate line of the
input file, you might write your recipe like this:

     program: $(OBJECTS)
             $(file >$@.in) $(foreach O,$^,$(file >>$@.in,$O))
             $(CMD) $(CMDFLAGS) @$@.in
             @rm $@.in

==============================================================================
File: make.info,  Node: |Call_Function|,  Next: |Value_Function|,  Prev: |File_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Call_Function*

8.7 The 'call' Function
-----------------------

The 'call' function is unique in that it can be used to create new
parameterized functions.  You can write a complex expression as the
value of a variable, then use 'call' to expand it with different values.

   The syntax of the 'call' function is:

     $(call VARIABLE,PARAM,PARAM,...)

   When 'make' expands this function, it assigns each PARAM to temporary
variables '$(1)', '$(2)', etc.  The variable '$(0)' will contain
VARIABLE.  There is no maximum number of parameter arguments.  There is
no minimum, either, but it doesn't make sense to use 'call' with no
parameters.

   Then VARIABLE is expanded as a 'make' variable in the context of
these temporary assignments.  Thus, any reference to '$(1)' in the value
of VARIABLE will resolve to the first PARAM in the invocation of 'call'.

   Note that VARIABLE is the _name_ of a variable, not a _reference_ to
that variable.  Therefore you would not normally use a '$' or
parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   If VARIABLE is the name of a built-in function, the built-in function
is always invoked (even if a 'make' variable by that name also exists).

   The 'call' function expands the PARAM arguments before assigning them
to temporary variables.  This means that VARIABLE values containing
references to built-in functions that have special expansion rules, like
'foreach' or 'if', may not work as you expect.

   Some examples may make this clearer.

   This macro simply reverses its arguments:

     reverse = $(2) $(1)

     foo = $(call reverse,a,b)

Here FOO will contain 'b a'.

   This one is slightly more interesting: it defines a macro to search
for the first instance of a program in 'PATH':

     pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))

     LS := $(call pathsearch,ls)

Now the variable LS contains '/bin/ls' or similar.

   The 'call' function can be nested.  Each recursive invocation gets
its own local values for '$(1)', etc. that mask the values of
higher-level 'call'.  For example, here is an implementation of a "map"
function:

     map = $(foreach a,$(2),$(call $(1),$(a)))

   Now you can MAP a function that normally takes only one argument,
such as 'origin', to multiple values in one step:

     o = $(call map,origin,o map MAKE)

   and end up with O containing something like 'file file default'.

   A final caution: be careful when adding whitespace to the arguments
to 'call'.  As with other functions, any whitespace contained in the
second and subsequent arguments is kept; this can cause strange effects.
It's generally safest to remove all extraneous whitespace when providing
parameters to 'call'.

==============================================================================
File: make.info,  Node: |Value_Function|,  Next: |Eval_Function|,  Prev: |Call_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Value_Function*

8.8 The 'value' Function
------------------------

The 'value' function provides a way for you to use the value of a
variable _without_ having it expanded.  Please note that this does not
undo expansions which have already occurred; for example if you create a
simply expanded variable its value is expanded during the definition; in
that case the 'value' function will return the same result as using the
variable directly.

   The syntax of the 'value' function is:

     $(value VARIABLE)

   Note that VARIABLE is the _name_ of a variable, not a _reference_ to
that variable.  Therefore you would not normally use a '$' or
parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   The result of this function is a string containing the value of
VARIABLE, without any expansion occurring.  For example, in this
makefile:

     FOO = $PATH

     all:
             @echo $(FOO)
             @echo $(value FOO)

The first output line would be 'ATH', since the "$P" would be expanded
as a 'make' variable, while the second output line would be the current
value of your '$PATH' environment variable, since the 'value' function
avoided the expansion.

   The 'value' function is most often used in conjunction with the
'eval' function (*note Eval Function::).

==============================================================================
File: make.info,  Node: |Eval_Function|,  Next: |Origin_Function|,  Prev: |Value_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Eval_Function*

8.9 The 'eval' Function
-----------------------

The 'eval' function is very special: it allows you to define new
makefile constructs that are not constant; which are the result of
evaluating other variables and functions.  The argument to the 'eval'
function is expanded, then the results of that expansion are parsed as
makefile syntax.  The expanded results can define new 'make' variables,
targets, implicit or explicit rules, etc.

   The result of the 'eval' function is always the empty string; thus,
it can be placed virtually anywhere in a makefile without causing syntax
errors.

   It's important to realize that the 'eval' argument is expanded
_twice_; first by the 'eval' function, then the results of that
expansion are expanded again when they are parsed as makefile syntax.
This means you may need to provide extra levels of escaping for "$"
characters when using 'eval'.  The 'value' function (*note Value
Function::) can sometimes be useful in these situations, to circumvent
unwanted expansions.

   Here is an example of how 'eval' can be used; this example combines a
number of concepts and other functions.  Although it might seem overly
complex to use 'eval' in this example, rather than just writing out the
rules, consider two things: first, the template definition (in
'PROGRAM_template') could need to be much more complex than it is here;
and second, you might put the complex, "generic" part of this example
into another makefile, then include it in all the individual makefiles.
Now your individual makefiles are quite straightforward.

     PROGRAMS    = server client

     server_OBJS = server.o server_priv.o server_access.o
     server_LIBS = priv protocol

     client_OBJS = client.o client_api.o client_mem.o
     client_LIBS = protocol

     # Everything after this is generic

     .PHONY: all
     all: $(PROGRAMS)

     define PROGRAM_template =
      $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)
      ALL_OBJS   += $$($(1)_OBJS)
     endef

     $(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))

     $(PROGRAMS):
             $(LINK.o) $^ $(LDLIBS) -o $@

     clean:
             rm -f $(ALL_OBJS) $(PROGRAMS)

==============================================================================
File: make.info,  Node: |Origin_Function|,  Next: |Flavor_Function|,  Prev: |Eval_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Origin_Function*

8.10 The 'origin' Function
--------------------------

The 'origin' function is unlike most other functions in that it does not
operate on the values of variables; it tells you something _about_ a
variable.  Specifically, it tells you where it came from.

   The syntax of the 'origin' function is:

     $(origin VARIABLE)

   Note that VARIABLE is the _name_ of a variable to inquire about, not
a _reference_ to that variable.  Therefore you would not normally use a
'$' or parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   The result of this function is a string telling you how the variable
VARIABLE was defined:

'undefined'

     if VARIABLE was never defined.

'default'

     if VARIABLE has a default definition, as is usual with 'CC' and so
     on.  *Note Variables Used by Implicit Rules: Implicit Variables.
     Note that if you have redefined a default variable, the 'origin'
     function will return the origin of the later definition.

'environment'

     if VARIABLE was inherited from the environment provided to 'make'.

'environment override'

     if VARIABLE was inherited from the environment provided to 'make',
     and is overriding a setting for VARIABLE in the makefile as a
     result of the '-e' option (*note Summary of Options: Options
     Summary.).

'file'

     if VARIABLE was defined in a makefile.

'command line'

     if VARIABLE was defined on the command line.

'override'

     if VARIABLE was defined with an 'override' directive in a makefile
     (*note The 'override' Directive: Override Directive.).

'automatic'

     if VARIABLE is an automatic variable defined for the execution of
     the recipe for each rule (*note Automatic Variables::).

   This information is primarily useful (other than for your curiosity)
to determine if you want to believe the value of a variable.  For
example, suppose you have a makefile 'foo' that includes another
makefile 'bar'.  You want a variable 'bletch' to be defined in 'bar' if
you run the command 'make -f bar', even if the environment contains a
definition of 'bletch'.  However, if 'foo' defined 'bletch' before
including 'bar', you do not want to override that definition.  This
could be done by using an 'override' directive in 'foo', giving that
definition precedence over the later definition in 'bar'; unfortunately,
the 'override' directive would also override any command line
definitions.  So, 'bar' could include:

     ifdef bletch
     ifeq "$(origin bletch)" "environment"
     bletch = barf, gag, etc.
     endif
     endif

If 'bletch' has been defined from the environment, this will redefine
it.

   If you want to override a previous definition of 'bletch' if it came
from the environment, even under '-e', you could instead write:

     ifneq "$(findstring environment,$(origin bletch))" ""
     bletch = barf, gag, etc.
     endif

   Here the redefinition takes place if '$(origin bletch)' returns
either 'environment' or 'environment override'.  *Note Functions for
String Substitution and Analysis: Text Functions.

==============================================================================
File: make.info,  Node: |Flavor_Function|,  Next: |Make_Control_Functions|,  Prev: |Origin_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Flavor_Function*

8.11 The 'flavor' Function
--------------------------

The 'flavor' function, like the 'origin' function, does not operate on
the values of variables but rather it tells you something _about_ a
variable.  Specifically, it tells you the flavor of a variable (*note
The Two Flavors of Variables: Flavors.).

   The syntax of the 'flavor' function is:

     $(flavor VARIABLE)

   Note that VARIABLE is the _name_ of a variable to inquire about, not
a _reference_ to that variable.  Therefore you would not normally use a
'$' or parentheses when writing it.  (You can, however, use a variable
reference in the name if you want the name not to be a constant.)

   The result of this function is a string that identifies the flavor of
the variable VARIABLE:

'undefined'

     if VARIABLE was never defined.

'recursive'

     if VARIABLE is a recursively expanded variable.

'simple'

     if VARIABLE is a simply expanded variable.

==============================================================================
File: make.info,  Node: |Make_Control_Functions|,  Next: |Shell_Function|,  Prev: |Flavor_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Make_Control_Functions*

8.12 Functions That Control Make
--------------------------------

These functions control the way make runs.  Generally, they are used to
provide information to the user of the makefile or to cause make to stop
if some sort of environmental error is detected.

'$(error TEXT...)'
     Generates a fatal error where the message is TEXT.  Note that the
     error is generated whenever this function is evaluated.  So, if you
     put it inside a recipe or on the right side of a recursive variable
     assignment, it won't be evaluated until later.  The TEXT will be
     expanded before the error is generated.

     For example,

          ifdef ERROR1
          $(error error is $(ERROR1))
          endif

     will generate a fatal error during the read of the makefile if the
     'make' variable 'ERROR1' is defined.  Or,

          ERR = $(error found an error!)

          .PHONY: err
          err: ; $(ERR)

     will generate a fatal error while 'make' is running, if the 'err'
     target is invoked.

'$(warning TEXT...)'
     This function works similarly to the 'error' function, above,
     except that 'make' doesn't exit.  Instead, TEXT is expanded and the
     resulting message is displayed, but processing of the makefile
     continues.

     The result of the expansion of this function is the empty string.

'$(info TEXT...)'
     This function does nothing more than print its (expanded)
     argument(s) to standard output.  No makefile name or line number is
     added.  The result of the expansion of this function is the empty
     string.

==============================================================================
File: make.info,  Node: |Shell_Function|,  Next: |Guile_Function|,  Prev: |Make_Control_Functions|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Shell_Function*

8.13 The 'shell' Function
-------------------------

The 'shell' function is unlike any other function other than the
'wildcard' function (*note The Function 'wildcard': Wildcard Function.)
in that it communicates with the world outside of 'make'.

   The 'shell' function performs the same function that backquotes ('`')
perform in most shells: it does "command expansion".  This means that it
takes as an argument a shell command and evaluates to the output of the
command.  The only processing 'make' does on the result is to convert
each newline (or carriage-return / newline pair) to a single space.  If
there is a trailing (carriage-return and) newline it will simply be
removed.

   The commands run by calls to the 'shell' function are run when the
function calls are expanded (*note How 'make' Reads a Makefile: Reading
Makefiles.).  Because this function involves spawning a new shell, you
should carefully consider the performance implications of using the
'shell' function within recursively expanded variables vs. simply
expanded variables (*note The Two Flavors of Variables: Flavors.).

   After the 'shell' function or '!=' assignment operator is used, its
exit status is placed in the '.SHELLSTATUS' variable.

   Here are some examples of the use of the 'shell' function:

     contents := $(shell cat foo)

sets 'contents' to the contents of the file 'foo', with a space (rather
than a newline) separating each line.

     files := $(shell echo *.c)

sets 'files' to the expansion of '*.c'.  Unless 'make' is using a very
strange shell, this has the same result as '$(wildcard *.c)' (as long as
at least one '.c' file exists).

==============================================================================
File: make.info,  Node: |Guile_Function|,  Prev: |Shell_Function|,  Up: |Functions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Guile_Function*

8.14 The 'guile' Function
-------------------------

If GNU 'make' is built with support for GNU Guile as an embedded
extension language then the 'guile' function will be available.  The
'guile' function takes one argument which is first expanded by 'make' in
the normal fashion, then passed to the GNU Guile evaluator.  The result
of the evaluator is converted into a string and used as the expansion of
the 'guile' function in the makefile.  See *note GNU Guile Integration:
Guile Integration. for details on writing extensions to 'make' in Guile.

   You can determine whether GNU Guile support is available by checking
the '.FEATURES' variable for the word GUILE.

==============================================================================
File: make.info,  Node: |Running|,  Next: |Implicit_Rules|,  Prev: |Functions|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Running*

9 How to Run 'make'
===================

A makefile that says how to recompile a program can be used in more than
one way.  The simplest use is to recompile every file that is out of
date.  Usually, makefiles are written so that if you run 'make' with no
arguments, it does just that.

   But you might want to update only some of the files; you might want
to use a different compiler or different compiler options; you might
want just to find out which files are out of date without changing them.

   By giving arguments when you run 'make', you can do any of these
things and many others.

   The exit status of 'make' is always one of three values:
'0'
     The exit status is zero if 'make' is successful.
'2'
     The exit status is two if 'make' encounters any errors.  It will
     print messages describing the particular errors.
'1'
     The exit status is one if you use the '-q' flag and 'make'
     determines that some target is not already up to date.  *Note
     Instead of Executing Recipes: Instead of Execution.

MENU

* |Makefile_Arguments|::          How to specify which makefile to use.
* |Goals|::                       How to use goal arguments to specify which
                                  parts of the makefile to use.
* |Instead_of_Execution|::        How to use mode flags to specify what
                                  kind of thing to do with the recipes
                                  in the makefile other than simply
                                  execute them.
* |Avoiding_Compilation|::        How to avoid recompiling certain files.
* |Overriding|::                  How to override a variable to specify
                                  an alternate compiler and other things.
* |Testing|::                     How to proceed past some errors, to
                                  test compilation.
* |Options_Summary|::             Summary of Options

==============================================================================
File: make.info,  Node: |Makefile_Arguments|,  Next: |Goals|,  Prev: |Running|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Makefile_Arguments*

9.1 Arguments to Specify the Makefile
-------------------------------------

The way to specify the name of the makefile is with the '-f' or '--file'
option ('--makefile' also works).  For example, '-f altmake' says to use
the file 'altmake' as the makefile.

   If you use the '-f' flag several times and follow each '-f' with an
argument, all the specified files are used jointly as makefiles.

   If you do not use the '-f' or '--file' flag, the default is to try
'GNUmakefile', 'makefile', and 'Makefile', in that order, and use the
first of these three which exists or can be made (*note Writing
Makefiles: Makefiles.).

==============================================================================
File: make.info,  Node: |Goals|,  Next: |Instead_of_Execution|,  Prev: |Makefile_Arguments|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Goals*

9.2 Arguments to Specify the Goals
----------------------------------

The "goals" are the targets that 'make' should strive ultimately to
update.  Other targets are updated as well if they appear as
prerequisites of goals, or prerequisites of prerequisites of goals, etc.

   By default, the goal is the first target in the makefile (not
counting targets that start with a period).  Therefore, makefiles are
usually written so that the first target is for compiling the entire
program or programs they describe.  If the first rule in the makefile
has several targets, only the first target in the rule becomes the
default goal, not the whole list.  You can manage the selection of the
default goal from within your makefile using the '.DEFAULT_GOAL'
variable (*note Other Special Variables: Special Variables.).

   You can also specify a different goal or goals with command line
arguments to 'make'.  Use the name of the goal as an argument.  If you
specify several goals, 'make' processes each of them in turn, in the
order you name them.

   Any target in the makefile may be specified as a goal (unless it
starts with '-' or contains an '=', in which case it will be parsed as a
switch or variable definition, respectively).  Even targets not in the
makefile may be specified, if 'make' can find implicit rules that say
how to make them.

   'Make' will set the special variable 'MAKECMDGOALS' to the list of
goals you specified on the command line.  If no goals were given on the
command line, this variable is empty.  Note that this variable should be
used only in special circumstances.

   An example of appropriate use is to avoid including '.d' files during
'clean' rules (*note Automatic Prerequisites::), so 'make' won't create
them only to immediately remove them again:

     sources = foo.c bar.c

     ifneq ($(MAKECMDGOALS),clean)
     include $(sources:.c=.d)
     endif

   One use of specifying a goal is if you want to compile only a part of
the program, or only one of several programs.  Specify as a goal each
file that you wish to remake.  For example, consider a directory
containing several programs, with a makefile that starts like this:

     .PHONY: all
     all: size nm ld ar as

   If you are working on the program 'size', you might want to say
'make size' so that only the files of that program are recompiled.

   Another use of specifying a goal is to make files that are not
normally made.  For example, there may be a file of debugging output, or
a version of the program that is compiled specially for testing, which
has a rule in the makefile but is not a prerequisite of the default
goal.

   Another use of specifying a goal is to run the recipe associated with
a phony target (*note Phony Targets::) or empty target (*note Empty
Target Files to Record Events: Empty Targets.).  Many makefiles contain
a phony target named 'clean' which deletes everything except source
files.  Naturally, this is done only if you request it explicitly with
'make clean'.  Following is a list of typical phony and empty target
names.  *Note Standard Targets::, for a detailed list of all the
standard target names which GNU software packages use.

'all'
     Make all the top-level targets the makefile knows about.

'clean'
     Delete all files that are normally created by running 'make'.

'mostlyclean'
     Like 'clean', but may refrain from deleting a few files that people
     normally don't want to recompile.  For example, the 'mostlyclean'
     target for GCC does not delete 'libgcc.a', because recompiling it
     is rarely necessary and takes a lot of time.

'distclean'
'realclean'
'clobber'
     Any of these targets might be defined to delete _more_ files than
     'clean' does.  For example, this would delete configuration files
     or links that you would normally create as preparation for
     compilation, even if the makefile itself cannot create these files.

'install'
     Copy the executable file into a directory that users typically
     search for commands; copy any auxiliary files that the executable
     uses into the directories where it will look for them.

'print'
     Print listings of the source files that have changed.

'tar'
     Create a tar file of the source files.

'shar'
     Create a shell archive (shar file) of the source files.

'dist'
     Create a distribution file of the source files.  This might be a
     tar file, or a shar file, or a compressed version of one of the
     above, or even more than one of the above.

'TAGS'
     Update a tags table for this program.

'check'
'test'
     Perform self tests on the program this makefile builds.

==============================================================================
File: make.info,  Node: |Instead_of_Execution|,  Next: |Avoiding_Compilation|,  Prev: |Goals|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Instead_of_Execution*

9.3 Instead of Executing Recipes
--------------------------------

The makefile tells 'make' how to tell whether a target is up to date,
and how to update each target.  But updating the targets is not always
what you want.  Certain options specify other activities for 'make'.

'-n'
'--just-print'
'--dry-run'
'--recon'

     "No-op".  Causes 'make' to print the recipes that are needed to
     make the targets up to date, but not actually execute them.  Note
     that some recipes are still executed, even with this flag (*note
     How the 'MAKE' Variable Works: MAKE Variable.).  Also any recipes
     needed to update included makefiles are still executed (*note How
     Makefiles Are Remade: Remaking Makefiles.).

'-t'
'--touch'

     "Touch".  Marks targets as up to date without actually changing
     them.  In other words, 'make' pretends to update the targets but
     does not really change their contents; instead only their modified
     times are updated.

'-q'
'--question'

     "Question".  Silently check whether the targets are up to date, but
     do not execute recipes; the exit code shows whether any updates are
     needed.

'-W FILE'
'--what-if=FILE'
'--assume-new=FILE'
'--new-file=FILE'

     "What if".  Each '-W' flag is followed by a file name.  The given
     files' modification times are recorded by 'make' as being the
     present time, although the actual modification times remain the
     same.  You can use the '-W' flag in conjunction with the '-n' flag
     to see what would happen if you were to modify specific files.

   With the '-n' flag, 'make' prints the recipe that it would normally
execute but usually does not execute it.

   With the '-t' flag, 'make' ignores the recipes in the rules and uses
(in effect) the command 'touch' for each target that needs to be remade.
The 'touch' command is also printed, unless '-s' or '.SILENT' is used.
For speed, 'make' does not actually invoke the program 'touch'.  It does
the work directly.

   With the '-q' flag, 'make' prints nothing and executes no recipes,
but the exit status code it returns is zero if and only if the targets
to be considered are already up to date.  If the exit status is one,
then some updating needs to be done.  If 'make' encounters an error, the
exit status is two, so you can distinguish an error from a target that
is not up to date.

   It is an error to use more than one of these three flags in the same
invocation of 'make'.

   The '-n', '-t', and '-q' options do not affect recipe lines that
begin with '+' characters or contain the strings '$(MAKE)' or '${MAKE}'.
Note that only the line containing the '+' character or the strings
'$(MAKE)' or '${MAKE}' is run regardless of these options.  Other lines
in the same rule are not run unless they too begin with '+' or contain
'$(MAKE)' or '${MAKE}' (*Note How the 'MAKE' Variable Works: MAKE
Variable.)

   The '-t' flag prevents phony targets (*note Phony Targets::) from
being updated, unless there are recipe lines beginning with '+' or
containing '$(MAKE)' or '${MAKE}'.

   The '-W' flag provides two features:

   * If you also use the '-n' or '-q' flag, you can see what 'make'
     would do if you were to modify some files.

   * Without the '-n' or '-q' flag, when 'make' is actually executing
     recipes, the '-W' flag can direct 'make' to act as if some files
     had been modified, without actually running the recipes for those
     files.

   Note that the options '-p' and '-v' allow you to obtain other
information about 'make' or about the makefiles in use (*note Summary of
Options: Options Summary.).

==============================================================================
File: make.info,  Node: |Avoiding_Compilation|,  Next: |Overriding|,  Prev: |Instead_of_Execution|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Avoiding_Compilation*

9.4 Avoiding Recompilation of Some Files
----------------------------------------

Sometimes you may have changed a source file but you do not want to
recompile all the files that depend on it.  For example, suppose you add
a macro or a declaration to a header file that many other files depend
on.  Being conservative, 'make' assumes that any change in the header
file requires recompilation of all dependent files, but you know that
they do not need to be recompiled and you would rather not waste the
time waiting for them to compile.

   If you anticipate the problem before changing the header file, you
can use the '-t' flag.  This flag tells 'make' not to run the recipes in
the rules, but rather to mark the target up to date by changing its
last-modification date.  You would follow this procedure:

  1. Use the command 'make' to recompile the source files that really
     need recompilation, ensuring that the object files are up-to-date
     before you begin.

  2. Make the changes in the header files.

  3. Use the command 'make -t' to mark all the object files as up to
     date.  The next time you run 'make', the changes in the header
     files will not cause any recompilation.

   If you have already changed the header file at a time when some files
do need recompilation, it is too late to do this.  Instead, you can use
the '-o FILE' flag, which marks a specified file as "old" (*note Summary
of Options: Options Summary.).  This means that the file itself will not
be remade, and nothing else will be remade on its account.  Follow this
procedure:

  1. Recompile the source files that need compilation for reasons
     independent of the particular header file, with 'make -o
     HEADERFILE'.  If several header files are involved, use a separate
     '-o' option for each header file.

  2. Touch all the object files with 'make -t'.

==============================================================================
File: make.info,  Node: |Overriding|,  Next: |Testing|,  Prev: |Avoiding_Compilation|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        *Overriding*

9.5 Overriding Variables
------------------------

An argument that contains '=' specifies the value of a variable: 'V=X'
sets the value of the variable V to X.  If you specify a value in this
way, all ordinary assignments of the same variable in the makefile are
ignored; we say they have been "overridden" by the command line
argument.

   The most common way to use this facility is to pass extra flags to
compilers.  For example, in a properly written makefile, the variable
'CFLAGS' is included in each recipe that runs the C compiler, so a file
'foo.c' would be compiled something like this:

     cc -c $(CFLAGS) foo.c

   Thus, whatever value you set for 'CFLAGS' affects each compilation
that occurs.  The makefile probably specifies the usual value for
'CFLAGS', like this:

     CFLAGS=-g

   Each time you run 'make', you can override this value if you wish.
For example, if you say 'make CFLAGS='-g -O'', each C compilation will
be done with 'cc -c -g -O'.  (This also illustrates how you can use
quoting in the shell to enclose spaces and other special characters in
the value of a variable when you override it.)

   The variable 'CFLAGS' is only one of many standard variables that
exist just so that you can change them this way.  *Note Variables Used
by Implicit Rules: Implicit Variables, for a complete list.

   You can also program the makefile to look at additional variables of
your own, giving the user the ability to control other aspects of how
the makefile works by changing the variables.

   When you override a variable with a command line argument, you can
define either a recursively-expanded variable or a simply-expanded
variable.  The examples shown above make a recursively-expanded
variable; to make a simply-expanded variable, write ':=' or '::='
instead of '='.  But, unless you want to include a variable reference or
function call in the _value_ that you specify, it makes no difference
which kind of variable you create.

   There is one way that the makefile can change a variable that you
have overridden.  This is to use the 'override' directive, which is a
line that looks like this: 'override VARIABLE = VALUE' (*note The
'override' Directive: Override Directive.).

==============================================================================
File: make.info,  Node: |Testing|,  Next: |Options_Summary|,  Prev: |Overriding|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Testing*

9.6 Testing the Compilation of a Program
----------------------------------------

Normally, when an error happens in executing a shell command, 'make'
gives up immediately, returning a nonzero status.  No further recipes
are executed for any target.  The error implies that the goal cannot be
correctly remade, and 'make' reports this as soon as it knows.

   When you are compiling a program that you have just changed, this is
not what you want.  Instead, you would rather that 'make' try compiling
every file that can be tried, to show you as many compilation errors as
possible.

   On these occasions, you should use the '-k' or '--keep-going' flag.
This tells 'make' to continue to consider the other prerequisites of the
pending targets, remaking them if necessary, before it gives up and
returns nonzero status.  For example, after an error in compiling one
object file, 'make -k' will continue compiling other object files even
though it already knows that linking them will be impossible.  In
addition to continuing after failed shell commands, 'make -k' will
continue as much as possible after discovering that it does not know how
to make a target or prerequisite file.  This will always cause an error
message, but without '-k', it is a fatal error (*note Summary of
Options: Options Summary.).

   The usual behavior of 'make' assumes that your purpose is to get the
goals up to date; once 'make' learns that this is impossible, it might
as well report the failure immediately.  The '-k' flag says that the
real purpose is to test as much as possible of the changes made in the
program, perhaps to find several independent problems so that you can
correct them all before the next attempt to compile.  This is why Emacs'
'M-x compile' command passes the '-k' flag by default.

==============================================================================
File: make.info,  Node: |Options_Summary|,  Prev: |Testing|,  Up: |Running|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Options_Summary*

9.7 Summary of Options
----------------------

Here is a table of all the options 'make' understands:

'-b'
'-m'
     These options are ignored for compatibility with other versions of
     'make'.

'-B'
'--always-make'
     Consider all targets out-of-date.  GNU 'make' proceeds to consider
     targets and their prerequisites using the normal algorithms;
     however, all targets so considered are always remade regardless of
     the status of their prerequisites.  To avoid infinite recursion, if
     'MAKE_RESTARTS' (*note Other Special Variables: Special Variables.)
     is set to a number greater than 0 this option is disabled when
     considering whether to remake makefiles (*note How Makefiles Are
     Remade: Remaking Makefiles.).

'-C DIR'
'--directory=DIR'
     Change to directory DIR before reading the makefiles.  If multiple
     '-C' options are specified, each is interpreted relative to the
     previous one: '-C / -C etc' is equivalent to '-C /etc'.  This is
     typically used with recursive invocations of 'make' (*note
     Recursive Use of 'make': Recursion.).

'-d'

     Print debugging information in addition to normal processing.  The
     debugging information says which files are being considered for
     remaking, which file-times are being compared and with what
     results, which files actually need to be remade, which implicit
     rules are considered and which are applied--everything interesting
     about how 'make' decides what to do.  The '-d' option is equivalent
     to '--debug=a' (see below).

'--debug[=OPTIONS]'

     Print debugging information in addition to normal processing.
     Various levels and types of output can be chosen.  With no
     arguments, print the "basic" level of debugging.  Possible
     arguments are below; only the first character is considered, and
     values must be comma- or space-separated.

     'a (all)'
          All types of debugging output are enabled.  This is equivalent
          to using '-d'.

     'b (basic)'
          Basic debugging prints each target that was found to be
          out-of-date, and whether the build was successful or not.

     'v (verbose)'
          A level above 'basic'; includes messages about which makefiles
          were parsed, prerequisites that did not need to be rebuilt,
          etc.  This option also enables 'basic' messages.

     'i (implicit)'
          Prints messages describing the implicit rule searches for each
          target.  This option also enables 'basic' messages.

     'j (jobs)'
          Prints messages giving details on the invocation of specific
          sub-commands.

     'm (makefile)'
          By default, the above messages are not enabled while trying to
          remake the makefiles.  This option enables messages while
          rebuilding makefiles, too.  Note that the 'all' option does
          enable this option.  This option also enables 'basic'
          messages.

     'n (none)'
          Disable all debugging currently enabled.  If additional
          debugging flags are encountered after this they will still
          take effect.

'-e'
'--environment-overrides'
     Give variables taken from the environment precedence over variables
     from makefiles.  *Note Variables from the Environment: Environment.

'--eval=STRING'

     Evaluate STRING as makefile syntax.  This is a command-line version
     of the 'eval' function (*note Eval Function::).  The evaluation is
     performed after the default rules and variables have been defined,
     but before any makefiles are read.

'-f FILE'
'--file=FILE'
'--makefile=FILE'
     Read the file named FILE as a makefile.  *Note Writing Makefiles:
     Makefiles.

'-h'
'--help'

     Remind you of the options that 'make' understands and then exit.

'-i'
'--ignore-errors'
     Ignore all errors in recipes executed to remake files.  *Note
     Errors in Recipes: Errors.

'-I DIR'
'--include-dir=DIR'
     Specifies a directory DIR to search for included makefiles.  *Note
     Including Other Makefiles: Include.  If several '-I' options are
     used to specify several directories, the directories are searched
     in the order specified.

'-j [JOBS]'
'--jobs[=JOBS]'
     Specifies the number of recipes (jobs) to run simultaneously.  With
     no argument, 'make' runs as many recipes simultaneously as
     possible.  If there is more than one '-j' option, the last one is
     effective.  *Note Parallel Execution: Parallel, for more
     information on how recipes are run.  Note that this option is
     ignored on MS-DOS.

'-k'
'--keep-going'
     Continue as much as possible after an error.  While the target that
     failed, and those that depend on it, cannot be remade, the other
     prerequisites of these targets can be processed all the same.
     *Note Testing the Compilation of a Program: Testing.

'-l [LOAD]'
'--load-average[=LOAD]'
'--max-load[=LOAD]'
     Specifies that no new recipes should be started if there are other
     recipes running and the load average is at least LOAD (a
     floating-point number).  With no argument, removes a previous load
     limit.  *Note Parallel Execution: Parallel.

'-L'
'--check-symlink-times'
     On systems that support symbolic links, this option causes 'make'
     to consider the timestamps on any symbolic links in addition to the
     timestamp on the file referenced by those links.  When this option
     is provided, the most recent timestamp among the file and the
     symbolic links is taken as the modification time for this target
     file.

'-n'
'--just-print'
'--dry-run'
'--recon'

     Print the recipe that would be executed, but do not execute it
     (except in certain circumstances).  *Note Instead of Executing
     Recipes: Instead of Execution.

'-o FILE'
'--old-file=FILE'
'--assume-old=FILE'
     Do not remake the file FILE even if it is older than its
     prerequisites, and do not remake anything on account of changes in
     FILE.  Essentially the file is treated as very old and its rules
     are ignored.  *Note Avoiding Recompilation of Some Files: Avoiding
     Compilation.

'-O[TYPE]'
'--output-sync[=TYPE]'
     Ensure that the complete output from each recipe is printed in one
     uninterrupted sequence.  This option is only useful when using the
     '--jobs' option to run multiple recipes simultaneously (*note
     Parallel Execution: Parallel.) Without this option output will be
     displayed as it is generated by the recipes.

     With no type or the type 'target', output from the entire recipe of
     each target is grouped together.  With the type 'line', output from
     each line in the recipe is grouped together.  With the type
     'recurse', the output from an entire recursive make is grouped
     together.  With the type 'none', no output synchronization is
     performed.  *Note Output During Parallel Execution: Parallel
     Output.

'-p'
'--print-data-base'
     Print the data base (rules and variable values) that results from
     reading the makefiles; then execute as usual or as otherwise
     specified.  This also prints the version information given by the
     '-v' switch (see below).  To print the data base without trying to
     remake any files, use 'make -qp'.  To print the data base of
     predefined rules and variables, use 'make -p -f /dev/null'.  The
     data base output contains file name and line number information for
     recipe and variable definitions, so it can be a useful debugging
     tool in complex environments.

'-q'
'--question'
     "Question mode".  Do not run any recipes, or print anything; just
     return an exit status that is zero if the specified targets are
     already up to date, one if any remaking is required, or two if an
     error is encountered.  *Note Instead of Executing Recipes: Instead
     of Execution.

'-r'
'--no-builtin-rules'
     Eliminate use of the built-in implicit rules (*note Using Implicit
     Rules: Implicit Rules.).  You can still define your own by writing
     pattern rules (*note Defining and Redefining Pattern Rules: Pattern
     Rules.).  The '-r' option also clears out the default list of
     suffixes for suffix rules (*note Old-Fashioned Suffix Rules: Suffix
     Rules.).  But you can still define your own suffixes with a rule
     for '.SUFFIXES', and then define your own suffix rules.  Note that
     only _rules_ are affected by the '-r' option; default variables
     remain in effect (*note Variables Used by Implicit Rules: Implicit
     Variables.); see the '-R' option below.

'-R'
'--no-builtin-variables'
     Eliminate use of the built-in rule-specific variables (*note
     Variables Used by Implicit Rules: Implicit Variables.).  You can
     still define your own, of course.  The '-R' option also
     automatically enables the '-r' option (see above), since it doesn't
     make sense to have implicit rules without any definitions for the
     variables that they use.

'-s'
'--silent'
'--quiet'

     Silent operation; do not print the recipes as they are executed.
     *Note Recipe Echoing: Echoing.

'-S'
'--no-keep-going'
'--stop'

     Cancel the effect of the '-k' option.  This is never necessary
     except in a recursive 'make' where '-k' might be inherited from the
     top-level 'make' via 'MAKEFLAGS' (*note Recursive Use of 'make':
     Recursion.) or if you set '-k' in 'MAKEFLAGS' in your environment.

'-t'
'--touch'

     Touch files (mark them up to date without really changing them)
     instead of running their recipes.  This is used to pretend that the
     recipes were done, in order to fool future invocations of 'make'.
     *Note Instead of Executing Recipes: Instead of Execution.

'--trace'
     Show tracing information for 'make' execution.  Prints the entire
     recipe to be executed, even for recipes that are normally silent
     (due to '.SILENT' or '@').  Also prints the makefile name and line
     number where the recipe was defined, and information on why the
     target is being rebuilt.

'-v'
'--version'
     Print the version of the 'make' program plus a copyright, a list of
     authors, and a notice that there is no warranty; then exit.

'-w'
'--print-directory'
     Print a message containing the working directory both before and
     after executing the makefile.  This may be useful for tracking down
     errors from complicated nests of recursive 'make' commands.  *Note
     Recursive Use of 'make': Recursion.  (In practice, you rarely need
     to specify this option since 'make' does it for you; see *note The
     '--print-directory' Option: -w Option.)

'--no-print-directory'
     Disable printing of the working directory under '-w'.  This option
     is useful when '-w' is turned on automatically, but you do not want
     to see the extra messages.  *Note The '--print-directory' Option:
     -w Option.

'-W FILE'
'--what-if=FILE'
'--new-file=FILE'
'--assume-new=FILE'
     Pretend that the target FILE has just been modified.  When used
     with the '-n' flag, this shows you what would happen if you were to
     modify that file.  Without '-n', it is almost the same as running a
     'touch' command on the given file before running 'make', except
     that the modification time is changed only in the imagination of
     'make'.  *Note Instead of Executing Recipes: Instead of Execution.

'--warn-undefined-variables'
     Issue a warning message whenever 'make' sees a reference to an
     undefined variable.  This can be helpful when you are trying to
     debug makefiles which use variables in complex ways.

==============================================================================
File: make.info,  Node: |Implicit_Rules|,  Next: |Archives|,  Prev: |Running|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Implicit_Rules*

10 Using Implicit Rules
=======================

Certain standard ways of remaking target files are used very often.  For
example, one customary way to make an object file is from a C source
file using the C compiler, 'cc'.

   "Implicit rules" tell 'make' how to use customary techniques so that
you do not have to specify them in detail when you want to use them.
For example, there is an implicit rule for C compilation.  File names
determine which implicit rules are run.  For example, C compilation
typically takes a '.c' file and makes a '.o' file.  So 'make' applies
the implicit rule for C compilation when it sees this combination of
file name endings.

   A chain of implicit rules can apply in sequence; for example, 'make'
will remake a '.o' file from a '.y' file by way of a '.c' file.

   The built-in implicit rules use several variables in their recipes so
that, by changing the values of the variables, you can change the way
the implicit rule works.  For example, the variable 'CFLAGS' controls
the flags given to the C compiler by the implicit rule for C
compilation.

   You can define your own implicit rules by writing "pattern rules".

   "Suffix rules" are a more limited way to define implicit rules.
Pattern rules are more general and clearer, but suffix rules are
retained for compatibility.

MENU

* |Using_Implicit|::              How to use an existing implicit rule
                                  to get the recipes for updating a file.
* |Catalogue_of_Rules|::          A list of built-in rules.
* |Implicit_Variables|::          How to change what predefined rules do.
* |Chained_Rules|::               How to use a chain of implicit rules.
* |Pattern_Rules|::               How to define new implicit rules.
* |Last_Resort|::                 How to define a recipe for rules which
                                  cannot find any.
* |Suffix_Rules|::                The old-fashioned style of implicit rule.
* |Implicit_Rule_Search|::        The precise algorithm for applying
                                  implicit rules.

==============================================================================
File: make.info,  Node: |Using_Implicit|,  Next: |Catalogue_of_Rules|,  Prev: |Implicit_Rules|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Using_Implicit*

10.1 Using Implicit Rules
-------------------------

To allow 'make' to find a customary method for updating a target file,
all you have to do is refrain from specifying recipes yourself.  Either
write a rule with no recipe, or don't write a rule at all.  Then 'make'
will figure out which implicit rule to use based on which kind of source
file exists or can be made.

   For example, suppose the makefile looks like this:

     foo : foo.o bar.o
             cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)

Because you mention 'foo.o' but do not give a rule for it, 'make' will
automatically look for an implicit rule that tells how to update it.
This happens whether or not the file 'foo.o' currently exists.

   If an implicit rule is found, it can supply both a recipe and one or
more prerequisites (the source files).  You would want to write a rule
for 'foo.o' with no recipe if you need to specify additional
prerequisites, such as header files, that the implicit rule cannot
supply.

   Each implicit rule has a target pattern and prerequisite patterns.
There may be many implicit rules with the same target pattern.  For
example, numerous rules make '.o' files: one, from a '.c' file with the
C compiler; another, from a '.p' file with the Pascal compiler; and so
on.  The rule that actually applies is the one whose prerequisites exist
or can be made.  So, if you have a file 'foo.c', 'make' will run the C
compiler; otherwise, if you have a file 'foo.p', 'make' will run the
Pascal compiler; and so on.

   Of course, when you write the makefile, you know which implicit rule
you want 'make' to use, and you know it will choose that one because you
know which possible prerequisite files are supposed to exist.  *Note
Catalogue of Built-In Rules: Catalogue of Rules, for a catalogue of all
the predefined implicit rules.

   Above, we said an implicit rule applies if the required prerequisites
"exist or can be made".  A file "can be made" if it is mentioned
explicitly in the makefile as a target or a prerequisite, or if an
implicit rule can be recursively found for how to make it.  When an
implicit prerequisite is the result of another implicit rule, we say
that "chaining" is occurring.  *Note Chains of Implicit Rules: Chained
Rules.

   In general, 'make' searches for an implicit rule for each target, and
for each double-colon rule, that has no recipe.  A file that is
mentioned only as a prerequisite is considered a target whose rule
specifies nothing, so implicit rule search happens for it.  *Note
Implicit Rule Search Algorithm: Implicit Rule Search, for the details of
how the search is done.

   Note that explicit prerequisites do not influence implicit rule
search.  For example, consider this explicit rule:

     foo.o: foo.p

The prerequisite on 'foo.p' does not necessarily mean that 'make' will
remake 'foo.o' according to the implicit rule to make an object file, a
'.o' file, from a Pascal source file, a '.p' file.  For example, if
'foo.c' also exists, the implicit rule to make an object file from a C
source file is used instead, because it appears before the Pascal rule
in the list of predefined implicit rules (*note Catalogue of Built-In
Rules: Catalogue of Rules.).

   If you do not want an implicit rule to be used for a target that has
no recipe, you can give that target an empty recipe by writing a
semicolon (*note Defining Empty Recipes: Empty Recipes.).

==============================================================================
File: make.info,  Node: |Catalogue_of_Rules|,  Next: |Implicit_Variables|,  Prev: |Using_Implicit|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Catalogue_of_Rules*

10.2 Catalogue of Built-In Rules
--------------------------------

Here is a catalogue of predefined implicit rules which are always
available unless the makefile explicitly overrides or cancels them.
*Note Canceling Implicit Rules: Canceling Rules, for information on
canceling or overriding an implicit rule.  The '-r' or
'--no-builtin-rules' option cancels all predefined rules.

   This manual only documents the default rules available on POSIX-based
operating systems.  Other operating systems, such as VMS, Windows, OS/2,
etc.  may have different sets of default rules.  To see the full list of
default rules and variables available in your version of GNU 'make', run
'make -p' in a directory with no makefile.

   Not all of these rules will always be defined, even when the '-r'
option is not given.  Many of the predefined implicit rules are
implemented in 'make' as suffix rules, so which ones will be defined
depends on the "suffix list" (the list of prerequisites of the special
target '.SUFFIXES').  The default suffix list is: '.out', '.a', '.ln',
'.o', '.c', '.cc', '.C', '.cpp', '.p', '.f', '.F', '.m', '.r', '.y',
'.l', '.ym', '.lm', '.s', '.S', '.mod', '.sym', '.def', '.h', '.info',
'.dvi', '.tex', '.texinfo', '.texi', '.txinfo', '.w', '.ch' '.web',
'.sh', '.elc', '.el'.  All of the implicit rules described below whose
prerequisites have one of these suffixes are actually suffix rules.  If
you modify the suffix list, the only predefined suffix rules in effect
will be those named by one or two of the suffixes that are on the list
you specify; rules whose suffixes fail to be on the list are disabled.
*Note Old-Fashioned Suffix Rules: Suffix Rules, for full details on
suffix rules.

Compiling C programs
     'N.o' is made automatically from 'N.c' with a recipe of the form
     '$(CC) $(CPPFLAGS) $(CFLAGS) -c'.

Compiling C++ programs
     'N.o' is made automatically from 'N.cc', 'N.cpp', or 'N.C' with a
     recipe of the form '$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c'.  We
     encourage you to use the suffix '.cc' for C++ source files instead
     of '.C'.

Compiling Pascal programs
     'N.o' is made automatically from 'N.p' with the recipe '$(PC)
     $(PFLAGS) -c'.

Compiling Fortran and Ratfor programs
     'N.o' is made automatically from 'N.r', 'N.F' or 'N.f' by running
     the Fortran compiler.  The precise recipe used is as follows:

     '.f'
          '$(FC) $(FFLAGS) -c'.
     '.F'
          '$(FC) $(FFLAGS) $(CPPFLAGS) -c'.
     '.r'
          '$(FC) $(FFLAGS) $(RFLAGS) -c'.

Preprocessing Fortran and Ratfor programs
     'N.f' is made automatically from 'N.r' or 'N.F'.  This rule runs
     just the preprocessor to convert a Ratfor or preprocessable Fortran
     program into a strict Fortran program.  The precise recipe used is
     as follows:

     '.F'
          '$(FC) $(CPPFLAGS) $(FFLAGS) -F'.
     '.r'
          '$(FC) $(FFLAGS) $(RFLAGS) -F'.

Compiling Modula-2 programs
     'N.sym' is made from 'N.def' with a recipe of the form '$(M2C)
     $(M2FLAGS) $(DEFFLAGS)'.  'N.o' is made from 'N.mod'; the form is:
     '$(M2C) $(M2FLAGS) $(MODFLAGS)'.

Assembling and preprocessing assembler programs
     'N.o' is made automatically from 'N.s' by running the assembler,
     'as'.  The precise recipe is '$(AS) $(ASFLAGS)'.

     'N.s' is made automatically from 'N.S' by running the C
     preprocessor, 'cpp'.  The precise recipe is '$(CPP) $(CPPFLAGS)'.

Linking a single object file
     'N' is made automatically from 'N.o' by running the linker (usually
     called 'ld') via the C compiler.  The precise recipe used is
     '$(CC) $(LDFLAGS) N.o $(LOADLIBES) $(LDLIBS)'.

     This rule does the right thing for a simple program with only one
     source file.  It will also do the right thing if there are multiple
     object files (presumably coming from various other source files),
     one of which has a name matching that of the executable file.
     Thus,

          x: y.o z.o

     when 'x.c', 'y.c' and 'z.c' all exist will execute:

          cc -c x.c -o x.o
          cc -c y.c -o y.o
          cc -c z.c -o z.o
          cc x.o y.o z.o -o x
          rm -f x.o
          rm -f y.o
          rm -f z.o

     In more complicated cases, such as when there is no object file
     whose name derives from the executable file name, you must write an
     explicit recipe for linking.

     Each kind of file automatically made into '.o' object files will be
     automatically linked by using the compiler ('$(CC)', '$(FC)' or
     '$(PC)'; the C compiler '$(CC)' is used to assemble '.s' files)
     without the '-c' option.  This could be done by using the '.o'
     object files as intermediates, but it is faster to do the compiling
     and linking in one step, so that's how it's done.

Yacc for C programs
     'N.c' is made automatically from 'N.y' by running Yacc with the
     recipe '$(YACC) $(YFLAGS)'.

Lex for C programs
     'N.c' is made automatically from 'N.l' by running Lex.  The actual
     recipe is '$(LEX) $(LFLAGS)'.

Lex for Ratfor programs
     'N.r' is made automatically from 'N.l' by running Lex.  The actual
     recipe is '$(LEX) $(LFLAGS)'.

     The convention of using the same suffix '.l' for all Lex files
     regardless of whether they produce C code or Ratfor code makes it
     impossible for 'make' to determine automatically which of the two
     languages you are using in any particular case.  If 'make' is
     called upon to remake an object file from a '.l' file, it must
     guess which compiler to use.  It will guess the C compiler, because
     that is more common.  If you are using Ratfor, make sure 'make'
     knows this by mentioning 'N.r' in the makefile.  Or, if you are
     using Ratfor exclusively, with no C files, remove '.c' from the
     list of implicit rule suffixes with:

          .SUFFIXES:
          .SUFFIXES: .o .r .f .l ...

Making Lint Libraries from C, Yacc, or Lex programs
     'N.ln' is made from 'N.c' by running 'lint'.  The precise recipe is
     '$(LINT) $(LINTFLAGS) $(CPPFLAGS) -i'.  The same recipe is used on
     the C code produced from 'N.y' or 'N.l'.

TeX and Web
     'N.dvi' is made from 'N.tex' with the recipe '$(TEX)'.  'N.tex' is
     made from 'N.web' with '$(WEAVE)', or from 'N.w' (and from 'N.ch'
     if it exists or can be made) with '$(CWEAVE)'.  'N.p' is made from
     'N.web' with '$(TANGLE)' and 'N.c' is made from 'N.w' (and from
     'N.ch' if it exists or can be made) with '$(CTANGLE)'.

Texinfo and Info
     'N.dvi' is made from 'N.texinfo', 'N.texi', or 'N.txinfo', with the
     recipe '$(TEXI2DVI) $(TEXI2DVI_FLAGS)'.  'N.info' is made from
     'N.texinfo', 'N.texi', or 'N.txinfo', with the recipe
     '$(MAKEINFO) $(MAKEINFO_FLAGS)'.

RCS
     Any file 'N' is extracted if necessary from an RCS file named
     either 'N,v' or 'RCS/N,v'.  The precise recipe used is
     '$(CO) $(COFLAGS)'.  'N' will not be extracted from RCS if it
     already exists, even if the RCS file is newer.  The rules for RCS
     are terminal (*note Match-Anything Pattern Rules: Match-Anything
     Rules.), so RCS files cannot be generated from another source; they
     must actually exist.

SCCS
     Any file 'N' is extracted if necessary from an SCCS file named
     either 's.N' or 'SCCS/s.N'.  The precise recipe used is
     '$(GET) $(GFLAGS)'.  The rules for SCCS are terminal (*note
     Match-Anything Pattern Rules: Match-Anything Rules.), so SCCS files
     cannot be generated from another source; they must actually exist.

     For the benefit of SCCS, a file 'N' is copied from 'N.sh' and made
     executable (by everyone).  This is for shell scripts that are
     checked into SCCS. Since RCS preserves the execution permission of
     a file, you do not need to use this feature with RCS.

     We recommend that you avoid using of SCCS. RCS is widely held to be
     superior, and is also free.  By choosing free software in place of
     comparable (or inferior) proprietary software, you support the free
     software movement.

   Usually, you want to change only the variables listed in the table
above, which are documented in the following section.

   However, the recipes in built-in implicit rules actually use
variables such as 'COMPILE.c', 'LINK.p', and 'PREPROCESS.S', whose
values contain the recipes listed above.

   'make' follows the convention that the rule to compile a '.X' source
file uses the variable 'COMPILE.X'.  Similarly, the rule to produce an
executable from a '.X' file uses 'LINK.X'; and the rule to preprocess a
'.X' file uses 'PREPROCESS.X'.

   Every rule that produces an object file uses the variable
'OUTPUT_OPTION'.  'make' defines this variable either to contain '-o
$@', or to be empty, depending on a compile-time option.  You need the
'-o' option to ensure that the output goes into the right file when the
source file is in a different directory, as when using 'VPATH' (*note
Directory Search::).  However, compilers on some systems do not accept a
'-o' switch for object files.  If you use such a system, and use
'VPATH', some compilations will put their output in the wrong place.  A
possible workaround for this problem is to give 'OUTPUT_OPTION' the
value '; mv $*.o $@'.

==============================================================================
File: make.info,  Node: |Implicit_Variables|,  Next: |Chained_Rules|,  Prev: |Catalogue_of_Rules|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *Implicit_Variables*

10.3 Variables Used by Implicit Rules
-------------------------------------

The recipes in built-in implicit rules make liberal use of certain
predefined variables.  You can alter the values of these variables in
the makefile, with arguments to 'make', or in the environment to alter
how the implicit rules work without redefining the rules themselves.
You can cancel all variables used by implicit rules with the '-R' or
'--no-builtin-variables' option.

   For example, the recipe used to compile a C source file actually says
'$(CC) -c $(CFLAGS) $(CPPFLAGS)'.  The default values of the variables
used are 'cc' and nothing, resulting in the command 'cc -c'.  By
redefining 'CC' to 'ncc', you could cause 'ncc' to be used for all C
compilations performed by the implicit rule.  By redefining 'CFLAGS' to
be '-g', you could pass the '-g' option to each compilation.  _All_
implicit rules that do C compilation use '$(CC)' to get the program name
for the compiler and _all_ include '$(CFLAGS)' among the arguments given
to the compiler.

   The variables used in implicit rules fall into two classes: those
that are names of programs (like 'CC') and those that contain arguments
for the programs (like 'CFLAGS').  (The "name of a program" may also
contain some command arguments, but it must start with an actual
executable program name.)  If a variable value contains more than one
argument, separate them with spaces.

   The following tables describe of some of the more commonly-used
predefined variables.  This list is not exhaustive, and the default
values shown here may not be what 'make' selects for your environment.
To see the complete list of predefined variables for your instance of
GNU 'make' you can run 'make -p' in a directory with no makefiles.

   Here is a table of some of the more common variables used as names of
programs in built-in rules:

'AR'
     Archive-maintaining program; default 'ar'.

'AS'
     Program for compiling assembly files; default 'as'.

'CC'
     Program for compiling C programs; default 'cc'.

'CXX'
     Program for compiling C++ programs; default 'g++'.

'CPP'
     Program for running the C preprocessor, with results to standard
     output; default '$(CC) -E'.

'FC'
     Program for compiling or preprocessing Fortran and Ratfor programs;
     default 'f77'.

'M2C'
     Program to use to compile Modula-2 source code; default 'm2c'.

'PC'
     Program for compiling Pascal programs; default 'pc'.

'CO'
     Program for extracting a file from RCS; default 'co'.

'GET'
     Program for extracting a file from SCCS; default 'get'.

'LEX'
     Program to use to turn Lex grammars into source code; default
     'lex'.

'YACC'
     Program to use to turn Yacc grammars into source code; default
     'yacc'.

'LINT'
     Program to use to run lint on source code; default 'lint'.

'MAKEINFO'
     Program to convert a Texinfo source file into an Info file; default
     'makeinfo'.

'TEX'
     Program to make TeX DVI files from TeX source; default 'tex'.

'TEXI2DVI'
     Program to make TeX DVI files from Texinfo source; default
     'texi2dvi'.

'WEAVE'
     Program to translate Web into TeX; default 'weave'.

'CWEAVE'
     Program to translate C Web into TeX; default 'cweave'.

'TANGLE'
     Program to translate Web into Pascal; default 'tangle'.

'CTANGLE'
     Program to translate C Web into C; default 'ctangle'.

'RM'
     Command to remove a file; default 'rm -f'.

   Here is a table of variables whose values are additional arguments
for the programs above.  The default values for all of these is the
empty string, unless otherwise noted.

'ARFLAGS'
     Flags to give the archive-maintaining program; default 'rv'.

'ASFLAGS'
     Extra flags to give to the assembler (when explicitly invoked on a
     '.s' or '.S' file).

'CFLAGS'
     Extra flags to give to the C compiler.

'CXXFLAGS'
     Extra flags to give to the C++ compiler.

'COFLAGS'
     Extra flags to give to the RCS 'co' program.

'CPPFLAGS'
     Extra flags to give to the C preprocessor and programs that use it
     (the C and Fortran compilers).

'FFLAGS'
     Extra flags to give to the Fortran compiler.

'GFLAGS'
     Extra flags to give to the SCCS 'get' program.

'LDFLAGS'
     Extra flags to give to compilers when they are supposed to invoke
     the linker, 'ld', such as '-L'.  Libraries ('-lfoo') should be
     added to the 'LDLIBS' variable instead.

'LDLIBS'
     Library flags or names given to compilers when they are supposed to
     invoke the linker, 'ld'.  'LOADLIBES' is a deprecated (but still
     supported) alternative to 'LDLIBS'.  Non-library linker flags, such
     as '-L', should go in the 'LDFLAGS' variable.

'LFLAGS'
     Extra flags to give to Lex.

'YFLAGS'
     Extra flags to give to Yacc.

'PFLAGS'
     Extra flags to give to the Pascal compiler.

'RFLAGS'
     Extra flags to give to the Fortran compiler for Ratfor programs.

'LINTFLAGS'
     Extra flags to give to lint.

==============================================================================
File: make.info,  Node: |Chained_Rules|,  Next: |Pattern_Rules|,  Prev: |Implicit_Variables|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Chained_Rules*

10.4 Chains of Implicit Rules
-----------------------------

Sometimes a file can be made by a sequence of implicit rules.  For
example, a file 'N.o' could be made from 'N.y' by running first Yacc and
then 'cc'.  Such a sequence is called a "chain".

   If the file 'N.c' exists, or is mentioned in the makefile, no special
searching is required: 'make' finds that the object file can be made by
C compilation from 'N.c'; later on, when considering how to make 'N.c',
the rule for running Yacc is used.  Ultimately both 'N.c' and 'N.o' are
updated.

   However, even if 'N.c' does not exist and is not mentioned, 'make'
knows how to envision it as the missing link between 'N.o' and 'N.y'!
In this case, 'N.c' is called an "intermediate file".  Once 'make' has
decided to use the intermediate file, it is entered in the data base as
if it had been mentioned in the makefile, along with the implicit rule
that says how to create it.

   Intermediate files are remade using their rules just like all other
files.  But intermediate files are treated differently in two ways.

   The first difference is what happens if the intermediate file does
not exist.  If an ordinary file B does not exist, and 'make' considers a
target that depends on B, it invariably creates B and then updates the
target from B.  But if B is an intermediate file, then 'make' can leave
well enough alone.  It won't bother updating B, or the ultimate target,
unless some prerequisite of B is newer than that target or there is some
other reason to update that target.

   The second difference is that if 'make' _does_ create B in order to
update something else, it deletes B later on after it is no longer
needed.  Therefore, an intermediate file which did not exist before
'make' also does not exist after 'make'.  'make' reports the deletion to
you by printing a 'rm -f' command showing which file it is deleting.

   Ordinarily, a file cannot be intermediate if it is mentioned in the
makefile as a target or prerequisite.  However, you can explicitly mark
a file as intermediate by listing it as a prerequisite of the special
target '.INTERMEDIATE'.  This takes effect even if the file is mentioned
explicitly in some other way.

   You can prevent automatic deletion of an intermediate file by marking
it as a "secondary" file.  To do this, list it as a prerequisite of the
special target '.SECONDARY'.  When a file is secondary, 'make' will not
create the file merely because it does not already exist, but 'make'
does not automatically delete the file.  Marking a file as secondary
also marks it as intermediate.

   You can list the target pattern of an implicit rule (such as '%.o')
as a prerequisite of the special target '.PRECIOUS' to preserve
intermediate files made by implicit rules whose target patterns match
that file's name; see *note Interrupts::.

   A chain can involve more than two implicit rules.  For example, it is
possible to make a file 'foo' from 'RCS/foo.y,v' by running RCS, Yacc
and 'cc'.  Then both 'foo.y' and 'foo.c' are intermediate files that are
deleted at the end.

   No single implicit rule can appear more than once in a chain.  This
means that 'make' will not even consider such a ridiculous thing as
making 'foo' from 'foo.o.o' by running the linker twice.  This
constraint has the added benefit of preventing any infinite loop in the
search for an implicit rule chain.

   There are some special implicit rules to optimize certain cases that
would otherwise be handled by rule chains.  For example, making 'foo'
from 'foo.c' could be handled by compiling and linking with separate
chained rules, using 'foo.o' as an intermediate file.  But what actually
happens is that a special rule for this case does the compilation and
linking with a single 'cc' command.  The optimized rule is used in
preference to the step-by-step chain because it comes earlier in the
ordering of rules.

==============================================================================
File: make.info,  Node: |Pattern_Rules|,  Next: |Last_Resort|,  Prev: |Chained_Rules|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Pattern_Rules*

10.5 Defining and Redefining Pattern Rules
------------------------------------------

You define an implicit rule by writing a "pattern rule".  A pattern rule
looks like an ordinary rule, except that its target contains the
character '%' (exactly one of them).  The target is considered a pattern
for matching file names; the '%' can match any nonempty substring, while
other characters match only themselves.  The prerequisites likewise use
'%' to show how their names relate to the target name.

   Thus, a pattern rule '%.o : %.c' says how to make any file 'STEM.o'
from another file 'STEM.c'.

   Note that expansion using '%' in pattern rules occurs after any
variable or function expansions, which take place when the makefile is
read.  *Note How to Use Variables: Using Variables, and *note Functions
for Transforming Text: Functions.

MENU

* |Pattern_Intro|::               An introduction to pattern rules.
* |Pattern_Examples|::            Examples of pattern rules.
* |Automatic_Variables|::         How to use automatic variables in the
                                  recipe of implicit rules.
* |Pattern_Match|::               How patterns match.
* |Match_Anything_Rules|::        Precautions you should take prior to
                                  defining rules that can match any
                                  target file whatever.
* |Canceling_Rules|::             How to override or cancel built-in rules.

==============================================================================
File: make.info,  Node: |Pattern_Intro|,  Next: |Pattern_Examples|,  Prev: |Pattern_Rules|,  Up: |Pattern_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Pattern_Intro*

10.5.1 Introduction to Pattern Rules
------------------------------------

A pattern rule contains the character '%' (exactly one of them) in the
target; otherwise, it looks exactly like an ordinary rule.  The target
is a pattern for matching file names; the '%' matches any nonempty
substring, while other characters match only themselves.

   For example, '%.c' as a pattern matches any file name that ends in
'.c'.  's.%.c' as a pattern matches any file name that starts with 's.',
ends in '.c' and is at least five characters long.  (There must be at
least one character to match the '%'.)  The substring that the '%'
matches is called the "stem".

   '%' in a prerequisite of a pattern rule stands for the same stem that
was matched by the '%' in the target.  In order for the pattern rule to
apply, its target pattern must match the file name under consideration
and all of its prerequisites (after pattern substitution) must name
files that exist or can be made.  These files become prerequisites of
the target.

   Thus, a rule of the form

     %.o : %.c ; RECIPE...

specifies how to make a file 'N.o', with another file 'N.c' as its
prerequisite, provided that 'N.c' exists or can be made.

   There may also be prerequisites that do not use '%'; such a
prerequisite attaches to every file made by this pattern rule.  These
unvarying prerequisites are useful occasionally.

   A pattern rule need not have any prerequisites that contain '%', or
in fact any prerequisites at all.  Such a rule is effectively a general
wildcard.  It provides a way to make any file that matches the target
pattern.  *Note Last Resort::.

   More than one pattern rule may match a target.  In this case 'make'
will choose the "best fit" rule.  *Note How Patterns Match: Pattern
Match.

   Pattern rules may have more than one target.  Unlike normal rules,
this does not act as many different rules with the same prerequisites
and recipe.  If a pattern rule has multiple targets, 'make' knows that
the rule's recipe is responsible for making all of the targets.  The
recipe is executed only once to make all the targets.  When searching
for a pattern rule to match a target, the target patterns of a rule
other than the one that matches the target in need of a rule are
incidental: 'make' worries only about giving a recipe and prerequisites
to the file presently in question.  However, when this file's recipe is
run, the other targets are marked as having been updated themselves.

==============================================================================
File: make.info,  Node: |Pattern_Examples|,  Next: |Automatic_Variables|,  Prev: |Pattern_Intro|,  Up: |Pattern_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Pattern_Examples*

10.5.2 Pattern Rule Examples
----------------------------

Here are some examples of pattern rules actually predefined in 'make'.
First, the rule that compiles '.c' files into '.o' files:

     %.o : %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

defines a rule that can make any file 'X.o' from 'X.c'.  The recipe uses
the automatic variables '$@' and '$<' to substitute the names of the
target file and the source file in each case where the rule applies
(*note Automatic Variables::).

   Here is a second built-in rule:

     % :: RCS/%,v
             $(CO) $(COFLAGS) $<

defines a rule that can make any file 'X' whatsoever from a
corresponding file 'X,v' in the sub-directory 'RCS'.  Since the target
is '%', this rule will apply to any file whatever, provided the
appropriate prerequisite file exists.  The double colon makes the rule
"terminal", which means that its prerequisite may not be an intermediate
file (*note Match-Anything Pattern Rules: Match-Anything Rules.).

   This pattern rule has two targets:

     %.tab.c %.tab.h: %.y
             bison -d $<

This tells 'make' that the recipe 'bison -d X.y' will make both
'X.tab.c' and 'X.tab.h'.  If the file 'foo' depends on the files
'parse.tab.o' and 'scan.o' and the file 'scan.o' depends on the file
'parse.tab.h', when 'parse.y' is changed, the recipe 'bison -d parse.y'
will be executed only once, and the prerequisites of both 'parse.tab.o'
and 'scan.o' will be satisfied.  (Presumably the file 'parse.tab.o' will
be recompiled from 'parse.tab.c' and the file 'scan.o' from 'scan.c',
while 'foo' is linked from 'parse.tab.o', 'scan.o', and its other
prerequisites, and it will execute happily ever after.)

==============================================================================
File: make.info,  Node: |Automatic_Variables|,  Next: |Pattern_Match|,  Prev: |Pattern_Examples|,  Up: |Pattern_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Automatic_Variables*

10.5.3 Automatic Variables
--------------------------

Suppose you are writing a pattern rule to compile a '.c' file into a
'.o' file: how do you write the 'cc' command so that it operates on the
right source file name?  You cannot write the name in the recipe,
because the name is different each time the implicit rule is applied.

   What you do is use a special feature of 'make', the "automatic
variables".  These variables have values computed afresh for each rule
that is executed, based on the target and prerequisites of the rule.  In
this example, you would use '$@' for the object file name and '$<' for
the source file name.

   It's very important that you recognize the limited scope in which
automatic variable values are available: they only have values within
the recipe.  In particular, you cannot use them anywhere within the
target list of a rule; they have no value there and will expand to the
empty string.  Also, they cannot be accessed directly within the
prerequisite list of a rule.  A common mistake is attempting to use '$@'
within the prerequisites list; this will not work.  However, there is a
special feature of GNU 'make', secondary expansion (*note Secondary
Expansion::), which will allow automatic variable values to be used in
prerequisite lists.

   Here is a table of automatic variables:

'$@'
     The file name of the target of the rule.  If the target is an
     archive member, then '$@' is the name of the archive file.  In a
     pattern rule that has multiple targets (*note Introduction to
     Pattern Rules: Pattern Intro.), '$@' is the name of whichever
     target caused the rule's recipe to be run.

'$%'
     The target member name, when the target is an archive member.
     *Note Archives::.  For example, if the target is 'foo.a(bar.o)'
     then '$%' is 'bar.o' and '$@' is 'foo.a'.  '$%' is empty when the
     target is not an archive member.

'$<'
     The name of the first prerequisite.  If the target got its recipe
     from an implicit rule, this will be the first prerequisite added by
     the implicit rule (*note Implicit Rules::).

'$?'
     The names of all the prerequisites that are newer than the target,
     with spaces between them.  For prerequisites which are archive
     members, only the named member is used (*note Archives::).

'$^'
     The names of all the prerequisites, with spaces between them.  For
     prerequisites which are archive members, only the named member is
     used (*note Archives::).  A target has only one prerequisite on
     each other file it depends on, no matter how many times each file
     is listed as a prerequisite.  So if you list a prerequisite more
     than once for a target, the value of '$^' contains just one copy of
     the name.  This list does not contain any of the order-only
     prerequisites; for those see the '$|' variable, below.

'$+'
     This is like '$^', but prerequisites listed more than once are
     duplicated in the order they were listed in the makefile.  This is
     primarily useful for use in linking commands where it is meaningful
     to repeat library file names in a particular order.

'$|'
     The names of all the order-only prerequisites, with spaces between
     them.

'$*'
     The stem with which an implicit rule matches (*note How Patterns
     Match: Pattern Match.).  If the target is 'dir/a.foo.b' and the
     target pattern is 'a.%.b' then the stem is 'dir/foo'.  The stem is
     useful for constructing names of related files.

     In a static pattern rule, the stem is part of the file name that
     matched the '%' in the target pattern.

     In an explicit rule, there is no stem; so '$*' cannot be determined
     in that way.  Instead, if the target name ends with a recognized
     suffix (*note Old-Fashioned Suffix Rules: Suffix Rules.), '$*' is
     set to the target name minus the suffix.  For example, if the
     target name is 'foo.c', then '$*' is set to 'foo', since '.c' is a
     suffix.  GNU 'make' does this bizarre thing only for compatibility
     with other implementations of 'make'.  You should generally avoid
     using '$*' except in implicit rules or static pattern rules.

     If the target name in an explicit rule does not end with a
     recognized suffix, '$*' is set to the empty string for that rule.

   '$?' is useful even in explicit rules when you wish to operate on
only the prerequisites that have changed.  For example, suppose that an
archive named 'lib' is supposed to contain copies of several object
files.  This rule copies just the changed object files into the archive:

     lib: foo.o bar.o lose.o win.o
             ar r lib $?

   Of the variables listed above, four have values that are single file
names, and three have values that are lists of file names.  These seven
have variants that get just the file's directory name or just the file
name within the directory.  The variant variables' names are formed by
appending 'D' or 'F', respectively.  These variants are semi-obsolete in
GNU 'make' since the functions 'dir' and 'notdir' can be used to get a
similar effect (*note Functions for File Names: File Name Functions.).
Note, however, that the 'D' variants all omit the trailing slash which
always appears in the output of the 'dir' function.  Here is a table of
the variants:

'$(@D)'
     The directory part of the file name of the target, with the
     trailing slash removed.  If the value of '$@' is 'dir/foo.o' then
     '$(@D)' is 'dir'.  This value is '.' if '$@' does not contain a
     slash.

'$(@F)'
     The file-within-directory part of the file name of the target.  If
     the value of '$@' is 'dir/foo.o' then '$(@F)' is 'foo.o'.  '$(@F)'
     is equivalent to '$(notdir $@)'.

'$(*D)'
'$(*F)'
     The directory part and the file-within-directory part of the stem;
     'dir' and 'foo' in this example.

'$(%D)'
'$(%F)'
     The directory part and the file-within-directory part of the target
     archive member name.  This makes sense only for archive member
     targets of the form 'ARCHIVE(MEMBER)' and is useful only when
     MEMBER may contain a directory name.  (*Note Archive Members as
     Targets: Archive Members.)

'$(<D)'
'$(<F)'
     The directory part and the file-within-directory part of the first
     prerequisite.

'$(^D)'
'$(^F)'
     Lists of the directory parts and the file-within-directory parts of
     all prerequisites.

'$(+D)'
'$(+F)'
     Lists of the directory parts and the file-within-directory parts of
     all prerequisites, including multiple instances of duplicated
     prerequisites.

'$(?D)'
'$(?F)'
     Lists of the directory parts and the file-within-directory parts of
     all prerequisites that are newer than the target.

   Note that we use a special stylistic convention when we talk about
these automatic variables; we write "the value of '$<'", rather than
"the variable '<'" as we would write for ordinary variables such as
'objects' and 'CFLAGS'.  We think this convention looks more natural in
this special case.  Please do not assume it has a deep significance;
'$<' refers to the variable named '<' just as '$(CFLAGS)' refers to the
variable named 'CFLAGS'.  You could just as well use '$(<)' in place of
'$<'.

==============================================================================
File: make.info,  Node: |Pattern_Match|,  Next: |Match_Anything_Rules|,  Prev: |Automatic_Variables|,  Up: |Pattern_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Pattern_Match*

10.5.4 How Patterns Match
-------------------------

A target pattern is composed of a '%' between a prefix and a suffix,
either or both of which may be empty.  The pattern matches a file name
only if the file name starts with the prefix and ends with the suffix,
without overlap.  The text between the prefix and the suffix is called
the "stem".  Thus, when the pattern '%.o' matches the file name
'test.o', the stem is 'test'.  The pattern rule prerequisites are turned
into actual file names by substituting the stem for the character '%'.
Thus, if in the same example one of the prerequisites is written as
'%.c', it expands to 'test.c'.

   When the target pattern does not contain a slash (and it usually does
not), directory names in the file names are removed from the file name
before it is compared with the target prefix and suffix.  After the
comparison of the file name to the target pattern, the directory names,
along with the slash that ends them, are added on to the prerequisite
file names generated from the pattern rule's prerequisite patterns and
the file name.  The directories are ignored only for the purpose of
finding an implicit rule to use, not in the application of that rule.
Thus, 'e%t' matches the file name 'src/eat', with 'src/a' as the stem.
When prerequisites are turned into file names, the directories from the
stem are added at the front, while the rest of the stem is substituted
for the '%'.  The stem 'src/a' with a prerequisite pattern 'c%r' gives
the file name 'src/car'.

   A pattern rule can be used to build a given file only if there is a
target pattern that matches the file name, _and_ all prerequisites in
that rule either exist or can be built.  The rules you write take
precedence over those that are built in.  Note however, that a rule
whose prerequisites actually exist or are mentioned always takes
priority over a rule with prerequisites that must be made by chaining
other implicit rules.

   It is possible that more than one pattern rule will meet these
criteria.  In that case, 'make' will choose the rule with the shortest
stem (that is, the pattern that matches most specifically).  If more
than one pattern rule has the shortest stem, 'make' will choose the
first one found in the makefile.

   This algorithm results in more specific rules being preferred over
more generic ones; for example:

     %.o: %.c
             $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

     %.o : %.f
             $(COMPILE.F) $(OUTPUT_OPTION) $<

     lib/%.o: lib/%.c
             $(CC) -fPIC -c $(CFLAGS) $(CPPFLAGS) $< -o $@

   Given these rules and asked to build 'bar.o' where both 'bar.c' and
'bar.f' exist, 'make' will choose the first rule and compile 'bar.c'
into 'bar.o'.  In the same situation where 'bar.c' does not exist, then
'make' will choose the second rule and compile 'bar.f' into 'bar.o'.

   If 'make' is asked to build 'lib/bar.o' and both 'lib/bar.c' and
'lib/bar.f' exist, then the third rule will be chosen since the stem for
this rule ('bar') is shorter than the stem for the first rule
('lib/bar').  If 'lib/bar.c' does not exist then the third rule is not
eligible and the second rule will be used, even though the stem is
longer.

==============================================================================
File: make.info,  Node: |Match_Anything_Rules|,  Next: |Canceling_Rules|,  Prev: |Pattern_Match|,  Up: |Pattern_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Match_Anything_Rules*

10.5.5 Match-Anything Pattern Rules
-----------------------------------

When a pattern rule's target is just '%', it matches any file name
whatever.  We call these rules "match-anything" rules.  They are very
useful, but it can take a lot of time for 'make' to think about them,
because it must consider every such rule for each file name listed
either as a target or as a prerequisite.

   Suppose the makefile mentions 'foo.c'.  For this target, 'make' would
have to consider making it by linking an object file 'foo.c.o', or by C
compilation-and-linking in one step from 'foo.c.c', or by Pascal
compilation-and-linking from 'foo.c.p', and many other possibilities.

   We know these possibilities are ridiculous since 'foo.c' is a C
source file, not an executable.  If 'make' did consider these
possibilities, it would ultimately reject them, because files such as
'foo.c.o' and 'foo.c.p' would not exist.  But these possibilities are so
numerous that 'make' would run very slowly if it had to consider them.

   To gain speed, we have put various constraints on the way 'make'
considers match-anything rules.  There are two different constraints
that can be applied, and each time you define a match-anything rule you
must choose one or the other for that rule.

   One choice is to mark the match-anything rule as "terminal" by
defining it with a double colon.  When a rule is terminal, it does not
apply unless its prerequisites actually exist.  Prerequisites that could
be made with other implicit rules are not good enough.  In other words,
no further chaining is allowed beyond a terminal rule.

   For example, the built-in implicit rules for extracting sources from
RCS and SCCS files are terminal; as a result, if the file 'foo.c,v' does
not exist, 'make' will not even consider trying to make it as an
intermediate file from 'foo.c,v.o' or from 'RCS/SCCS/s.foo.c,v'.  RCS
and SCCS files are generally ultimate source files, which should not be
remade from any other files; therefore, 'make' can save time by not
looking for ways to remake them.

   If you do not mark the match-anything rule as terminal, then it is
non-terminal.  A non-terminal match-anything rule cannot apply to a file
name that indicates a specific type of data.  A file name indicates a
specific type of data if some non-match-anything implicit rule target
matches it.

   For example, the file name 'foo.c' matches the target for the pattern
rule '%.c : %.y' (the rule to run Yacc).  Regardless of whether this
rule is actually applicable (which happens only if there is a file
'foo.y'), the fact that its target matches is enough to prevent
consideration of any non-terminal match-anything rules for the file
'foo.c'.  Thus, 'make' will not even consider trying to make 'foo.c' as
an executable file from 'foo.c.o', 'foo.c.c', 'foo.c.p', etc.

   The motivation for this constraint is that non-terminal
match-anything rules are used for making files containing specific types
of data (such as executable files) and a file name with a recognized
suffix indicates some other specific type of data (such as a C source
file).

   Special built-in dummy pattern rules are provided solely to recognize
certain file names so that non-terminal match-anything rules will not be
considered.  These dummy rules have no prerequisites and no recipes, and
they are ignored for all other purposes.  For example, the built-in
implicit rule

     %.p :

exists to make sure that Pascal source files such as 'foo.p' match a
specific target pattern and thereby prevent time from being wasted
looking for 'foo.p.o' or 'foo.p.c'.

   Dummy pattern rules such as the one for '%.p' are made for every
suffix listed as valid for use in suffix rules (*note Old-Fashioned
Suffix Rules: Suffix Rules.).

==============================================================================
File: make.info,  Node: |Canceling_Rules|,  Prev: |Match_Anything_Rules|,  Up: |Pattern_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Canceling_Rules*

10.5.6 Canceling Implicit Rules
-------------------------------

You can override a built-in implicit rule (or one you have defined
yourself) by defining a new pattern rule with the same target and
prerequisites, but a different recipe.  When the new rule is defined,
the built-in one is replaced.  The new rule's position in the sequence
of implicit rules is determined by where you write the new rule.

   You can cancel a built-in implicit rule by defining a pattern rule
with the same target and prerequisites, but no recipe.  For example, the
following would cancel the rule that runs the assembler:

     %.o : %.s

==============================================================================
File: make.info,  Node: |Last_Resort|,  Next: |Suffix_Rules|,  Prev: |Pattern_Rules|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Last_Resort*

10.6 Defining Last-Resort Default Rules
---------------------------------------

You can define a last-resort implicit rule by writing a terminal
match-anything pattern rule with no prerequisites (*note Match-Anything
Rules::).  This is just like any other pattern rule; the only thing
special about it is that it will match any target.  So such a rule's
recipe is used for all targets and prerequisites that have no recipe of
their own and for which no other implicit rule applies.

   For example, when testing a makefile, you might not care if the
source files contain real data, only that they exist.  Then you might do
this:

     %::
             touch $@

to cause all the source files needed (as prerequisites) to be created
automatically.

   You can instead define a recipe to be used for targets for which
there are no rules at all, even ones which don't specify recipes.  You
do this by writing a rule for the target '.DEFAULT'.  Such a rule's
recipe is used for all prerequisites which do not appear as targets in
any explicit rule, and for which no implicit rule applies.  Naturally,
there is no '.DEFAULT' rule unless you write one.

   If you use '.DEFAULT' with no recipe or prerequisites:

     .DEFAULT:

the recipe previously stored for '.DEFAULT' is cleared.  Then 'make'
acts as if you had never defined '.DEFAULT' at all.

   If you do not want a target to get the recipe from a match-anything
pattern rule or '.DEFAULT', but you also do not want any recipe to be
run for the target, you can give it an empty recipe (*note Defining
Empty Recipes: Empty Recipes.).

   You can use a last-resort rule to override part of another makefile.
*Note Overriding Part of Another Makefile: Overriding Makefiles.

==============================================================================
File: make.info,  Node: |Suffix_Rules|,  Next: |Implicit_Rule_Search|,  Prev: |Last_Resort|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *Suffix_Rules*

10.7 Old-Fashioned Suffix Rules
-------------------------------

"Suffix rules" are the old-fashioned way of defining implicit rules for
'make'.  Suffix rules are obsolete because pattern rules are more
general and clearer.  They are supported in GNU 'make' for compatibility
with old makefiles.  They come in two kinds: "double-suffix" and
"single-suffix".

   A double-suffix rule is defined by a pair of suffixes: the target
suffix and the source suffix.  It matches any file whose name ends with
the target suffix.  The corresponding implicit prerequisite is made by
replacing the target suffix with the source suffix in the file name.  A
two-suffix rule whose target and source suffixes are '.o' and '.c' is
equivalent to the pattern rule '%.o : %.c'.

   A single-suffix rule is defined by a single suffix, which is the
source suffix.  It matches any file name, and the corresponding implicit
prerequisite name is made by appending the source suffix.  A
single-suffix rule whose source suffix is '.c' is equivalent to the
pattern rule '% : %.c'.

   Suffix rule definitions are recognized by comparing each rule's
target against a defined list of known suffixes.  When 'make' sees a
rule whose target is a known suffix, this rule is considered a
single-suffix rule.  When 'make' sees a rule whose target is two known
suffixes concatenated, this rule is taken as a double-suffix rule.

   For example, '.c' and '.o' are both on the default list of known
suffixes.  Therefore, if you define a rule whose target is '.c.o',
'make' takes it to be a double-suffix rule with source suffix '.c' and
target suffix '.o'.  Here is the old-fashioned way to define the rule
for compiling a C source file:

     .c.o:
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

   Suffix rules cannot have any prerequisites of their own.  If they
have any, they are treated as normal files with funny names, not as
suffix rules.  Thus, the rule:

     .c.o: foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

tells how to make the file '.c.o' from the prerequisite file 'foo.h',
and is not at all like the pattern rule:

     %.o: %.c foo.h
             $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

which tells how to make '.o' files from '.c' files, and makes all '.o'
files using this pattern rule also depend on 'foo.h'.

   Suffix rules with no recipe are also meaningless.  They do not remove
previous rules as do pattern rules with no recipe (*note Canceling
Implicit Rules: Canceling Rules.).  They simply enter the suffix or pair
of suffixes concatenated as a target in the data base.

   The known suffixes are simply the names of the prerequisites of the
special target '.SUFFIXES'.  You can add your own suffixes by writing a
rule for '.SUFFIXES' that adds more prerequisites, as in:

     .SUFFIXES: .hack .win

which adds '.hack' and '.win' to the end of the list of suffixes.

   If you wish to eliminate the default known suffixes instead of just
adding to them, write a rule for '.SUFFIXES' with no prerequisites.  By
special dispensation, this eliminates all existing prerequisites of
'.SUFFIXES'.  You can then write another rule to add the suffixes you
want.  For example,

     .SUFFIXES:            # Delete the default suffixes
     .SUFFIXES: .c .o .h   # Define our suffix list

   The '-r' or '--no-builtin-rules' flag causes the default list of
suffixes to be empty.

   The variable 'SUFFIXES' is defined to the default list of suffixes
before 'make' reads any makefiles.  You can change the list of suffixes
with a rule for the special target '.SUFFIXES', but that does not alter
this variable.

==============================================================================
File: make.info,  Node: |Implicit_Rule_Search|,  Prev: |Suffix_Rules|,  Up: |Implicit_Rules|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Implicit_Rule_Search*

10.8 Implicit Rule Search Algorithm
-----------------------------------

Here is the procedure 'make' uses for searching for an implicit rule for
a target T.  This procedure is followed for each double-colon rule with
no recipe, for each target of ordinary rules none of which have a
recipe, and for each prerequisite that is not the target of any rule.
It is also followed recursively for prerequisites that come from
implicit rules, in the search for a chain of rules.

   Suffix rules are not mentioned in this algorithm because suffix rules
are converted to equivalent pattern rules once the makefiles have been
read in.

   For an archive member target of the form 'ARCHIVE(MEMBER)', the
following algorithm is run twice, first using the entire target name T,
and second using '(MEMBER)' as the target T if the first run found no
rule.

  1. Split T into a directory part, called D, and the rest, called N.
     For example, if T is 'src/foo.o', then D is 'src/' and N is
     'foo.o'.

  2. Make a list of all the pattern rules one of whose targets matches T
     or N.  If the target pattern contains a slash, it is matched
     against T; otherwise, against N.

  3. If any rule in that list is _not_ a match-anything rule, then
     remove all non-terminal match-anything rules from the list.

  4. Remove from the list all rules with no recipe.

  5. For each pattern rule in the list:

       a. Find the stem S, which is the nonempty part of T or N matched
          by the '%' in the target pattern.

       b. Compute the prerequisite names by substituting S for '%'; if
          the target pattern does not contain a slash, append D to the
          front of each prerequisite name.

       c. Test whether all the prerequisites exist or ought to exist.
          (If a file name is mentioned in the makefile as a target or as
          an explicit prerequisite, then we say it ought to exist.)

          If all prerequisites exist or ought to exist, or there are no
          prerequisites, then this rule applies.

  6. If no pattern rule has been found so far, try harder.  For each
     pattern rule in the list:

       a. If the rule is terminal, ignore it and go on to the next rule.

       b. Compute the prerequisite names as before.

       c. Test whether all the prerequisites exist or ought to exist.

       d. For each prerequisite that does not exist, follow this
          algorithm recursively to see if the prerequisite can be made
          by an implicit rule.

       e. If all prerequisites exist, ought to exist, or can be made by
          implicit rules, then this rule applies.

  7. If no implicit rule applies, the rule for '.DEFAULT', if any,
     applies.  In that case, give T the same recipe that '.DEFAULT' has.
     Otherwise, there is no recipe for T.

   Once a rule that applies has been found, for each target pattern of
the rule other than the one that matched T or N, the '%' in the pattern
is replaced with S and the resultant file name is stored until the
recipe to remake the target file T is executed.  After the recipe is
executed, each of these stored file names are entered into the data base
and marked as having been updated and having the same update status as
the file T.

   When the recipe of a pattern rule is executed for T, the automatic
variables are set corresponding to the target and prerequisites.  *Note
Automatic Variables::.

==============================================================================
File: make.info,  Node: |Archives|,  Next: |Extending_make|,  Prev: |Implicit_Rules|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Archives*

11 Using 'make' to Update Archive Files
=======================================

"Archive files" are files containing named sub-files called "members";
they are maintained with the program 'ar' and their main use is as
subroutine libraries for linking.

MENU

* |Archive_Members|::             Archive members as targets.
* |Archive_Update|::              The implicit rule for archive member targets.
* |Archive_Pitfalls|::            Dangers to watch out for when using archives.
* |Archive_Suffix_Rules|::        You can write a special kind of suffix rule
                                  for updating archives.

==============================================================================
File: make.info,  Node: |Archive_Members|,  Next: |Archive_Update|,  Prev: |Archives|,  Up: |Archives|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Archive_Members*

11.1 Archive Members as Targets
-------------------------------

An individual member of an archive file can be used as a target or
prerequisite in 'make'.  You specify the member named MEMBER in archive
file ARCHIVE as follows:

     ARCHIVE(MEMBER)

This construct is available only in targets and prerequisites, not in
recipes!  Most programs that you might use in recipes do not support
this syntax and cannot act directly on archive members.  Only 'ar' and
other programs specifically designed to operate on archives can do so.
Therefore, valid recipes to update an archive member target probably
must use 'ar'.  For example, this rule says to create a member 'hack.o'
in archive 'foolib' by copying the file 'hack.o':

     foolib(hack.o) : hack.o
             ar cr foolib hack.o

   In fact, nearly all archive member targets are updated in just this
way and there is an implicit rule to do it for you.  *Please note:* The
'c' flag to 'ar' is required if the archive file does not already exist.

   To specify several members in the same archive, you can write all the
member names together between the parentheses.  For example:

     foolib(hack.o kludge.o)

is equivalent to:

     foolib(hack.o) foolib(kludge.o)

   You can also use shell-style wildcards in an archive member
reference.  *Note Using Wildcard Characters in File Names: Wildcards.
For example, 'foolib(*.o)' expands to all existing members of the
'foolib' archive whose names end in '.o'; perhaps 'foolib(hack.o)
foolib(kludge.o)'.

==============================================================================
File: make.info,  Node: |Archive_Update|,  Next: |Archive_Pitfalls|,  Prev: |Archive_Members|,  Up: |Archives|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Archive_Update*

11.2 Implicit Rule for Archive Member Targets
---------------------------------------------

Recall that a target that looks like 'A(M)' stands for the member named
M in the archive file A.

   When 'make' looks for an implicit rule for such a target, as a
special feature it considers implicit rules that match '(M)', as well as
those that match the actual target 'A(M)'.

   This causes one special rule whose target is '(%)' to match.  This
rule updates the target 'A(M)' by copying the file M into the archive.
For example, it will update the archive member target 'foo.a(bar.o)' by
copying the _file_ 'bar.o' into the archive 'foo.a' as a _member_ named
'bar.o'.

   When this rule is chained with others, the result is very powerful.
Thus, 'make "foo.a(bar.o)"' (the quotes are needed to protect the '('
and ')' from being interpreted specially by the shell) in the presence
of a file 'bar.c' is enough to cause the following recipe to be run,
even without a makefile:

     cc -c bar.c -o bar.o
     ar r foo.a bar.o
     rm -f bar.o

Here 'make' has envisioned the file 'bar.o' as an intermediate file.
*Note Chains of Implicit Rules: Chained Rules.

   Implicit rules such as this one are written using the automatic
variable '$%'.  *Note Automatic Variables::.

   An archive member name in an archive cannot contain a directory name,
but it may be useful in a makefile to pretend that it does.  If you
write an archive member target 'foo.a(dir/file.o)', 'make' will perform
automatic updating with this recipe:

     ar r foo.a dir/file.o

which has the effect of copying the file 'dir/file.o' into a member
named 'file.o'.  In connection with such usage, the automatic variables
'%D' and '%F' may be useful.

MENU

* |Archive_Symbols|::             How to update archive symbol directories.

==============================================================================
File: make.info,  Node: |Archive_Symbols|,  Prev: |Archive_Update|,  Up: |Archive_Update|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Archive_Symbols*

11.2.1 Updating Archive Symbol Directories
------------------------------------------

An archive file that is used as a library usually contains a special
member named '__.SYMDEF' that contains a directory of the external
symbol names defined by all the other members.  After you update any
other members, you need to update '__.SYMDEF' so that it will summarize
the other members properly.  This is done by running the 'ranlib'
program:

     ranlib ARCHIVEFILE

   Normally you would put this command in the rule for the archive file,
and make all the members of the archive file prerequisites of that rule.
For example,

     libfoo.a: libfoo.a(x.o) libfoo.a(y.o) ...
             ranlib libfoo.a

The effect of this is to update archive members 'x.o', 'y.o', etc., and
then update the symbol directory member '__.SYMDEF' by running 'ranlib'.
The rules for updating the members are not shown here; most likely you
can omit them and use the implicit rule which copies files into the
archive, as described in the preceding section.

   This is not necessary when using the GNU 'ar' program, which updates
the '__.SYMDEF' member automatically.

==============================================================================
File: make.info,  Node: |Archive_Pitfalls|,  Next: |Archive_Suffix_Rules|,  Prev: |Archive_Update|,  Up: |Archives|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Archive_Pitfalls*

11.3 Dangers When Using Archives
--------------------------------

It is important to be careful when using parallel execution (the '-j'
switch; *note Parallel Execution: Parallel.) and archives.  If multiple
'ar' commands run at the same time on the same archive file, they will
not know about each other and can corrupt the file.

   Possibly a future version of 'make' will provide a mechanism to
circumvent this problem by serializing all recipes that operate on the
same archive file.  But for the time being, you must either write your
makefiles to avoid this problem in some other way, or not use '-j'.

==============================================================================
File: make.info,  Node: |Archive_Suffix_Rules|,  Prev: |Archive_Pitfalls|,  Up: |Archives|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Archive_Suffix_Rules*

11.4 Suffix Rules for Archive Files
-----------------------------------

You can write a special kind of suffix rule for dealing with archive
files.  *Note Suffix Rules::, for a full explanation of suffix rules.
Archive suffix rules are obsolete in GNU 'make', because pattern rules
for archives are a more general mechanism (*note Archive Update::).  But
they are retained for compatibility with other 'make's.

   To write a suffix rule for archives, you simply write a suffix rule
using the target suffix '.a' (the usual suffix for archive files).  For
example, here is the old-fashioned suffix rule to update a library
archive from C source files:

     .c.a:
             $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
             $(AR) r $@ $*.o
             $(RM) $*.o

This works just as if you had written the pattern rule:

     (%.o): %.c
             $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
             $(AR) r $@ $*.o
             $(RM) $*.o

   In fact, this is just what 'make' does when it sees a suffix rule
with '.a' as the target suffix.  Any double-suffix rule '.X.a' is
converted to a pattern rule with the target pattern '(%.o)' and a
prerequisite pattern of '%.X'.

   Since you might want to use '.a' as the suffix for some other kind of
file, 'make' also converts archive suffix rules to pattern rules in the
normal way (*note Suffix Rules::).  Thus a double-suffix rule '.X.a'
produces two pattern rules: '(%.o): %.X' and '%.a: %.X'.

==============================================================================
File: make.info,  Node: |Extending_make|,  Next: |Integrating_make|,  Prev: |Archives|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *Extending_make*

12 Extending GNU 'make'
=======================

GNU 'make' provides many advanced capabilities, including many useful
functions.  However, it does not contain a complete programming language
and so it has limitations.  Sometimes these limitations can be overcome
through use of the 'shell' function to invoke a separate program,
although this can be inefficient.

   In cases where the built-in capabilities of GNU 'make' are
insufficient to your requirements there are two options for extending
'make'.  On systems where it's provided, you can utilize GNU Guile as an
embedded scripting language (*note GNU Guile Integration: Guile
Integration.).  On systems which support dynamically loadable objects,
you can write your own extension in any language (which can be compiled
into such an object) and load it to provide extended capabilities (*note
The 'load' Directive: load Directive.).

MENU

* |Guile_Integration|::           Using Guile as an embedded scripting language.
* |Loading_Objects|::             Loading dynamic objects as extensions.

==============================================================================
File: make.info,  Node: |Guile_Integration|,  Next: |Loading_Objects|,  Prev: |Extending_make|,  Up: |Extending_make|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Guile_Integration*

12.1 GNU Guile Integration
--------------------------

GNU 'make' may be built with support for GNU Guile as an embedded
extension language.  Guile implements the Scheme language.  A review of
GNU Guile and the Scheme language and its features is beyond the scope
of this manual: see the documentation for GNU Guile and Scheme.

   You can determine if 'make' contains support for Guile by examining
the '.FEATURES' variable; it will contain the word GUILE if Guile
support is available.

   The Guile integration provides one new 'make' function: 'guile'.  The
'guile' function takes one argument which is first expanded by 'make' in
the normal fashion, then passed to the GNU Guile evaluator.  The result
of the evaluator is converted into a string and used as the expansion of
the 'guile' function in the makefile.

   In addition, GNU 'make' exposes Guile procedures for use in Guile
scripts.

MENU

* |Guile_Types|::                 Converting Guile types to 'make' strings.
* |Guile_Interface|::             Invoking 'make' functions from Guile.
* |Guile_Example|::               Example using Guile in 'make'.

==============================================================================
File: make.info,  Node: |Guile_Types|,  Next: |Guile_Interface|,  Prev: |Guile_Integration|,  Up: |Guile_Integration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *Guile_Types*

12.1.1 Conversion of Guile Types
--------------------------------

There is only one "data type" in 'make': a string.  GNU Guile, on the
other hand, provides a rich variety of different data types.  An
important aspect of the interface between 'make' and GNU Guile is the
conversion of Guile data types into 'make' strings.

   This conversion is relevant in two places: when a makefile invokes
the 'guile' function to evaluate a Guile expression, the result of that
evaluation must be converted into a make string so it can be further
evaluated by 'make'.  And secondly, when a Guile script invokes one of
the procedures exported by 'make' the argument provided to the procedure
must be converted into a string.

   The conversion of Guile types into 'make' strings is as below:

'#f'
     False is converted into the empty string: in 'make' conditionals
     the empty string is considered false.

'#t'
     True is converted to the string '#t': in 'make' conditionals any
     non-empty string is considered true.

'symbol'
'number'
     A symbol or number is converted into the string representation of
     that symbol or number.

'character'
     A printable character is converted to the same character.

'string'
     A string containing only printable characters is converted to the
     same string.

'list'
     A list is converted recursively according to the above rules.  This
     implies that any structured list will be flattened (that is, a
     result of ''(a b (c d) e)' will be converted to the 'make' string
     'a b c d e').

'other'
     Any other Guile type results in an error.  In future versions of
     'make', other Guile types may be converted.

   The translation of '#f' (to the empty string) and '#t' (to the
non-empty string '#t') is designed to allow you to use Guile boolean
results directly as 'make' boolean conditions.  For example:

     $(if $(guile (access? "myfile" R_OK)),$(info myfile exists))

   As a consequence of these conversion rules you must consider the
result of your Guile script, as that result will be converted into a
string and parsed by 'make'.  If there is no natural result for the
script (that is, the script exists solely for its side-effects), you
should add '#f' as the final expression in order to avoid syntax errors
in your makefile.

==============================================================================
File: make.info,  Node: |Guile_Interface|,  Next: |Guile_Example|,  Prev: |Guile_Types|,  Up: |Guile_Integration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Guile_Interface*

12.1.2 Interfaces from Guile to 'make'
--------------------------------------

In addition to the 'guile' function available in makefiles, 'make'
exposes some procedures for use in your Guile scripts.  At startup
'make' creates a new Guile module, 'gnu make', and exports these
procedures as public interfaces from that module:

'gmk-expand'
     This procedure takes a single argument which is converted into a
     string.  The string is expanded by 'make' using normal 'make'
     expansion rules.  The result of the expansion is converted into a
     Guile string and provided as the result of the procedure.

'gmk-eval'
     This procedure takes a single argument which is converted into a
     string.  The string is evaluated by 'make' as if it were a
     makefile.  This is the same capability available via the 'eval'
     function (*note Eval Function::).  The result of the 'gmk-eval'
     procedure is always the empty string.

     Note that 'gmk-eval' is not quite the same as using 'gmk-expand'
     with the 'eval' function: in the latter case the evaluated string
     will be expanded _twice_; first by 'gmk-expand', then again by the
     'eval' function.

==============================================================================
File: make.info,  Node: |Guile_Example|,  Prev: |Guile_Interface|,  Up: |Guile_Integration|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *Guile_Example*

12.1.3 Example Using Guile in 'make'
------------------------------------

Here is a very simple example using GNU Guile to manage writing to a
file.  These Guile procedures simply open a file, allow writing to the
file (one string per line), and close the file.  Note that because we
cannot store complex values such as Guile ports in 'make' variables,
we'll keep the port as a global variable in the Guile interpreter.

   You can create Guile functions easily using 'define'/'endef' to
create a Guile script, then use the 'guile' function to internalize it:

     define GUILEIO
     ;; A simple Guile IO library for GNU make

     (define MKPORT #f)

     (define (mkopen name mode)
       (set! MKPORT (open-file name mode))
       #f)

     (define (mkwrite s)
       (display s MKPORT)
       (newline MKPORT)
       #f)

     (define (mkclose)
       (close-port MKPORT)
       #f)

     #f
     endef

     # Internalize the Guile IO functions
     $(guile $(GUILEIO))

   If you have a significant amount of Guile support code, you might
consider keeping it in a different file (e.g., 'guileio.scm') and then
loading it in your makefile using the 'guile' function:

     $(guile (load "guileio.scm"))

   An advantage to this method is that when editing 'guileio.scm', your
editor will understand that this file contains Scheme syntax rather than
makefile syntax.

   Now you can use these Guile functions to create files.  Suppose you
need to operate on a very large list, which cannot fit on the command
line, but the utility you're using accepts the list as input as well:

     prog: $(PREREQS)
             @$(guile (mkopen "tmp.out" "w")) \
              $(foreach X,$^,$(guile (mkwrite "$(X)"))) \
              $(guile (mkclose))
             $(LINK) < tmp.out

   A more comprehensive suite of file manipulation procedures is
possible of course.  You could, for example, maintain multiple output
files at the same time by choosing a symbol for each one and using it as
the key to a hash table, where the value is a port, then returning the
symbol to be stored in a 'make' variable.

==============================================================================
File: make.info,  Node: |Loading_Objects|,  Prev: Guile Integration,  Up: |Extending_make|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Loading_Objects*

12.2 Loading Dynamic Objects
----------------------------

     Warning: The 'load' directive and extension capability is
     considered a "technology preview" in this release of GNU make.  We
     encourage you to experiment with this feature and we appreciate any
     feedback on it.  However we cannot guarantee to maintain
     backward-compatibility in the next release.  Consider using GNU
     Guile instead for extending GNU make (*note The 'guile' Function:
     Guile Function.).

   Many operating systems provide a facility for dynamically loading
compiled objects.  If your system provides this facility, GNU 'make' can
make use of it to load dynamic objects at runtime, providing new
capabilities which may then be invoked by your makefile.

   The 'load' directive is used to load a dynamic object.  Once the
object is loaded, a "setup" function will be invoked to allow the object
to initialize itself and register new facilities with GNU 'make'.  A
dynamic object might include new 'make' functions, for example, and the
"setup" function would register them with GNU 'make''s function handling
system.

MENU

* |load_Directive|::              Loading dynamic objects as extensions.
* |Remaking_Loaded_Objects|::     How loaded objects get remade.
* |Loaded_Object_API|::           Programmatic interface for loaded objects.
* |Loaded_Object_Example|::       Example of a loaded object

==============================================================================
File: make.info,  Node: |load_Directive|,  Next: |Remaking_Loaded_Objects|,  Prev: |Loading_Objects|,  Up: |Loading_Objects|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *load_Directive*

12.2.1 The 'load' Directive
---------------------------

Objects are loaded into GNU 'make' by placing the 'load' directive into
your makefile.  The syntax of the 'load' directive is as follows:

     load OBJECT-FILE ...

   or:

     load OBJECT-FILE(SYMBOL-NAME) ...

   The file OBJECT-FILE is dynamically loaded by GNU 'make'.  If
OBJECT-FILE does not include a directory path then it is first looked
for in the current directory.  If it is not found there, or a directory
path is included, then system-specific paths will be searched.  If the
load fails for any reason, 'make' will print a message and exit.

   If the load succeeds 'make' will invoke an initializing function.

   If SYMBOL-NAME is provided, it will be used as the name of the
initializing function.

   If no SYMBOL-NAME is provided, the initializing function name is
created by taking the base file name of OBJECT-FILE, up to the first
character which is not a valid symbol name character (alphanumerics and
underscores are valid symbol name characters).  To this prefix will be
appended the suffix '_gmk_setup'.

   More than one object file may be loaded with a single 'load'
directive, and both forms of 'load' arguments may be used in the same
directive.

   The initializing function will be provided the file name and line
number of the invocation of the 'load' operation.  It should return a
value of type 'int', which must be '0' on failure and non-'0' on
success.  If the return value is '-1', then GNU make will _not_ attempt
to rebuild the object file (*note How Loaded Objects Are Remade:
Remaking Loaded Objects.).

   For example:

     load ../mk_funcs.so

   will load the dynamic object '../mk_funcs.so'.  After the object is
loaded, 'make' will invoke the function (assumed to be defined by the
shared object) 'mk_funcs_gmk_setup'.

   On the other hand:

     load ../mk_funcs.so(init_mk_func)

   will load the dynamic object '../mk_funcs.so'.  After the object is
loaded, 'make' will invoke the function 'init_mk_func'.

   Regardless of how many times an object file appears in a 'load'
directive, it will only be loaded (and its setup function will only be
invoked) once.

   After an object has been successfully loaded, its file name is
appended to the '.LOADED' variable.

   If you would prefer that failure to load a dynamic object not be
reported as an error, you can use the '-load' directive instead of
'load'.  GNU 'make' will not fail and no message will be generated if an
object fails to load.  The failed object is not added to the '.LOADED'
variable, which can then be consulted to determine if the load was
successful.

==============================================================================
File: make.info,  Node: |Remaking_Loaded_Objects|,  Next: |Loaded_Object_API|,  Prev: |load_Directive|,  Up: |Loading_Objects|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Remaking_Loaded_Objects*

12.2.2 How Loaded Objects Are Remade
------------------------------------

Loaded objects undergo the same re-make procedure as makefiles (*note
How Makefiles Are Remade: Remaking Makefiles.).  If any loaded object is
recreated, then 'make' will start from scratch and re-read all the
makefiles, and reload the object files again.  It is not necessary for
the loaded object to do anything special to support this.

   It's up to the makefile author to provide the rules needed for
rebuilding the loaded object.

==============================================================================
File: make.info,  Node: |Loaded_Object_API|,  Next: |Loaded_Object_Example|,  Prev: |Remaking_Loaded_Objects|,  Up: |Loading_Objects|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Loaded_Object_API*

12.2.3 Loaded Object Interface
------------------------------

     Warning: For this feature to be useful your extensions will need to
     invoke various functions internal to GNU 'make'.  The programming
     interfaces provided in this release should not be considered
     stable: functions may be added, removed, or change calling
     signatures or implementations in future versions of GNU 'make'.

   To be useful, loaded objects must be able to interact with GNU
'make'.  This interaction includes both interfaces the loaded object
provides to makefiles and also interfaces 'make' provides to the loaded
object to manipulate 'make''s operation.

   The interface between loaded objects and 'make' is defined by the
'gnumake.h' C header file.  All loaded objects written in C should
include this header file.  Any loaded object not written in C will need
to implement the interface defined in this header file.

   Typically, a loaded object will register one or more new GNU 'make'
functions using the 'gmk_add_function' routine from within its setup
function.  The implementations of these 'make' functions may make use of
the 'gmk_expand' and 'gmk_eval' routines to perform their tasks, then
optionally return a string as the result of the function expansion.

Loaded Object Licensing
-----------------------

Every dynamic extension should define the global symbol
'plugin_is_GPL_compatible' to assert that it has been licensed under a
GPL-compatible license.  If this symbol does not exist, 'make' emits a
fatal error and exits when it tries to load your extension.

   The declared type of the symbol should be 'int'.  It does not need to
be in any allocated section, though.  The code merely asserts that the
symbol exists in the global scope.  Something like this is enough:

     int plugin_is_GPL_compatible;

Data Structures
---------------

'gmk_floc'
     This structure represents a filename/location pair.  It is provided
     when defining items, so GNU 'make' can inform the user later where
     the definition occurred if necessary.

Registering Functions
---------------------

There is currently one way for makefiles to invoke operations provided
by the loaded object: through the 'make' function call interface.  A
loaded object can register one or more new functions which may then be
invoked from within the makefile in the same way as any other function.

   Use 'gmk_add_function' to create a new 'make' function.  Its
arguments are as follows:

'name'
     The function name.  This is what the makefile should use to invoke
     the function.  The name must be between 1 and 255 characters long
     and it may only contain alphanumeric, period ('.'), dash ('-'), and
     underscore ('_') characters.  It may not begin with a period.

'func_ptr'
     A pointer to a function that 'make' will invoke when it expands the
     function in a makefile.  This function must be defined by the
     loaded object.

'min_args'
     The minimum number of arguments the function will accept.  Must be
     between 0 and 255.  GNU 'make' will check this and fail before
     invoking 'func_ptr' if the function was invoked with too few
     arguments.

'max_args'
     The maximum number of arguments the function will accept.  Must be
     between 0 and 255.  GNU 'make' will check this and fail before
     invoking 'func_ptr' if the function was invoked with too few
     arguments.  If the value is 0, then any number of arguments is
     accepted.  If the value is greater than 0, then it must be greater
     than or equal to 'min_args'.

'flags'
     Flags that specify how this function will operate; the desired
     flags should be OR'd together.  If the 'GMK_FUNC_NOEXPAND' flag is
     given then the function arguments will not be expanded before the
     function is called; otherwise they will be expanded first.

Registered Function Interface
-----------------------------

A function registered with 'make' must match the 'gmk_func_ptr' type.
It will be invoked with three parameters: 'name' (the name of the
function), 'argc' (the number of arguments to the function), and 'argv'
(an array of pointers to arguments to the function).  The last pointer
(that is, 'argv[argc]') will be null ('0').

   The return value of the function is the result of expanding the
function.  If the function expands to nothing the return value may be
null.  Otherwise, it must be a pointer to a string created with
'gmk_alloc'.  Once the function returns, 'make' owns this string and
will free it when appropriate; it cannot be accessed by the loaded
object.

GNU 'make' Facilities
---------------------

There are some facilities exported by GNU 'make' for use by loaded
objects.  Typically these would be run from within the setup function
and/or the functions registered via 'gmk_add_function', to retrieve or
modify the data 'make' works with.

'gmk_expand'
     This function takes a string and expands it using 'make' expansion
     rules.  The result of the expansion is returned in a nil-terminated
     string buffer.  The caller is responsible for calling 'gmk_free'
     with a pointer to the returned buffer when done.

'gmk_eval'
     This function takes a buffer and evaluates it as a segment of
     makefile syntax.  This function can be used to define new
     variables, new rules, etc.  It is equivalent to using the 'eval'
     'make' function.

   Note that there is a difference between 'gmk_eval' and calling
'gmk_expand' with a string using the 'eval' function: in the latter case
the string will be expanded _twice_; once by 'gmk_expand' and then again
by the 'eval' function.  Using 'gmk_eval' the buffer is only expanded
once, at most (as it's read by the 'make' parser).

Memory Management
-----------------

Some systems allow for different memory management schemes.  Thus you
should never pass memory that you've allocated directly to any 'make'
function, nor should you attempt to directly free any memory returned to
you by any 'make' function.  Instead, use the 'gmk_alloc' and 'gmk_free'
functions.

   In particular, the string returned to 'make' by a function registered
using 'gmk_add_function' _must_ be allocated using 'gmk_alloc', and the
string returned from the 'make' 'gmk_expand' function _must_ be freed
(when no longer needed) using 'gmk_free'.

'gmk_alloc'
     Return a pointer to a newly-allocated buffer.  This function will
     always return a valid pointer; if not enough memory is available
     'make' will exit.

'gmk_free'
     Free a buffer returned to you by 'make'.  Once the 'gmk_free'
     function returns the string will no longer be valid.

==============================================================================
File: make.info,  Node: |Loaded_Object_Example|,  Prev: |Loaded_Object_API|,  Up: |Loading_Objects|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *Loaded_Object_Example*

12.2.4 Example Loaded Object
----------------------------

Let's suppose we wanted to write a new GNU 'make' function that would
create a temporary file and return its name.  We would like our function
to take a prefix as an argument.  First we can write the function in a
file 'mk_temp.c':

     #include <stdlib.h>
     #include <stdlib.h>
     #include <stdio.h>
     #include <string.h>
     #include <unistd.h>
     #include <errno.h>

     #include <gnumake.h>

     int plugin_is_GPL_compatible;

     char *
     gen_tmpfile(const char *nm, int argc, char **argv)
     {
       int fd;

       /* Compute the size of the filename and allocate space for it.  */
       int len = strlen (argv[0]) + 6 + 1;
       char *buf = gmk_alloc (len);

       strcpy (buf, argv[0]);
       strcat (buf, "XXXXXX");

       fd = mkstemp(buf);
       if (fd >= 0)
         {
           /* Don't leak the file descriptor.  */
           close (fd);
           return buf;
         }

       /* Failure.  */
       fprintf (stderr, "mkstemp(%s) failed: %s\n", buf, strerror (errno));
       gmk_free (buf);
       return NULL;
     }

     int
     mk_temp_gmk_setup ()
     {
       /* Register the function with make name "mk-temp".  */
       gmk_add_function ("mk-temp", gen_tmpfile, 1, 1, 1);
       return 1;
     }

   Next, we will write a makefile that can build this shared object,
load it, and use it:

     all:
             @echo Temporary file: $(mk-temp tmpfile.)

     load mk_temp.so

     mk_temp.so: mk_temp.c
             $(CC) -shared -fPIC -o $ $<

   On MS-Windows, due to peculiarities of how shared objects are
produced, the compiler needs to scan the "import library" produced when
building 'make', typically called 'libgnumake-VERSION.dll.a', where
VERSION is the version of the load object API. So the recipe to produce
a shared object will look on Windows like this (assuming the API version
is 1):

     mk_temp.dll: mk_temp.c
             $(CC) -shared -o $ $< -lgnumake-1

   Now when you run 'make' you'll see something like:

     $ make
     cc -shared -fPIC -o mk_temp.so mk_temp.c
     Temporary filename: tmpfile.A7JEwd

==============================================================================
File: make.info,  Node: |Integrating_make|,  Next: |Features|,  Prev: |Extending_make|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  *Integrating_make*

13 Integrating GNU 'make'
=========================

GNU 'make' is often one component in a larger system of tools, including
integrated development environments, compiler toolchains, and others.
The role of 'make' is to start commands and determine whether they
succeeded or not: no special integration is needed to accomplish that.
However, sometimes it is convenient to bind 'make' more tightly with
other parts of the system, both higher-level (tools that invoke 'make')
and lower-level (tools that 'make' invokes).

MENU

* |Job_Slots|::                   Share job slots with GNU 'make'.
* |Terminal_Output|::             Control output to terminals.

==============================================================================
File: make.info,  Node: |Job_Slots|,  Next: |Terminal_Output|,  Prev: |Integrating_make|,  Up: |Integrating_make|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *Job_Slots*

13.1 Sharing Job Slots with GNU 'make'
--------------------------------------

GNU 'make' has the ability to run multiple recipes in parallel (*note
Parallel Execution: Parallel.) and to cap the total number of parallel
jobs even across recursive invocations of 'make' (*note Communicating
Options to a Sub-'make': Options/Recursion.).  Tools that 'make' invokes
which are also able to run multiple operations in parallel, either using
multiple threads or multiple processes, can be enhanced to participate
in GNU 'make''s job management facility to ensure that the total number
of active threads/processes running on the system does not exceed the
maximum number of slots provided to GNU 'make'.

   GNU 'make' uses a method called the "jobserver" to control the number
of active jobs across recursive invocations.  The actual implementation
of the jobserver varies across different operating systems, but some
fundamental aspects are always true.

   First, only command lines that 'make' understands to be recursive
invocations of 'make' (*note How the 'MAKE' Variable Works: MAKE
Variable.) will have access to the jobserver.  When writing makefiles
you must be sure to mark the command as recursive (most commonly by
prefixing the command line with the '+' indicator (*note Recursive Use
of 'make': Recursion.).

   Second, 'make' will provide information necessary for accessing the
jobserver through the environment to its children, in the 'MAKEFLAGS'
environment variable.  Tools which want to participate in the jobserver
protocol will need to parse this environment variable, as described in
subsequent sections.

   Third, every command 'make' starts has one implicit job slot reserved
for it before it starts.  Any tool which wants to participate in the
jobserver protocol should assume it can always run one job without
having to contact the jobserver at all.

   Finally, it's critical that tools that participate in the jobserver
protocol return the exact number of slots they obtained from the
jobserver back to the jobserver before they exit, even under error
conditions.  Remember that the implicit job slot should not be
returned to the jobserver!  Returning too few slots means that those
slots will be lost for the rest of the build process; returning too many
slots means that extra slots will be available.  The top-level 'make'
command will print an error message at the end of the build if it
detects an incorrect number of slots available in the jobserver.

   As an example, suppose you are implementing a linker which provides
for multithreaded operation.  You would like to enhance the linker so
that if it is invoked by GNU 'make' it can participate in the jobserver
protocol to control how many threads are used during link.  First you
will need to modify the linker to determine if the 'MAKEFLAGS'
environment variable is set.  Next you will need to parse the value of
that variable to determine if the jobserver is available, and how to
access it.  If it is available then you can access it to obtain job
slots controlling how much parallelism your tool can use.  Once done
your tool must return those job slots back to the jobserver.

MENU

* |POSIX_Jobserver|::             Using the jobserver on POSIX systems.
* |Windows_Jobserver|::           Using the jobserver on Windows systems.

==============================================================================
File: make.info,  Node: |POSIX_Jobserver|,  Next: |Windows_Jobserver|,  Prev: |Job_Slots|,  Up: |Job_Slots|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *POSIX_Jobserver*

13.1.1 POSIX Jobserver Interaction
----------------------------------

On POSIX systems the jobserver is implemented as a simple UNIX pipe.
The pipe will be pre-loaded with one single-character token for each
available job.  To obtain an extra slot you must read a single character
from the jobserver pipe; to release a slot you must write a single
character back into the jobserver pipe.

   To access the pipe you must parse the 'MAKEFLAGS' variable and look
for the argument string '--jobserver-auth=R,W' where 'R' and 'W' are
non-negative integers representing file descriptors: 'R' is the read
file descriptor and 'W' is the write file descriptor.

   It's important that when you release the job slot, you write back the
same character you read from the pipe for that slot.  Don't assume that
all tokens are the same character; different characters may have
different meanings to GNU 'make'.  The order is not important, since
'make' has no idea in what order jobs will complete anyway.

   There are various error conditions you must consider to ensure your
implementation is robust:

   * Usually you will have a command-line argument controlling the
     parallel operation of your tool.  Consider whether your tool should
     detect situations where both the jobserver and the command-line
     argument are specified, and how it should react.

   * If your tool determines that the '--jobserver-auth' option is
     available in 'MAKEFLAGS' but that the file descriptors specified
     are closed, this means that the calling 'make' process did not
     think that your tool was a recursive 'make' invocation (e.g., the
     command line was not prefixed with a '+' character).  You should
     notify your users of this situation.

   * Your tool should also examine the first word of the 'MAKEFLAGS'
     variable and look for the character 'n'.  If this character is
     present then 'make' was invoked with the '-n' option and your tool
     should stop without performing any operations.

   * Your tool should be sure to write back the tokens it read, even
     under error conditions.  This includes not only errors in your tool
     but also outside influences such as interrupts ('SIGINT'), etc.
     You may want to install signal handlers to manage this write-back.

==============================================================================
File: make.info,  Node: |Windows_Jobserver|,  Prev: |POSIX_Jobserver|,  Up: |Job_Slots|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Windows_Jobserver*

13.1.2 Windows Jobserver Interaction
------------------------------------

On Windows systems the jobserver is implemented as a named semaphore.
The semaphore will be set with an initial count equal to the number of
available slots; to obtain a slot you must wait on the semaphore (with
or without a timeout).  To release a slot, release the semaphore.

   To access the semaphore you must parse the 'MAKEFLAGS' variable and
look for the argument string '--jobserver-auth=NAME' where 'NAME' is the
name of the named semaphore.  Use this name with 'OpenSemaphore' to
create a handle to the semaphore.

   There are various error conditions you must consider to ensure your
implementation is robust:

   * Usually you will have a command-line argument controlling the
     parallel operation of your tool.  Consider whether your tool should
     detect situations where both the jobserver and the command-line
     argument are specified, and how it should react.

   * Your tool should be sure to release the semaphore for the tokens it
     read, even under error conditions.  This includes not only errors
     in your tool but also outside influences such as interrupts
     ('SIGINT'), etc.  You may want to install signal handlers to manage
     this write-back.

==============================================================================
File: make.info,  Node: |Terminal_Output|,  Prev: Job Slots,  Up: |Integrating_make|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Terminal_Output*

13.2 Synchronized Terminal Output
---------------------------------

Normally GNU 'make' will invoke all commands with access to the same
standard and error outputs that 'make' itself was started with.  A
number of tools will detect whether the output is a terminal or
not-a-terminal, and use this information to change the output style.
For example if the output goes to a terminal the tool may add control
characters that set color, or even change the location of the cursor.
If the output is not going to a terminal then these special control
characters are not emitted so that they don't corrupt log files, etc.

   The '--output-sync' (*note Output During Parallel Output: Parallel
Output.) option will defeat the terminal detection.  When output
synchronization is enabled GNU 'make' arranges for all command output to
be written to a file, so that its output can be written as a block
without interference from other commands.  This means that all tools
invoked by 'make' will believe that their output is not going to be
displayed on a terminal, even when it will be (because 'make' will
display it there after the command is completed).

   In order to facilitate tools which would like to determine whether or
not their output will be displayed on a terminal, GNU 'make' will set
the 'MAKE_TERMOUT' and 'MAKE_TERMERR' environment variables before
invoking any commands.  Tools which would like to determine whether
standard or error output (respectively) will be displayed on a terminal
can check these environment variables to determine if they exist and
contain a non-empty value.  If so the tool can assume that the output
will (eventually) be displayed on a terminal.  If the variables are not
set or have an empty value, then the tool should fall back to its normal
methods of detecting whether output is going to a terminal or not.

   The content of the variables can be parsed to determine the type of
terminal which will be used to display the output.

   Similarly, environments which invoke 'make' and would like to capture
the output and eventually display it on a terminal (or some display
which can interpret terminal control characters) can set these variables
before invoking 'make'.  GNU 'make' will not modify these environment
variables if they already exist when it starts.

==============================================================================
File: make.info,  Node: |Features|,  Next: |Missing|,  Prev: |Integrating_make|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *Features*

14 Features of GNU 'make'
=========================

Here is a summary of the features of GNU 'make', for comparison with and
credit to other versions of 'make'.  We consider the features of 'make'
in 4.2 BSD systems as a baseline.  If you are concerned with writing
portable makefiles, you should not use the features of 'make' listed
here, nor the ones in *note Missing::.

   Many features come from the version of 'make' in System V.

   * The 'VPATH' variable and its special meaning.  *Note Searching
     Directories for Prerequisites: Directory Search.  This feature
     exists in System V 'make', but is undocumented.  It is documented
     in 4.3 BSD 'make' (which says it mimics System V's 'VPATH'
     feature).

   * Included makefiles.  *Note Including Other Makefiles: Include.
     Allowing multiple files to be included with a single directive is a
     GNU extension.

   * Variables are read from and communicated via the environment.
     *Note Variables from the Environment: Environment.

   * Options passed through the variable 'MAKEFLAGS' to recursive
     invocations of 'make'.  *Note Communicating Options to a
     Sub-'make': Options/Recursion.

   * The automatic variable '$%' is set to the member name in an archive
     reference.  *Note Automatic Variables::.

   * The automatic variables '$@', '$*', '$<', '$%', and '$?' have
     corresponding forms like '$(@F)' and '$(@D)'.  We have generalized
     this to '$^' as an obvious extension.  *Note Automatic Variables::.

   * Substitution variable references.  *Note Basics of Variable
     References: Reference.

   * The command line options '-b' and '-m', accepted and ignored.  In
     System V 'make', these options actually do something.

   * Execution of recursive commands to run 'make' via the variable
     'MAKE' even if '-n', '-q' or '-t' is specified.  *Note Recursive
     Use of 'make': Recursion.

   * Support for suffix '.a' in suffix rules.  *Note Archive Suffix
     Rules::.  This feature is obsolete in GNU 'make', because the
     general feature of rule chaining (*note Chains of Implicit Rules:
     Chained Rules.) allows one pattern rule for installing members in
     an archive (*note Archive Update::) to be sufficient.

   * The arrangement of lines and backslash/newline combinations in
     recipes is retained when the recipes are printed, so they appear as
     they do in the makefile, except for the stripping of initial
     whitespace.

   The following features were inspired by various other versions of
'make'.  In some cases it is unclear exactly which versions inspired
which others.

   * Pattern rules using '%'.  This has been implemented in several
     versions of 'make'.  We're not sure who invented it first, but it's
     been spread around a bit.  *Note Defining and Redefining Pattern
     Rules: Pattern Rules.

   * Rule chaining and implicit intermediate files.  This was
     implemented by Stu Feldman in his version of 'make' for AT&T Eighth
     Edition Research Unix, and later by Andrew Hume of AT&T Bell Labs
     in his 'mk' program (where he terms it "transitive closure").  We
     do not really know if we got this from either of them or thought it
     up ourselves at the same time.  *Note Chains of Implicit Rules:
     Chained Rules.

   * The automatic variable '$^' containing a list of all prerequisites
     of the current target.  We did not invent this, but we have no idea
     who did.  *Note Automatic Variables::.  The automatic variable '$+'
     is a simple extension of '$^'.

   * The "what if" flag ('-W' in GNU 'make') was (as far as we know)
     invented by Andrew Hume in 'mk'.  *Note Instead of Executing
     Recipes: Instead of Execution.

   * The concept of doing several things at once (parallelism) exists in
     many incarnations of 'make' and similar programs, though not in the
     System V or BSD implementations.  *Note Recipe Execution:
     Execution.

   * A number of different build tools that support parallelism also
     support collecting output and displaying as a single block.  *Note
     Output During Parallel Execution: Parallel Output.

   * Modified variable references using pattern substitution come from
     SunOS 4.  *Note Basics of Variable References: Reference.  This
     functionality was provided in GNU 'make' by the 'patsubst' function
     before the alternate syntax was implemented for compatibility with
     SunOS 4.  It is not altogether clear who inspired whom, since GNU
     'make' had 'patsubst' before SunOS 4 was released.

   * The special significance of '+' characters preceding recipe lines
     (*note Instead of Executing Recipes: Instead of Execution.) is
     mandated by 'IEEE Standard 1003.2-1992' (POSIX.2).

   * The '+=' syntax to append to the value of a variable comes from
     SunOS 4 'make'.  *Note Appending More Text to Variables: Appending.

   * The syntax 'ARCHIVE(MEM1 MEM2...)' to list multiple members in a
     single archive file comes from SunOS 4 'make'.  *Note Archive
     Members::.

   * The '-include' directive to include makefiles with no error for a
     nonexistent file comes from SunOS 4 'make'.  (But note that SunOS 4
     'make' does not allow multiple makefiles to be specified in one
     '-include' directive.)  The same feature appears with the name
     'sinclude' in SGI 'make' and perhaps others.

   * The '!=' shell assignment operator exists in many BSD of 'make' and
     is purposefully implemented here to behave identically to those
     implementations.

   * Various build management tools are implemented using scripting
     languages such as Perl or Python and thus provide a natural
     embedded scripting language, similar to GNU 'make''s integration of
     GNU Guile.

   The remaining features are inventions new in GNU 'make':

   * Use the '-v' or '--version' option to print version and copyright
     information.

   * Use the '-h' or '--help' option to summarize the options to 'make'.

   * Simply-expanded variables.  *Note The Two Flavors of Variables:
     Flavors.

   * Pass command line variable assignments automatically through the
     variable 'MAKE' to recursive 'make' invocations.  *Note Recursive
     Use of 'make': Recursion.

   * Use the '-C' or '--directory' command option to change directory.
     *Note Summary of Options: Options Summary.

   * Make verbatim variable definitions with 'define'.  *Note Defining
     Multi-Line Variables: Multi-Line.

   * Declare phony targets with the special target '.PHONY'.

     Andrew Hume of AT&T Bell Labs implemented a similar feature with a
     different syntax in his 'mk' program.  This seems to be a case of
     parallel discovery.  *Note Phony Targets: Phony Targets.

   * Manipulate text by calling functions.  *Note Functions for
     Transforming Text: Functions.

   * Use the '-o' or '--old-file' option to pretend a file's
     modification-time is old.  *Note Avoiding Recompilation of Some
     Files: Avoiding Compilation.

   * Conditional execution.

     This feature has been implemented numerous times in various
     versions of 'make'; it seems a natural extension derived from the
     features of the C preprocessor and similar macro languages and is
     not a revolutionary concept.  *Note Conditional Parts of Makefiles:
     Conditionals.

   * Specify a search path for included makefiles.  *Note Including
     Other Makefiles: Include.

   * Specify extra makefiles to read with an environment variable.
     *Note The Variable 'MAKEFILES': MAKEFILES Variable.

   * Strip leading sequences of './' from file names, so that './FILE'
     and 'FILE' are considered to be the same file.

   * Use a special search method for library prerequisites written in
     the form '-lNAME'.  *Note Directory Search for Link Libraries:
     Libraries/Search.

   * Allow suffixes for suffix rules (*note Old-Fashioned Suffix Rules:
     Suffix Rules.) to contain any characters.  In other versions of
     'make', they must begin with '.' and not contain any '/'
     characters.

   * Keep track of the current level of 'make' recursion using the
     variable 'MAKELEVEL'.  *Note Recursive Use of 'make': Recursion.

   * Provide any goals given on the command line in the variable
     'MAKECMDGOALS'.  *Note Arguments to Specify the Goals: Goals.

   * Specify static pattern rules.  *Note Static Pattern Rules: Static
     Pattern.

   * Provide selective 'vpath' search.  *Note Searching Directories for
     Prerequisites: Directory Search.

   * Provide computed variable references.  *Note Basics of Variable
     References: Reference.

   * Update makefiles.  *Note How Makefiles Are Remade: Remaking
     Makefiles.  System V 'make' has a very, very limited form of this
     functionality in that it will check out SCCS files for makefiles.

   * Various new built-in implicit rules.  *Note Catalogue of Built-In
     Rules: Catalogue of Rules.

   * Load dynamic objects which can modify the behavior of 'make'.
     *Note Loading Dynamic Objects: Loading Objects.

==============================================================================
File: make.info,  Node: |Missing|,  Next: |Makefile_Conventions|,  Prev: |Features|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *Missing*

15 Incompatibilities and Missing Features
=========================================

The 'make' programs in various other systems support a few features that
are not implemented in GNU 'make'.  The POSIX.2 standard ('IEEE Standard
1003.2-1992') which specifies 'make' does not require any of these
features.

   * A target of the form 'FILE((ENTRY))' stands for a member of archive
     file FILE.  The member is chosen, not by name, but by being an
     object file which defines the linker symbol ENTRY.

     This feature was not put into GNU 'make' because of the
     non-modularity of putting knowledge into 'make' of the internal
     format of archive file symbol tables.  *Note Updating Archive
     Symbol Directories: Archive Symbols.

   * Suffixes (used in suffix rules) that end with the character '~'
     have a special meaning to System V 'make'; they refer to the SCCS
     file that corresponds to the file one would get without the '~'.
     For example, the suffix rule '.c~.o' would make the file 'N.o' from
     the SCCS file 's.N.c'.  For complete coverage, a whole series of
     such suffix rules is required.  *Note Old-Fashioned Suffix Rules:
     Suffix Rules.

     In GNU 'make', this entire series of cases is handled by two
     pattern rules for extraction from SCCS, in combination with the
     general feature of rule chaining.  *Note Chains of Implicit Rules:
     Chained Rules.

   * In System V and 4.3 BSD 'make', files found by 'VPATH' search
     (*note Searching Directories for Prerequisites: Directory Search.)
     have their names changed inside recipes.  We feel it is much
     cleaner to always use automatic variables and thus make this
     feature obsolete.

   * In some Unix 'make's, the automatic variable '$*' appearing in the
     prerequisites of a rule has the amazingly strange "feature" of
     expanding to the full name of the _target of that rule_.  We cannot
     imagine what went on in the minds of Unix 'make' developers to do
     this; it is utterly inconsistent with the normal definition of
     '$*'.

   * In some Unix 'make's, implicit rule search (*note Using Implicit
     Rules: Implicit Rules.) is apparently done for _all_ targets, not
     just those without recipes.  This means you can do:

          foo.o:
                  cc -c foo.c

     and Unix 'make' will intuit that 'foo.o' depends on 'foo.c'.

     We feel that such usage is broken.  The prerequisite properties of
     'make' are well-defined (for GNU 'make', at least), and doing such
     a thing simply does not fit the model.

   * GNU 'make' does not include any built-in implicit rules for
     compiling or preprocessing EFL programs.  If we hear of anyone who
     is using EFL, we will gladly add them.

   * It appears that in SVR4 'make', a suffix rule can be specified with
     no recipe, and it is treated as if it had an empty recipe (*note
     Empty Recipes::).  For example:

          .c.a:

     will override the built-in '.c.a' suffix rule.

     We feel that it is cleaner for a rule without a recipe to always
     simply add to the prerequisite list for the target.  The above
     example can be easily rewritten to get the desired behavior in GNU
     'make':

          .c.a: ;

   * Some versions of 'make' invoke the shell with the '-e' flag, except
     under '-k' (*note Testing the Compilation of a Program: Testing.).
     The '-e' flag tells the shell to exit as soon as any program it
     runs returns a nonzero status.  We feel it is cleaner to write each
     line of the recipe to stand on its own and not require this special
     treatment.

==============================================================================
File: make.info,  Node: |Makefile_Conventions|,  Next: |Quick_Reference|,  Prev: |Missing|,  Up: |Top|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              *Makefile_Conventions*

16 Makefile Conventions
=======================

This node describes conventions for writing the Makefiles for GNU
programs.  Using Automake will help you write a Makefile that follows
these conventions.  For more information on portable Makefiles, see
POSIX and *note Portable Make Programming: (autoconf)Portable Make.

MENU

* |Makefile_Basics|::             General conventions for Makefiles.
* |Utilities_in_Makefiles|::      Utilities to be used in Makefiles.
* |Command_Variables|::           Variables for specifying commands.
* |DESTDIR|::                     Supporting staged installs.
* |Directory_Variables|::         Variables for installation directories.
* |Standard_Targets|::            Standard targets for users.
* |Install_Command_Categories|::  Three categories of commands in the 'install'
                                  rule: normal, pre-install and post-install.

==============================================================================
File: make.info,  Node: |Makefile_Basics|,  Next: |Utilities_in_Makefiles|,  Up: |Makefile_Conventions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   *Makefile_Basics*

16.1 General Conventions for Makefiles
--------------------------------------

Every Makefile should contain this line:

     SHELL = /bin/sh

to avoid trouble on systems where the 'SHELL' variable might be
inherited from the environment.  (This is never a problem with GNU
'make'.)

   Different 'make' programs have incompatible suffix lists and implicit
rules, and this sometimes creates confusion or misbehavior.  So it is a
good idea to set the suffix list explicitly using only the suffixes you
need in the particular Makefile, like this:

     .SUFFIXES:
     .SUFFIXES: .c .o

The first line clears out the suffix list, the second introduces all
suffixes which may be subject to implicit rules in this Makefile.

   Don't assume that '.' is in the path for command execution.  When you
need to run programs that are a part of your package during the make,
please make sure that it uses './' if the program is built as part of
the make or '$(srcdir)/' if the file is an unchanging part of the source
code.  Without one of these prefixes, the current search path is used.

   The distinction between './' (the "build directory") and '$(srcdir)/'
(the "source directory") is important because users can build in a
separate directory using the '--srcdir' option to 'configure'.  A rule
of the form:

     foo.1 : foo.man sedscript
             sed -f sedscript foo.man > foo.1

will fail when the build directory is not the source directory, because
'foo.man' and 'sedscript' are in the source directory.

   When using GNU 'make', relying on 'VPATH' to find the source file
will work in the case where there is a single dependency file, since the
'make' automatic variable '$<' will represent the source file wherever
it is.  (Many versions of 'make' set '$<' only in implicit rules.)  A
Makefile target like

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o

should instead be written as

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@

in order to allow 'VPATH' to work correctly.  When the target has
multiple dependencies, using an explicit '$(srcdir)' is the easiest way
to make the rule work well.  For example, the target above for 'foo.1'
is best written as:

     foo.1 : foo.man sedscript
             sed -f $(srcdir)/sedscript $(srcdir)/foo.man > $@

   GNU distributions usually contain some files which are not source
files--for example, Info files, and the output from Autoconf, Automake,
Bison or Flex.  Since these files normally appear in the source
directory, they should always appear in the source directory, not in the
build directory.  So Makefile rules to update them should put the
updated files in the source directory.

   However, if a file does not appear in the distribution, then the
Makefile should not put it in the source directory, because building a
program in ordinary circumstances should not modify the source directory
in any way.

   Try to make the build and installation targets, at least (and all
their subtargets) work correctly with a parallel 'make'.

==============================================================================
File: make.info,  Node: |Utilities_in_Makefiles|,  Next: |Command_Variables|,  Prev: |Makefile_Basics|,  Up: |Makefile_Conventions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *Utilities_in_Makefiles*

16.2 Utilities in Makefiles
---------------------------

Write the Makefile commands (and any shell scripts, such as 'configure')
to run under 'sh' (both the traditional Bourne shell and the POSIX
shell), not 'csh'.  Don't use any special features of 'ksh' or 'bash',
or POSIX features not widely supported in traditional Bourne 'sh'.

   The 'configure' script and the Makefile rules for building and
installation should not use any utilities directly except these:

     awk cat cmp cp diff echo egrep expr false grep install-info ln ls
     mkdir mv printf pwd rm rmdir sed sleep sort tar test touch tr true

   Compression programs such as 'gzip' can be used in the 'dist' rule.

   Generally, stick to the widely-supported (usually POSIX-specified)
options and features of these programs.  For example, don't use 'mkdir
-p', convenient as it may be, because a few systems don't support it at
all and with others, it is not safe for parallel execution.  For a list
of known incompatibilities, see *note Portable Shell Programming:
(autoconf)Portable Shell.

   It is a good idea to avoid creating symbolic links in makefiles,
since a few file systems don't support them.

   The Makefile rules for building and installation can also use
compilers and related programs, but should do so via 'make' variables so
that the user can substitute alternatives.  Here are some of the
programs we mean:

     ar bison cc flex install ld ldconfig lex
     make makeinfo ranlib texi2dvi yacc

   Use the following 'make' variables to run those programs:

     $(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
     $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)

   When you use 'ranlib' or 'ldconfig', you should make sure nothing bad
happens if the system does not have the program in question.  Arrange to
ignore an error from that command, and print a message before the
command to tell the user that failure of this command does not mean a
problem.  (The Autoconf 'AC_PROG_RANLIB' macro can help with this.)

   If you use symbolic links, you should implement a fallback for
systems that don't have symbolic links.

   Additional utilities that can be used via Make variables are:

     chgrp chmod chown mknod

   It is ok to use other utilities in Makefile portions (or scripts)
intended only for particular systems where you know those utilities
exist.

==============================================================================
File: make.info,  Node: |Command_Variables|,  Next: |DESTDIR|,  Prev: |Utilities_in_Makefiles|,  Up: |Makefile_Conventions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 *Command_Variables*

16.3 Variables for Specifying Commands
--------------------------------------

Makefiles should provide variables for overriding certain commands,
options, and so on.

   In particular, you should run most utility programs via variables.
Thus, if you use Bison, have a variable named 'BISON' whose default
value is set with 'BISON = bison', and refer to it with '$(BISON)'
whenever you need to use Bison.

   File management utilities such as 'ln', 'rm', 'mv', and so on, need
not be referred to through variables in this way, since users don't need
to replace them with other programs.

   Each program-name variable should come with an options variable that
is used to supply options to the program.  Append 'FLAGS' to the
program-name variable name to get the options variable name--for
example, 'BISONFLAGS'.  (The names 'CFLAGS' for the C compiler, 'YFLAGS'
for yacc, and 'LFLAGS' for lex, are exceptions to this rule, but we keep
them because they are standard.)  Use 'CPPFLAGS' in any compilation
command that runs the preprocessor, and use 'LDFLAGS' in any compilation
command that does linking as well as in any direct use of 'ld'.

   If there are C compiler options that _must_ be used for proper
compilation of certain files, do not include them in 'CFLAGS'.  Users
expect to be able to specify 'CFLAGS' freely themselves.  Instead,
arrange to pass the necessary options to the C compiler independently of
'CFLAGS', by writing them explicitly in the compilation commands or by
defining an implicit rule, like this:

     CFLAGS = -g
     ALL_CFLAGS = -I. $(CFLAGS)
     .c.o:
             $(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $<

   Do include the '-g' option in 'CFLAGS', because that is not
_required_ for proper compilation.  You can consider it a default that
is only recommended.  If the package is set up so that it is compiled
with GCC by default, then you might as well include '-O' in the default
value of 'CFLAGS' as well.

   Put 'CFLAGS' last in the compilation command, after other variables
containing compiler options, so the user can use 'CFLAGS' to override
the others.

   'CFLAGS' should be used in every invocation of the C compiler, both
those which do compilation and those which do linking.

   Every Makefile should define the variable 'INSTALL', which is the
basic command for installing a file into the system.

   Every Makefile should also define the variables 'INSTALL_PROGRAM' and
'INSTALL_DATA'.  (The default for 'INSTALL_PROGRAM' should be
'$(INSTALL)'; the default for 'INSTALL_DATA' should be '${INSTALL} -m
644'.)  Then it should use those variables as the commands for actual
installation, for executables and non-executables respectively.  Minimal
use of these variables is as follows:

     $(INSTALL_PROGRAM) foo $(bindir)/foo
     $(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a

   However, it is preferable to support a 'DESTDIR' prefix on the target
files, as explained in the next section.

   It is acceptable, but not required, to install multiple files in one
command, with the final argument being a directory, as in:

     $(INSTALL_PROGRAM) foo bar baz $(bindir)

==============================================================================
File: make.info,  Node: |DESTDIR|,  Next: |Directory_Variables|,  Prev: |Command_Variables|,  Up: |Makefile_Conventions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *DESTDIR*

16.4 'DESTDIR': Support for Staged Installs
-------------------------------------------

'DESTDIR' is a variable prepended to each installed target file, like
this:

     $(INSTALL_PROGRAM) foo $(DESTDIR)$(bindir)/foo
     $(INSTALL_DATA) libfoo.a $(DESTDIR)$(libdir)/libfoo.a

   The 'DESTDIR' variable is specified by the user on the 'make' command
line as an absolute file name.  For example:

     make DESTDIR=/tmp/stage install

'DESTDIR' should be supported only in the 'install*' and 'uninstall*'
targets, as those are the only targets where it is useful.

   If your installation step would normally install '/usr/local/bin/foo'
and '/usr/local/lib/libfoo.a', then an installation invoked as in the
example above would install '/tmp/stage/usr/local/bin/foo' and
'/tmp/stage/usr/local/lib/libfoo.a' instead.

   Prepending the variable 'DESTDIR' to each target in this way provides
for "staged installs", where the installed files are not placed directly
into their expected location but are instead copied into a temporary
location ('DESTDIR').  However, installed files maintain their relative
directory structure and any embedded file names will not be modified.

   You should not set the value of 'DESTDIR' in your 'Makefile' at all;
then the files are installed into their expected locations by default.
Also, specifying 'DESTDIR' should not change the operation of the
software in any way, so its value should not be included in any file
contents.

   'DESTDIR' support is commonly used in package creation.  It is also
helpful to users who want to understand what a given package will
install where, and to allow users who don't normally have permissions to
install into protected areas to build and install before gaining those
permissions.  Finally, it can be useful with tools such as 'stow', where
code is installed in one place but made to appear to be installed
somewhere else using symbolic links or special mount operations.  So, we
strongly recommend GNU packages support 'DESTDIR', though it is not an
absolute requirement.

==============================================================================
File: make.info,  Node: |Directory_Variables|,  Next: |Standard_Targets|,  Prev: |DESTDIR|,  Up: |Makefile_Conventions|
==============================================================================

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               *Directory_Variables*

16.5 Variables for Installation Directories
-------------------------------------------

Installation directories should always be named by variables, so it is
easy to install in a nonstandard place.  The standard names for these
variables and the values they should have in GNU packages are described
below.  They are based on a standard file system layout; variants of it
are used in GNU/Linux and other modern operating systems.

   Installers are expected to override these values when calling 'make'
(e.g., 'make prefix=/usr install') or 'configure' (e.g., 'configure
--prefix=/usr').  GNU packages should not try to guess which value
should be appropriate for these variables on the system they are being
installed onto: use the default settings specified here so that all GNU
packages behave identically, allowing the installer to achieve any
desired layout.

   All installation directories, and their parent directories, should be
created (if necessary) before they are installed into.

   These first two variables set the root for the installation.  All the
other installation directories should be subdirectories of one of these
two, and nothing should be directly installed into these two
directories.

'prefix'
     A prefix used in constructing the default values of the variables
     listed below.  The default value of 'prefix' should be
     '/usr/local'.  When building the complete GNU system, the prefix
     will be empty and '/usr' will be a symbolic link to '/'.  (If you
     are using Autoconf, write it as '@prefix@'.)

     Running 'make install' with a different value of 'prefix' from the
     one used to build the program should _not_ recompile the program.
     vim:tw=78:ts=8:ft=help:norl:
vim:ft=help bt=nowrite bufhidden=delete readonly nomodifiable nobuflisted:
